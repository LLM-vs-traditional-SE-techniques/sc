import org.elasticsearch.action.index.*;
import org.elasticsearch.ElasticsearchGenerationException;
import org.elasticsearch.Version;
import org.elasticsearch.action.ActionRequestValidationException;
import org.elasticsearch.action.CompositeIndicesRequest;
import org.elasticsearch.action.DocWriteRequest;
import org.elasticsearch.action.RoutingMissingException;
import org.elasticsearch.action.support.replication.ReplicatedWriteRequest;
import org.elasticsearch.action.support.replication.ReplicationRequest;
import org.elasticsearch.client.Requests;
import org.elasticsearch.cluster.metadata.MappingMetaData;
import org.elasticsearch.cluster.metadata.MetaData;
import org.elasticsearch.common.Nullable;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.bytes.BytesArray;
import org.elasticsearch.common.bytes.BytesReference;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;
import org.elasticsearch.common.lucene.uid.Versions;
import org.elasticsearch.common.unit.ByteSizeValue;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentFactory;
import org.elasticsearch.common.xcontent.XContentHelper;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.IndexSettings;
import org.elasticsearch.index.VersionType;
import org.elasticsearch.index.shard.ShardId;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import static org.elasticsearch.action.ValidateActions.addValidationError;
import java.util.*;

import org.elasticsearch.Version;
import org.elasticsearch.action.ActionRequestValidationException;
import org.elasticsearch.action.DocWriteRequest;
import org.elasticsearch.action.support.ActiveShardCount;
import org.elasticsearch.action.support.replication.ReplicationResponse;
import org.elasticsearch.common.bytes.BytesArray;
import org.elasticsearch.common.io.stream.BytesStreamOutput;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.unit.ByteSizeValue;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.VersionType;
import org.elasticsearch.index.seqno.SequenceNumbers;
import org.elasticsearch.index.shard.ShardId;
import org.elasticsearch.rest.RestStatus;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import static org.junit.Assert.*;
import org.junit.Test;

import org.junit.*;


public class CodexTest_0_8_77 { 
  @Test
    public void testSerialization() throws IOException {
        IndexRequest testRequest = new IndexRequest("index", "type", "id");
        String[] includes = new String[]{"path1.*"};
        String[] excludes = Strings.EMPTY_ARRAY;
        int version = randomIntBetween(0, Integer.MAX_VALUE);
        long versionType = randomFrom(VersionType.values()).getValue();
        String routing = randomRealisticUnicodeOfCodepointLengthBetween(1, 128);
        String parent = randomRealisticUnicodeOfCodepointLengthBetween(1, 128);
        String timestamp = randomRealisticUnicodeOfCodepointLengthBetween(1, 128);
        long ttl = randomNonNegativeLong();
        String pipeline = randomRealisticUnicodeOfCodepointLengthBetween(1, 10);
        BytesReference source = BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", "value").endObject());
        BytesReference template = BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("template", "value").endObject());
        ActiveShardCount waitForActiveShards = ActiveShardCount.parseString(randomRealisticUnicodeOfCodepointLengthBetween(1, 10));
        ReplicationRequest.OpType opType = randomFrom(ReplicationRequest.OpType.values());
        long autoGeneratedTimestamp = randomBoolean() ? IndexRequest.UNSET_AUTO_GENERATED_TIMESTAMP : randomNonNegativeLong();
        boolean refresh = randomBoolean();
        DocWriteRequest.OpType operationType = randomFrom(DocWriteRequest.OpType.values());
        String versionTypeString = randomFrom(VersionType.values()).name().toLowerCase(Locale.ROOT);
        String waitForActiveShardsString = waitForActiveShards.toString().toLowerCase(Locale.ROOT);
        testRequest.routing(routing);
        Map<String, String> parameters = new HashMap<>();
        parameters.put("routing", routing);
        if (randomBoolean()) {
            testRequest.
}