test,file,project
"public String testsetDirTipText() {
    return ""The directory containing the test sets."";
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public File getTestsetDir() {
    return m_TestsetDir;
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public void setTestsetDir(File value) {
    m_TestsetDir = value;
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public String testsetPrefixTipText() {
    return ""The prefix to use for the filename of the test sets."";
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public String getTestsetPrefix() {
    return m_TestsetPrefix;
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public void setTestsetPrefix(String value) {
    m_TestsetPrefix = value;
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public String testsetSuffixTipText() {
    return ""The suffix to use for the filename of the test sets - must contain ""
      + ""the file extension."";
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public String getTestsetSuffix() {
    return m_TestsetSuffix;
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"public void setTestsetSuffix(String value) {
    if ((value == null) || (value.length() == 0)) {
      value = DEFAULT_SUFFIX;
    }
    m_TestsetSuffix = value;
  }",./weka/src/main/java/weka/experiment/ExplicitTestsetResultProducer.java,weka-master
"protected String templateString(Instance template) {

    String result = """";
    for (int m_DatasetKeyColumn : m_DatasetKeyColumns) {
      result += template.toString(m_DatasetKeyColumn) + ' ';
    }
    if (result.startsWith(""weka.classifiers."")) {
      result = result.substring(""weka.classifiers."".length());
    }
    return result.trim();
  }",./weka/src/main/java/weka/experiment/PairedTTester.java,weka-master
"@Override
  public PairedStats calculateStatistics(Instance datasetSpecifier,
    int resultset1Index, int resultset2Index, int comparisonColumn)
    throws Exception {

    if (m_Instances.attribute(comparisonColumn).type() != Attribute.NUMERIC) {
      throw new Exception(""Comparison column "" + (comparisonColumn + 1) + "" (""
        + m_Instances.attribute(comparisonColumn).name() + "") is not numeric"");
    }
    if (!m_ResultsetsValid) {
      prepareData();
    }

    Resultset resultset1 = m_Resultsets.get(resultset1Index);
    Resultset resultset2 = m_Resultsets.get(resultset2Index);
    ArrayList<Instance> dataset1 = resultset1.dataset(datasetSpecifier);
    ArrayList<Instance> dataset2 = resultset2.dataset(datasetSpecifier);
    String datasetName = templateString(datasetSpecifier);
    if (dataset1 == null) {
      throw new Exception(""No results for dataset="" + datasetName
        + "" for resultset="" + resultset1.templateString());
    } else if (dataset2 == null) {
      throw new Exception(""No results for dataset="" + datasetName
        + "" for resultset="" + resultset2.templateString());
    } else if (dataset1.size() != dataset2.size()) {
      throw new Exception(""Results for dataset="" + datasetName
        + "" differ in size for resultset="" + resultset1.templateString()
        + "" and resultset="" + resultset2.templateString());
    }

    PairedStats pairedStats = new PairedStats(m_SignificanceLevel);

    for (int k = 0; k < dataset1.size(); k++) {
      Instance current1 = dataset1.get(k);
      Instance current2 = dataset2.get(k);
      if (current1.isMissing(comparisonColumn)) {
        System.err.println(""Instance has missing value in comparison ""
          + ""column!\n"" + current1);
        continue;
      }
      if (current2.isMissing(comparisonColumn)) {
        System.err.println(""Instance has missing value in comparison ""
          + ""column!\n"" + current2);
        continue;
      }
      if (current1.value(m_RunColumn) != current2.value(m_RunColumn)) {
        System.err.println(""Run numbers do not match!\n"" + current1 + current2);
      }
      if (m_FoldColumn != -1) {
        if (current1.value(m_FoldColumn) != current2.value(m_FoldColumn)) {
          System.err.println(""Fold numbers do not match!\n"" + current1
            + current2);
        }
      }
      double value1 = current1.value(comparisonColumn);
      double value2 = current2.value(comparisonColumn);
      pairedStats.add(value1, value2);
    }
    pairedStats.calculateDerived();
    // System.err.println(""Differences stats:\n"" +
    // pairedStats.differencesStats);
    return pairedStats;

  }",./weka/src/main/java/weka/experiment/PairedTTester.java,weka-master
"@Override
  public PairedStats calculateStatistics(Instance datasetSpecifier,
    int resultset1Index, int resultset2Index, int comparisonColumn)
    throws Exception {

    if (m_Instances.attribute(comparisonColumn).type() != Attribute.NUMERIC) {
      throw new Exception(""Comparison column "" + (comparisonColumn + 1) + "" (""
        + m_Instances.attribute(comparisonColumn).name() + "") is not numeric"");
    }
    if (!m_ResultsetsValid) {
      prepareData();
    }

    Resultset resultset1 = (Resultset) m_Resultsets.get(resultset1Index);
    Resultset resultset2 = (Resultset) m_Resultsets.get(resultset2Index);
    ArrayList<Instance> dataset1 = resultset1.dataset(datasetSpecifier);
    ArrayList<Instance> dataset2 = resultset2.dataset(datasetSpecifier);
    String datasetName = templateString(datasetSpecifier);
    if (dataset1 == null) {
      throw new Exception(""No results for dataset="" + datasetName
        + "" for resultset="" + resultset1.templateString());
    } else if (dataset2 == null) {
      throw new Exception(""No results for dataset="" + datasetName
        + "" for resultset="" + resultset2.templateString());
    } else if (dataset1.size() != dataset2.size()) {
      throw new Exception(""Results for dataset="" + datasetName
        + "" differ in size for resultset="" + resultset1.templateString()
        + "" and resultset="" + resultset2.templateString());
    }

    // calculate the test/train ratio
    double testTrainRatio = 0.0;
    int trainSizeIndex = -1;
    int testSizeIndex = -1;
    // find the columns with the train/test sizes
    for (int i = 0; i < m_Instances.numAttributes(); i++) {
      if (m_Instances.attribute(i).name().toLowerCase()
        .equals(""number_of_training_instances"")) {
        trainSizeIndex = i;
      } else if (m_Instances.attribute(i).name().toLowerCase()
        .equals(""number_of_testing_instances"")) {
        testSizeIndex = i;
      }
    }
    if (trainSizeIndex >= 0 && testSizeIndex >= 0) {
      double totalTrainSize = 0.0;
      double totalTestSize = 0.0;
      for (int k = 0; k < dataset1.size(); k++) {
        Instance current = dataset1.get(k);
        totalTrainSize += current.value(trainSizeIndex);
        totalTestSize += current.value(testSizeIndex);
      }
      testTrainRatio = totalTestSize / totalTrainSize;
    }
    PairedStats pairedStats = new PairedStatsCorrected(m_SignificanceLevel,
      testTrainRatio);

    for (int k = 0; k < dataset1.size(); k++) {
      Instance current1 = dataset1.get(k);
      Instance current2 = dataset2.get(k);
      if (current1.isMissing(comparisonColumn)) {
        System.err.println(""Instance has missing value in comparison ""
          + ""column!\n"" + current1);
        continue;
      }
      if (current2.isMissing(comparisonColumn)) {
        System.err.println(""Instance has missing value in comparison ""
          + ""column!\n"" + current2);
        continue;
      }
      if (current1.value(m_RunColumn) != current2.value(m_RunColumn)) {
        System.err.println(""Run numbers do not match!\n"" + current1 + current2);
      }
      if (m_FoldColumn != -1) {
        if (current1.value(m_FoldColumn) != current2.value(m_FoldColumn)) {
          System.err.println(""Fold numbers do not match!\n"" + current1
            + current2);
        }
      }

      double value1 = current1.value(comparisonColumn);
      double value2 = current2.value(comparisonColumn);
      pairedStats.add(value1, value2);
    }
    pairedStats.calculateDerived();
    return pairedStats;
  }",./weka/src/main/java/weka/experiment/PairedCorrectedTTester.java,weka-master
"public BASELINETESTSTATISTIC getTestStatistic() {
        return testStatistic;
    }",./weka/src/main/java/weka/core/pmml/jaxbbindings/TestDistributions.java,weka-master
"public void setTestStatistic(BASELINETESTSTATISTIC value) {
        this.testStatistic = value;
    }",./weka/src/main/java/weka/core/pmml/jaxbbindings/TestDistributions.java,weka-master
"public TestInstances() {
    super();

    setRelation(""Testdata"");
    setSeed(1);
    setNumInstances(20);
    setClassType(Attribute.NOMINAL);
    setNumClasses(2);
    setClassIndex(CLASS_IS_LAST);
    setNumNominal(1);
    setNumNominalValues(2);
    setNumNumeric(0);
    setNumString(0);
    setNumDate(0);
    setNumRelational(0);
    setNumRelationalNominal(1);
    setNumRelationalNominalValues(2);
    setNumRelationalNumeric(0);
    setNumRelationalString(0);
    setNumRelationalDate(0);
    setNumInstancesRelational(10);
    setMultiInstance(false);
    setWords(arrayToList(DEFAULT_WORDS));
    setWordSeparators(DEFAULT_SEPARATORS);
  }",./weka/src/main/java/weka/core/TestInstances.java,weka-master
"public TestSetMaker() {
    m_visual.loadIcons(BeanVisual.ICON_PATH + ""TestSetMaker.gif"",
      BeanVisual.ICON_PATH + ""TestSetMaker_animated.gif"");
    m_visual.setText(""TestSetMaker"");
  }",./weka/src/main/java/weka/gui/beans/TestSetMaker.java,weka-master
"@SuppressWarnings(""unchecked"")
  protected void notifyTestSetProduced(TestSetEvent tse) {
    Vector<TestSetListener> l;
    synchronized (this) {
      l = (Vector<TestSetListener>) m_listeners.clone();
    }
    if (l.size() > 0) {
      for (int i = 0; i < l.size(); i++) {
        if (m_receivedStopNotification) {
          if (m_logger != null) {
            m_logger.logMessage(""[TestSetMaker] "" + statusMessagePrefix()
              + "" stopping."");
            m_logger.statusMessage(statusMessagePrefix() + ""INTERRUPTED"");
          }
          m_receivedStopNotification = false;
          break;
        }
        l.elementAt(i).acceptTestSet(tse);
      }
    }
  }",./weka/src/main/java/weka/gui/beans/TestSetMaker.java,weka-master
"public TrainTestSplitMaker() {
    m_visual.loadIcons(BeanVisual.ICON_PATH + ""TrainTestSplitMaker.gif"",
      BeanVisual.ICON_PATH + ""TrainTestSplittMaker_animated.gif"");
    m_visual.setText(""TrainTestSplitMaker"");
  }",./weka/src/main/java/weka/gui/beans/TrainTestSplitMaker.java,weka-master
"@Override
  public void acceptTestSet(TestSetEvent e) {
    Instances testSet = e.getTestSet();
    DataSetEvent dse = new DataSetEvent(this, testSet);
    acceptDataSet(dse);
  }",./weka/src/main/java/weka/gui/beans/TrainTestSplitMaker.java,weka-master
"@SuppressWarnings(""unchecked"")
  protected void notifyTestSetProduced(TestSetEvent tse) {
    Vector<TestSetListener> l;
    synchronized (this) {
      l = (Vector<TestSetListener>) m_testListeners.clone();
    }
    if (l.size() > 0) {
      for (int i = 0; i < l.size(); i++) {
        if (m_splitThread == null) {
          break;
        }
        // System.err.println(""Notifying test listeners ""
        // +""(Train - test split maker)"");
        l.elementAt(i).acceptTestSet(tse);
      }
    }
  }",./weka/src/main/java/weka/gui/beans/TrainTestSplitMaker.java,weka-master
"public TestSetEvent(Object source, Instances testSet) {
    super(source);
    m_testSet = testSet;
    if (m_testSet != null && m_testSet.numInstances() == 0) {
      m_structureOnly = true;
    }
  }",./weka/src/main/java/weka/gui/beans/TestSetEvent.java,weka-master
"public TestSetEvent(Object source, Instances testSet, 
                      int setNum, int maxSetNum) {
    this(source, testSet);
    m_setNumber = setNum;
    m_maxSetNumber = maxSetNum;
  }",./weka/src/main/java/weka/gui/beans/TestSetEvent.java,weka-master
"public TestSetEvent(Object source, Instances testSet,
      int runNum, int maxRunNum, int setNum, int maxSetNum) {
    this(source, testSet, setNum, maxSetNum);
    
    m_runNumber = runNum;
    m_maxRunNumber = maxRunNum;
  }",./weka/src/main/java/weka/gui/beans/TestSetEvent.java,weka-master
"public Instances getTestSet() {
    return m_testSet;
  }",./weka/src/main/java/weka/gui/beans/TestSetEvent.java,weka-master
"public AbstractTrainAndTestSetProducer() {
    setLayout(new BorderLayout());
    add(m_visual, BorderLayout.CENTER);
  }",./weka/src/main/java/weka/gui/beans/AbstractTrainAndTestSetProducer.java,weka-master
"@Override
  public synchronized void addTestSetListener(TestSetListener tsl) {
    m_testListeners.addElement(tsl);
  }",./weka/src/main/java/weka/gui/beans/AbstractTrainAndTestSetProducer.java,weka-master
"@Override
  public synchronized void removeTestSetListener(TestSetListener tsl) {
    m_testListeners.removeElement(tsl);
  }",./weka/src/main/java/weka/gui/beans/AbstractTrainAndTestSetProducer.java,weka-master
"public AbstractTestSetProducer() {

    setLayout(new BorderLayout());
    add(m_visual, BorderLayout.CENTER);
  }",./weka/src/main/java/weka/gui/beans/AbstractTestSetProducer.java,weka-master
"@Override
  public synchronized void addTestSetListener(TestSetListener tsl) {
    m_listeners.addElement(tsl);
  }",./weka/src/main/java/weka/gui/beans/AbstractTestSetProducer.java,weka-master
"@Override
  public synchronized void removeTestSetListener(TestSetListener tsl) {
    m_listeners.removeElement(tsl);
  }",./weka/src/main/java/weka/gui/beans/AbstractTestSetProducer.java,weka-master
"public TrainTestSplitMakerCustomizer() {
    setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 5, 5, 5));
    
    setLayout(new BorderLayout());
    add(m_splitEditor, BorderLayout.CENTER);
    add(new javax.swing.JLabel(""TrainTestSplitMakerCustomizer""), 
	BorderLayout.NORTH);
  }",./weka/src/main/java/weka/gui/beans/TrainTestSplitMakerCustomizer.java,weka-master
"public Test(int i, double s, Instances dataset) {
    m_AttIndex = i;
    m_Split = s;
    m_Dataset = dataset;

    m_Not = false;
  }",./weka/src/main/java/weka/datagenerators/Test.java,weka-master
"public Test(int i, double s, Instances dataset, boolean n) {
    m_AttIndex = i;
    m_Split = s;
    m_Dataset = dataset;
    m_Not = n;
  }",./weka/src/main/java/weka/datagenerators/Test.java,weka-master
"public boolean passesTest(Instance inst) throws Exception {
    if (inst.isMissing(m_AttIndex)) {
      return false; // missing values fail
    }

    boolean isNominal = inst.attribute(m_AttIndex).isNominal();
    double attribVal = inst.value(m_AttIndex);
    if (!m_Not) {
      if (isNominal) {
        if (((int) attribVal) != ((int) m_Split)) {
          return false;
        }
      } else if (attribVal >= m_Split) {
        return false;
      }
    } else {
      if (isNominal) {
        if (((int) attribVal) == ((int) m_Split)) {
          return false;
        }
      } else if (attribVal < m_Split) {
        return false;
      }
    }
    return true;
  }",./weka/src/main/java/weka/datagenerators/Test.java,weka-master
"private String testComparisonString() {
    Attribute att = m_Dataset.attribute(m_AttIndex);
    if (att.isNumeric()) {
      return ((m_Not ? "">= "" : ""< "") + Utils.doubleToString(m_Split, 3));
    } else {
      if (att.numValues() != 2) {
        return ((m_Not ? ""!= "" : ""= "") + att.value((int) m_Split));
      } else {
        return (""= "" + (m_Not ? att.value((int) m_Split == 0 ? 1 : 0) : att
          .value((int) m_Split)));
      }
    }
  }",./weka/src/main/java/weka/datagenerators/Test.java,weka-master
"public OneRAttributeEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/OneRAttributeEvalTest.java,weka-master
"public InfoGainAttributeEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/InfoGainAttributeEvalTest.java,weka-master
"public WrapperSubsetEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/WrapperSubsetEvalTest.java,weka-master
"public BestFirstTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/BestFirstTest.java,weka-master
"public AbstractSearchTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/attributeSelection/AbstractSearchTest.java,weka-master
"protected CheckAttributeSelection getTester() {
    CheckAttributeSelection	result;
    
    result = super.getTester();
    result.setTestEvaluator(false);
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractSearchTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = super.getOptionTester();
    if (getSearch() instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) getSearch());
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractSearchTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;

    result = super.getGOETester();
    result.setObject(getSearch());
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractSearchTest.java,weka-master
"public SymmetricalUncertAttributeEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/SymmetricalUncertAttributeEvalTest.java,weka-master
"public GreedyStepwiseTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/GreedyStepwiseTest.java,weka-master
"public ReliefFAttributeEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/ReliefFAttributeEvalTest.java,weka-master
"public CfsSubsetEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/CfsSubsetEvalTest.java,weka-master
"public PrincipalComponentsTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/PrincipalComponentsTest.java,weka-master
"public AbstractEvaluatorTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/attributeSelection/AbstractEvaluatorTest.java,weka-master
"protected CheckAttributeSelection getTester() {
    CheckAttributeSelection	result;
    
    result = super.getTester();
    result.setTestEvaluator(true);
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractEvaluatorTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = super.getOptionTester();
    if (getEvaluator() instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) getEvaluator());
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractEvaluatorTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;

    result = super.getGOETester();
    result.setObject(getEvaluator());
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractEvaluatorTest.java,weka-master
"public RankerTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/RankerTest.java,weka-master
"public AbstractAttributeSelectionTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"protected CheckAttributeSelection getTester() {
    CheckAttributeSelection	result;
    
    result = new CheckAttributeSelection();
    result.setSilent(true);
    result.setSearch(m_Search);
    result.setEvaluator(m_Evaluator);
    result.setNumInstances(20);
    result.setDebug(DEBUG);
    result.setPostProcessor(getPostProcessor());
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = new CheckOptionHandler();
    result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;
    
    result = new CheckGOE();
    result.setObject(null);
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testAttributes() {
    // nominal
    checkAttributes(true,  false, false, false, false, true);
    // numeric
    checkAttributes(false, true,  false, false, false, true);
    // string
    checkAttributes(false, false, true,  false, false, true);
    // date
    checkAttributes(false, false, false, true,  false, true);
    // relational
    if (!m_multiInstanceHandler)
      checkAttributes(false, false, false, false, true,  true);
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testSerialVersionUID() {
    boolean[]     result;

    result = m_Tester.declaresSerialVersionUID();

    if (!result[0])
      fail(""Doesn't declare serialVersionUID!"");
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testInstanceWeights() {
    boolean[]     result;
    int           i;
    
    if (m_weightedInstancesHandler) {
      for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
        // does the scheme support this type of class at all?
        if (!canPredict(i))
          continue;
        
        result = m_Tester.instanceWeights(
            m_NominalPredictors[i], 
            m_NumericPredictors[i], 
            m_StringPredictors[i], 
            m_DatePredictors[i], 
            m_RelationalPredictors[i], 
            m_multiInstanceHandler, 
            i);

        if (!result[0])
          System.err.println(""Error handling instance weights ("" + getClassTypeString(i) 
              + "" class)!"");
      }
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testNClasses() {
    boolean[]     result;

    if (!canPredict(Attribute.NOMINAL))
      return;

    result = m_Tester.canHandleNClasses(
        m_NominalPredictors[Attribute.NOMINAL],
        m_NumericPredictors[Attribute.NOMINAL],
        m_StringPredictors[Attribute.NOMINAL],
        m_DatePredictors[Attribute.NOMINAL],
        m_RelationalPredictors[Attribute.NOMINAL],
        m_multiInstanceHandler,
        m_NClasses);

    if (!result[0] && !result[1])
      fail(""Error handling "" + m_NClasses + "" classes!"");
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testClassAsNthAttribute() {
    int           i;
    
    // multi-Instance data has fixed format!
    if (m_multiInstanceHandler)
      return;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the scheme support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // first attribute
      m_handleClassAsFirstAttribute[i] = checkClassAsNthAttribute(i, 0);

      // second attribute
      m_handleClassAsSecondAttribute[i] = checkClassAsNthAttribute(i, 1);
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testZeroTraining() {
    boolean[]     result;
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the scheme support this type of class at all?
      if (!canPredict(i))
        continue;
      
      result = m_Tester.canHandleZeroTraining(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          i);

      if (!result[0] && !result[1])
        fail(""Error handling zero training instances ("" + getClassTypeString(i) 
            + "" class)!"");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testMissingPredictors() {
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the scheme support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // 20% missing
      checkMissingPredictors(i, 20, true);

      // 100% missing
      if (m_handleMissingPredictors[i])
        checkMissingPredictors(i, 100, true);
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testMissingClass() {
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the scheme support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // 20% missing
      checkMissingClass(i, 20, true);

      // 100% missing
      if (m_handleMissingClass[i])
        checkMissingClass(i, 100, true);
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testBuildInitialization() {
    boolean[]     result;
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the scheme support this type of class at all?
      if (!canPredict(i))
        continue;
      
      result = m_Tester.correctSearchInitialisation(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          i);

      if (!result[0] && !result[1])
        fail(""Incorrect build initialization ("" + getClassTypeString(i) 
            + "" class)!"");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testDatasetIntegrity() {
    boolean[]     result;
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the scheme support this type of class at all?
      if (!canPredict(i))
        continue;
      
      result = m_Tester.datasetIntegrity(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          i,
          m_handleMissingPredictors[i],
          m_handleMissingClass[i]);

      if (!result[0] && !result[1])
        fail(""Dataset is altered during training ("" 
            + getClassTypeString(i) + "" class)!"");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testRegression() throws Exception {
    int		i;
    boolean	succeeded;
    Regression 	reg;
    Instances   train;
    
    // don't bother if not working correctly
    if (m_Tester.hasClasspathProblems())
      return;
    
    reg = new Regression(this.getClass());
    succeeded = false;
    train = null;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the scheme support this type of class at all?
      if (!canPredict(i))
        continue;
        
      train = m_Tester.makeTestDataset(
          42, m_Tester.getNumInstances(), 
  	  m_NominalPredictors[i] ? 2 : 0,
  	  m_NumericPredictors[i] ? 1 : 0, 
          m_StringPredictors[i] ? 1 : 0,
          m_DatePredictors[i] ? 1 : 0,
          m_RelationalPredictors[i] ? 1 : 0,
          2, 
          i,
          m_multiInstanceHandler);
  
      try {
        m_RegressionResults[i] = useScheme(train);
        succeeded = true;
        reg.println(m_RegressionResults[i]);
      }
      catch (Exception e) {
	String msg = e.getMessage().toLowerCase();
	if (msg.indexOf(""not in classpath"") > -1)
	  return;

	m_RegressionResults[i] = null;
      }
    }
    
    if (!succeeded) {
      fail(""Problem during regression testing: no successful predictions for any class type"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating.""); 
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } 
    catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions())
	fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testDefaultOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkDefaultOptions())
	fail(""Default options were not processed correctly."");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions())
	fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions())
	fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo())
      fail(""No globalInfo method"");
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips())
      fail(""Tool tips inconsistent"");
  }",./weka/src/test/java/weka/attributeSelection/AbstractAttributeSelectionTest.java,weka-master
"public GainRatioAttributeEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/GainRatioAttributeEvalTest.java,weka-master
"public CorrelationAttributeEvalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/attributeSelection/CorrelationAttributeEvalTest.java,weka-master
"public HierarchicalClustererTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/HierarchicalClustererTest.java,weka-master
"public FilteredClustererTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/FilteredClustererTest.java,weka-master
"public MakeDensityBasedClustererTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/MakeDensityBasedClustererTest.java,weka-master
"public CanopyTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/CanopyTest.java,weka-master
"public EMTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/EMTest.java,weka-master
"public AbstractClustererTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = new CheckOptionHandler();
    if (getClusterer() instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) getClusterer());
    else
      result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;
    
    result = new CheckGOE();
    result.setObject(getClusterer());
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testAttributes() {
    // nominal
    checkAttributes(true,  false, false, false, false, true);
    // numeric
    checkAttributes(false, true,  false, false, false, true);
    // string
    checkAttributes(false, false, true,  false, false, true);
    // date
    checkAttributes(false, false, false, true,  false, true);
    // relational
    if (!m_multiInstanceHandler)
      checkAttributes(false, false, false, false, true,  true);
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testSerialVersionUID() {
    boolean[]     result;

    result = m_Tester.declaresSerialVersionUID();

    if (!result[0])
      fail(""Doesn't declare serialVersionUID!"");
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testInstanceWeights() {
    boolean[]     result;
    
    if (m_weightedInstancesHandler) {
      if (!canPredict())
	return;
      
      result = m_Tester.instanceWeights(
          m_NominalPredictors,
          m_NumericPredictors,
          m_StringPredictors,
          m_DatePredictors, 
          m_RelationalPredictors, 
          m_multiInstanceHandler);

      if (!result[0])
        System.err.println(""Error handling instance weights!"");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testZeroTraining() {
    boolean[]     result;
    
    if (!canPredict())
      return;
    
    result = m_Tester.canHandleZeroTraining(
        m_NominalPredictors, 
        m_NumericPredictors, 
        m_StringPredictors, 
        m_DatePredictors, 
        m_RelationalPredictors, 
        m_multiInstanceHandler);

    if (!result[0] && !result[1])
      fail(""Error handling zero training instances!"");
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testMissingPredictors() {
    if (!canPredict())
      return;
    
    // 20% missing
    checkMissingPredictors(20, true);

    // 100% missing
    if (m_handleMissingPredictors)
      checkMissingPredictors(100, true);
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testBuildInitialization() {
    boolean[]     result;
    
    if (!canPredict())
      return;
    
    result = m_Tester.correctBuildInitialisation(
        m_NominalPredictors, 
        m_NumericPredictors, 
        m_StringPredictors, 
        m_DatePredictors, 
        m_RelationalPredictors, 
        m_multiInstanceHandler);

    if (!result[0] && !result[1])
      fail(""Incorrect build initialization!"");
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testDatasetIntegrity() {
    boolean[]     result;
  
    if (!canPredict())
      return;
    
    result = m_Tester.datasetIntegrity(
        m_NominalPredictors, 
        m_NumericPredictors, 
        m_StringPredictors, 
        m_DatePredictors, 
        m_RelationalPredictors, 
        m_multiInstanceHandler, 
        m_handleMissingPredictors);

    if (!result[0] && !result[1])
      fail(""Training set is altered during training!"");
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testUpdatingEquality() {
    boolean[]     result;
    
    if (m_updateableClusterer) {
        result = m_Tester.updatingEquality(
            m_NominalPredictors, 
            m_NumericPredictors, 
            m_StringPredictors, 
            m_DatePredictors, 
            m_RelationalPredictors, 
            m_multiInstanceHandler);

        if (!result[0])
          System.err.println(
              ""Incremental training does not produce same result as batch training!"");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testRegression() throws Exception {
    boolean	succeeded;
    Regression 	reg;
    Instances   train;
    
    // don't bother if not working correctly
    if (m_Tester.hasClasspathProblems())
      return;
    
    reg       = new Regression(this.getClass());
    train     = null;
    succeeded = false;
    
    train = m_Tester.makeTestDataset(
	42, m_Tester.getNumInstances(), 
	m_NominalPredictors ? 2 : 0,
	m_NumericPredictors ? 1 : 0, 
	m_StringPredictors ? 1 : 0,
	m_DatePredictors ? 1 : 0,
	m_RelationalPredictors ? 1 : 0,
	m_multiInstanceHandler);
    
    try {
      m_RegressionResults = useClusterer(train);
      succeeded = true;
      reg.println(m_RegressionResults);
    }
    catch (Exception e) {
      String msg = e.getMessage().toLowerCase();
      if (msg.indexOf(""not in classpath"") > -1)
	return;
      
      m_RegressionResults = null;
    }
    
    if (!succeeded) {
      fail(""Problem during regression testing: no successful output generated"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating.""); 
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } 
    catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions())
	fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testDefaultOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkDefaultOptions())
	fail(""Default options were not processed correctly."");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions())
	fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions())
	fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo())
      fail(""No globalInfo method"");
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips())
      fail(""Tool tips inconsistent"");
  }",./weka/src/test/java/weka/clusterers/AbstractClustererTest.java,weka-master
"public CobwebTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/CobwebTest.java,weka-master
"public FarthestFirstTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/FarthestFirstTest.java,weka-master
"public SimpleKMeansTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/clusterers/SimpleKMeansTest.java,weka-master
"public void testInitialization() {
    checkStatsInitialized(getStats());
  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public void testStdDev() {
    Stats stats;
    
    String descr = ""Incorrect stdDev!"";
    /* We'll only focus on count > 0
     * because count <= 0 gets tested in testNegativeCount
     * And we'll only focus on values seen > 0
     * because values seen <= 0 gets tested in testNegativeCount
     */
    
    // test count <= 1 and values seen = 1
    stats = getStats();
    stats.add(1.0, 1.0);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);

    stats = getStats();
    stats.add(2.0, 0.5);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);
    
    stats = getStats();
    stats.add(-10.0, 0.10986);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);
    
    // first add then subtract
    stats = getStats();
    addWeightedStats(stats, 1.0, 1.0, 2.0, 2.0, 3.0, 1.0);
    subtractWeightedStats(stats, 1.0, 1.0, 2.0, 2.0);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);
    
    // first subtract then add
    stats = getStats();
    subtractWeightedStats(stats, 1.0, 1.0, 2.0, 2.0);
    addWeightedStats(stats, 1.0, 1.0, 2.0, 2.0, 3.0, 1.0);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);
   
    // test count <= 1 and values seen > 1
    stats = getStats();
    addWeightedStats(stats, 1.0, 0.1, 2.0, 0.2, 3.0, 0.3);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);

    stats = getStats();
    addWeightedStats(stats, 1.0, 0.2, 2.0, 0.2, 3.0, 0.4);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);
    
    // first add then subtract
    stats = getStats();
    addWeightedStats(stats, 1.0, 0.4, 2.0, 0.2, 3.0, 0.3, 4.0, 0.2);
    subtractWeightedStats(stats, 2.0, 0.2, 4.0, 0.2);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);
    
    // first subtract then add
    stats = getStats();
    subtractWeightedStats(stats, 2.0, 0.2, 4.0, 0.2);
    addWeightedStats(stats, 1.0, 0.4, 2.0, 0.2, 3.0, 0.3, 4.0, 0.2);
    stats.calculateDerived();
    assertNaN(descr, stats.stdDev);
    
    // test count > 1 and values seen > 1
    // We won't test this case as it's tested in other testcases
    
  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public void testNegativeCount() {
    
    Stats stats;
    Stats reference;
    
    // go negative right from the start
    stats = getStats();
    subtractWeightedStats(stats, weightedValues1);
    checkStatsNegativeCount(stats);
    stats.calculateDerived();
    checkStatsNegativeCount(stats);
    
    // go first positive and only afterwards negative
    stats = getStats();
    addWeightedStats(stats, weightedValues1);
    stats.calculateDerived();
    checkStatsValidState(stats);
    subtractWeightedStats(stats, weightedValues1);
    checkStatsInitialized(stats);
    stats.calculateDerived();
    checkStatsInitialized(stats);
    subtractWeightedStats(stats, weightedValues2);
    checkStatsNegativeCount(stats);
    stats.calculateDerived();
    checkStatsNegativeCount(stats);

    // go first negative and then recover
    reference = getStats();
    stats = getStats();
    subtractWeightedStats(stats, weightedValues1);
    checkStatsNegativeCount(stats);
    addWeightedStats(stats, weightedValues1);
    checkStatsInitialized(stats);
    stats.calculateDerived();
    checkStatsInitialized(stats);
    addWeightedStats(stats, weightedValues1);
    stats.calculateDerived();
    checkStatsValidState(stats);
    addWeightedStats(reference, weightedValues1);
    reference.calculateDerived();
    checkStats(stats, ""Incorrect behaviour after negative count recovry!"",
        reference, 0.0);
    
    // go first positive, then negative, then recover
    stats = getStats();
    reference = getStats();
    addWeightedStats(stats, weightedValues3);
    stats.calculateDerived();
    checkStatsValidState(stats);
    subtractWeightedStats(stats, weightedValues3);
    checkStatsInitialized(stats);
    stats.calculateDerived();
    checkStatsInitialized(stats);
    subtractWeightedStats(stats, weightedValues2);
    checkStatsNegativeCount(stats);
    stats.calculateDerived();
    checkStatsNegativeCount(stats);
    subtractWeightedStats(stats, weightedValues1);
    checkStatsNegativeCount(stats);
    stats.calculateDerived();
    checkStatsNegativeCount(stats);
    addWeightedStats(stats, weightedValues2);
    checkStatsNegativeCount(stats);
    stats.calculateDerived();
    checkStatsNegativeCount(stats);
    addWeightedStats(stats, weightedValues1);
    checkStatsInitialized(stats);
    stats.calculateDerived();
    checkStatsInitialized(stats);
    addWeightedStats(stats, weightedValues3);
    stats.calculateDerived();
    checkStatsValidState(stats);
    addWeightedStats(reference, weightedValues3);
    reference.calculateDerived();
    checkStats(stats, ""Incorrect behaviour after negative count recovery!"",
        reference, 0.0);
    
  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public void testMinMax() {
    
    Stats stats;
    stats = getStats();

    // start off with small values:
    addWeightedStats(stats, smallWeightedValues);
    double max_simple = getWeightedMax(smallWeightedValues);
    double min_simple = getWeightedMin(smallWeightedValues);
    assertEquals(""Incorrect min!"", min_simple, stats.min);
    assertEquals(""Incorrect max!"", max_simple, stats.max);

    // change min/max
    assertTrue(""Assumption violated in testcase!"",
        max_simple < getWeightedMax(weightedValues1));
    assertTrue(""Assumption violated in testcase!"",
        min_simple > getWeightedMin(weightedValues1));
    addWeightedStats(stats, weightedValues1);
    max_simple = Math.max(max_simple, getWeightedMax(weightedValues1));
    min_simple = Math.min(min_simple, getWeightedMin(weightedValues1));
    assertEquals(""Incorrect min!"", min_simple, stats.min);
    assertEquals(""Incorrect max!"", max_simple, stats.max);

    // check that min/max don't change if existing values have been added
    addWeightedStats(stats, weightedValues1);
    assertEquals(""Incorrect min!"", min_simple, stats.min);
    assertEquals(""Incorrect max!"", max_simple, stats.max);

    // add different values, but don't change min/max
    addWeightedStats(stats, weightedValues2);
    // keep track of min/max of values_added \ values_subtracted
    double max_real = max_simple;
    double min_real = min_simple;
    max_simple = Math.max(max_simple, getWeightedMax(weightedValues2));
    min_simple = Math.min(min_simple, getWeightedMin(weightedValues2));
    assertEquals(""Incorrect min!"", min_simple, stats.min);
    assertEquals(""Incorrect max!"", max_simple, stats.max);

    // subtract existing values
    subtractWeightedStats(stats, weightedValues2);
    assertEquals(""Assumption violated in testcase!"", max_simple, max_real);
    assertEquals(""Assumption violated in testcase!"", min_simple, min_real);
    assertTrue(""Incorrect min!"", min_real >= stats.min && stats.min >= min_simple);
    assertTrue(""Incorrect max!"", max_real <= stats.max && stats.max <= max_simple);
    
    // add values after subtracting
    addWeightedStats(stats, weightedValues3);
    max_simple = Math.max(max_simple, getWeightedMax(weightedValues3));
    min_simple = Math.min(min_simple, getWeightedMin(weightedValues3));
    max_real = Math.max(max_real, getWeightedMax(weightedValues3));
    min_real = Math.min(min_real, getWeightedMin(weightedValues3));
    assertTrue(""Incorrect min!"", min_real >= stats.min && stats.min >= min_simple);
    assertTrue(""Incorrect max!"", max_real <= stats.max && stats.max <= max_simple);
    
    // add bigger values
    addWeightedStats(stats, bigWeightedValues);
    max_simple = Math.max(max_simple, getWeightedMax(bigWeightedValues));
    min_simple = Math.min(min_simple, getWeightedMin(bigWeightedValues));
    assertEquals(""Incorrect min!"", min_simple, stats.min);
    assertEquals(""Incorrect max!"", max_simple, stats.max);
    
    // subtract bigger values
    subtractWeightedStats(stats, weightedValues2);
    assertTrue(""Assumption violated in testcase!"", max_simple > max_real);
    assertTrue(""Assumption violated in testcase!"", min_simple < min_real);
    assertTrue(""Incorrect min!"", min_real >= stats.min && stats.min >= min_simple);
    assertTrue(""Incorrect max!"", max_real <= stats.max && stats.max <= max_simple);

  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public void testInvalidState() {
    
    final double[] invalidValues = {
        Double.POSITIVE_INFINITY,
        Double.NEGATIVE_INFINITY,
        getNaN(), getNaN(), getNaN(), getNaN(), getNaN()
    };
    
    final double[] validValues = {
        0.0, 1.0, 2.0, 2.0, 3.0, 10.0,
        -0.0, -1.0, -2.0, -2.0, -3.0, -10.0
    };

    for (double value : invalidValues) {
      for (double weight : validValues) {
        goIntoInvalidState(value, weight);
      }
      for (double weight : invalidValues) {
        goIntoInvalidState(value, weight);
      }
    }
    for (double value : validValues) {
      for (double weight : invalidValues) {
        goIntoInvalidState(value, weight);
      }
    }
    
  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public void testZeroWeights() {

    String descr = ""Ignoring 0 weights"";
    Stats reference = getStats();
    Stats test = getStats();

    addWeightedStats(test, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, -10.0, 0.0, 10.0, 0.0);
    
    checkStatsInitialized(test);
    checkStats(test, descr, reference, 0.0);
    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);

    addWeightedStats(reference, weightedValues1);
    addWeightedStats(test, weightedValues1);

    addWeightedStats(test, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, -10.0, 0.0, 10.0, 0.0);
    
    checkStats(test, descr, reference, 0.0);
    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);
    
    addWeightedStats(reference, weightedValues2);
    addWeightedStats(test, weightedValues2);

    subtractWeightedStats(test,
        Double.MAX_VALUE, 0.0,
        Double.MAX_VALUE, -0.0, -Double.MAX_VALUE, 0.0, -Double.MAX_VALUE, -0.0,
        Double.MIN_VALUE, 0.0, Double.MIN_VALUE, -0.0, -Double.MIN_VALUE, 0.0,
        -Double.MIN_VALUE, -0.0
    );

    checkStats(test, descr, reference, 0.0);
    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);
    
    subtractWeightedStats(reference, weightedValues1);
    subtractWeightedStats(test, weightedValues1);

    subtractWeightedStats(test, 
        0.0, 0.0, -0.0, -0.0, 1e20, -0.0, 30, -0.0
    );

    checkStats(test, descr, reference, 0.0);
    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);
    
    addWeightedStats(reference, smallWeightedValues);
    addWeightedStats(test, smallWeightedValues);

    addWeightedStats(test,
        Double.MAX_VALUE, 0.0,
        Double.MAX_VALUE, -0.0, -Double.MAX_VALUE, 0.0, -Double.MAX_VALUE, -0.0,
        Double.MIN_VALUE, 0.0, Double.MIN_VALUE, -0.0, -Double.MIN_VALUE, 0.0,
        -Double.MIN_VALUE, -0.0
    );

    checkStats(test, descr, reference, 0.0);
    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);

    addWeightedStats(reference, bigWeightedValues);
    addWeightedStats(test, bigWeightedValues);

    addWeightedStats(test, 
        0.0, 0.0, 0.0, -0.0, -0.0, 0.0, -0.0, -0.0, 20, 0.0, 20, -0.0
    );

    checkStats(test, descr, reference, 0.0);
    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);
    
  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public void testNegativeWeights() {
    
    String descr = ""Incorrect handling of negative weights"";
    Stats reference = getStats();
    Stats test = getStats();
    
    final double[] positiveWeights = {
        1.0, 10.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 5.0, 5.0, 10.0, 0.1, -10.0, 0.1,
        100.0, 2.3, -100.0, 2.4
    };
    final double[] negativeWeights = {
        1.0, -10.0, 2.0, -2.0, 3.0, -3.0, 4.0, -4.0, 5.0, -5.0, 10.0, -0.1, -10.0, -0.1,
        100.0, -2.3, -100.0, -2.4
    };

    addWeightedStats(reference, positiveWeights);
    subtractWeightedStats(test, negativeWeights);

    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);

    addWeightedStats(reference, weightedValues1);
    addWeightedStats(test, weightedValues1);

    subtractWeightedStats(reference, positiveWeights);
    addWeightedStats(test, negativeWeights);

    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);
    
    addWeightedStats(reference, weightedValues2);
    addWeightedStats(test, weightedValues2);

    addWeightedStats(reference, positiveWeights);
    subtractWeightedStats(test, negativeWeights);

    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);
    
    subtractWeightedStats(reference, weightedValues1);
    subtractWeightedStats(test, weightedValues1);

    reference.calculateDerived();
    test.calculateDerived();
    checkStats(test, descr, reference, 0.0);

  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public void testAccuracy() {

    checkAccuracy(
        generatedWeightedValues1,
        generatedMean1,
        generatedStdDev1
        );

    checkAccuracy(
        generatedWeightedValues2,
        generatedMean2,
        generatedStdDev2
        );

    checkAccuracy(
        generatedWeightedValues3,
        generatedMean3,
        generatedStdDev3
        );

    checkAccuracy(
        generatedWeightedValues4,
        generatedMean4,
        generatedStdDev4,
        1e-2
        );

    checkAccuracy(
        generatedWeightedValues5,
        generatedMean5,
        generatedStdDev5,
        1e-2
        );

    checkAccuracy(
        generatedWeightedValues6,
        generatedMean6,
        generatedStdDev6,
        1e-2
        );

    checkAccuracy(
        generatedWeightedValues7,
        generatedMean7,
        generatedStdDev7
        );

    checkAccuracy(
        generatedWeightedValues8,
        generatedMean8,
        generatedStdDev8
        );

    checkAccuracy(
        generatedWeightedValues9,
        generatedMean9,
        generatedStdDev9
        );

    checkAccuracy(
        generatedWeightedValues10,
        generatedMean10,
        generatedStdDev10
        );

    checkAccuracy(
        generatedWeightedValues11,
        generatedMean11,
        generatedStdDev11
        );

    checkAccuracy(
        generatedWeightedValues12,
        generatedMean12,
        generatedStdDev12
        );

    checkAccuracy(
        generatedWeightedValues13,
        generatedMean13,
        generatedStdDev13
        );

    checkAccuracy(
        generatedWeightedValues14,
        generatedMean14,
        generatedStdDev14,
        1
        );

    checkAccuracy(
        generatedWeightedValues15,
        generatedMean15,
        generatedStdDev15
        );

    checkAccuracy(
        generatedWeightedValues16,
        generatedMean16,
        generatedStdDev16,
        1
        );

    checkAccuracy(
        generatedWeightedValues17,
        generatedMean17,
        generatedStdDev17
        );

    checkAccuracy(
        generatedWeightedValues18,
        generatedMean18,
        generatedStdDev18,
        2
        );

    checkAccuracy(
        generatedWeightedValues19,
        generatedMean19,
        generatedStdDev19
        );

    checkAccuracy(
        generatedWeightedValues20,
        generatedMean20,
        generatedStdDev20,
        1
        );

    checkAccuracy(
        generatedWeightedValues21,
        generatedMean21,
        generatedStdDev21
        );

    checkAccuracy(
        generatedWeightedValues22,
        generatedMean22,
        generatedStdDev22
        );

  }",./weka/src/test/java/weka/experiment/StatsTest.java,weka-master
"public AbstractClassifierTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier result;

    result = new CheckClassifier();
    result.setSilent(true);
    result.setClassifier(m_Classifier);
    result.setNumInstances(20);
    result.setDebug(DEBUG);
    result.setPostProcessor(getPostProcessor());

    return result;
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler result;

    result = new CheckOptionHandler();
    result.setOptionHandler((OptionHandler) getClassifier());
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE result;

    result = new CheckGOE();
    result.setObject(getClassifier());
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testToString() {
    boolean[] result;

    result = m_Tester.testToString();

    if (!result[0]) {
      fail(""Error in toString() method!"");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testSerialVersionUID() {
    boolean[] result;

    result = m_Tester.declaresSerialVersionUID();

    if (!result[0]) {
      fail(""Doesn't declare serialVersionUID!"");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testAttributes() {
    // nominal
    checkAttributes(true, false, false, false, false, true);
    // numeric
    checkAttributes(false, true, false, false, false, true);
    // string
    checkAttributes(false, false, true, false, false, true);
    // date
    checkAttributes(false, false, false, true, false, true);
    // relational
    if (!m_multiInstanceHandler) {
      checkAttributes(false, false, false, false, true, true);
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testInstanceWeights() {
    boolean[] result;
    int i;

    if (m_weightedInstancesHandler) {
      for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
        // does the classifier support this type of class at all?
        if (!canPredict(i)) {
          continue;
        }

        result = m_Tester.instanceWeights(m_NominalPredictors[i],
          m_NumericPredictors[i], m_StringPredictors[i], m_DatePredictors[i],
          m_RelationalPredictors[i], m_multiInstanceHandler, i);

        if (!result[0]) {
          System.err.println(""Error handling instance weights (""
            + getClassTypeString(i) + "" class)!"");
        }
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testOnlyClass() {
    boolean[] result;
    int i;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      result = m_Tester.canHandleOnlyClass(m_NominalPredictors[i],
        m_NumericPredictors[i], m_StringPredictors[i], m_DatePredictors[i],
        m_RelationalPredictors[i], i);

      if (!result[0] && !result[1]) {
        fail(""Error handling data containing only the class!"");
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testNClasses() {
    boolean[] result;

    if (!canPredict(Attribute.NOMINAL)) {
      return;
    }

    result = m_Tester.canHandleNClasses(m_NominalPredictors[Attribute.NOMINAL],
      m_NumericPredictors[Attribute.NOMINAL],
      m_StringPredictors[Attribute.NOMINAL],
      m_DatePredictors[Attribute.NOMINAL],
      m_RelationalPredictors[Attribute.NOMINAL], m_multiInstanceHandler,
      m_NClasses);

    if (!result[0] && !result[1]) {
      fail(""Error handling "" + m_NClasses + "" classes!"");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testClassAsNthAttribute() {
    int i;

    // multi-Instance data has fixed format!
    if (m_multiInstanceHandler) {
      return;
    }

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      // first attribute
      m_handleClassAsFirstAttribute[i] = checkClassAsNthAttribute(i, 0);

      // second attribute
      m_handleClassAsSecondAttribute[i] = checkClassAsNthAttribute(i, 1);
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testZeroTraining() {
    boolean[] result;
    int i;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      result = m_Tester.canHandleZeroTraining(m_NominalPredictors[i],
        m_NumericPredictors[i], m_StringPredictors[i], m_DatePredictors[i],
        m_RelationalPredictors[i], m_multiInstanceHandler, i);

      if (!result[0] && !result[1]) {
        fail(""Error handling zero training instances ("" + getClassTypeString(i)
          + "" class)!"");
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testMissingPredictors() {
    int i;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      // 20% missing
      checkMissingPredictors(i, 20, true);

      // 100% missing
      if (m_handleMissingPredictors[i]) {
        checkMissingPredictors(i, 100, true);
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testMissingClass() {
    int i;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      // 20% missing
      checkMissingClass(i, 20, true);

      // 100% missing
      if (m_handleMissingClass[i]) {
        checkMissingClass(i, 100, true);
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testBuildInitialization() {
    boolean[] result;
    int i;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      result = m_Tester.correctBuildInitialisation(m_NominalPredictors[i],
        m_NumericPredictors[i], m_StringPredictors[i], m_DatePredictors[i],
        m_RelationalPredictors[i], m_multiInstanceHandler, i);

      if (!result[0] && !result[1]) {
        fail(""Incorrect build initialization ("" + getClassTypeString(i)
          + "" class)!"");
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testDatasetIntegrity() {
    boolean[] result;
    int i;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      result = m_Tester.datasetIntegrity(m_NominalPredictors[i],
        m_NumericPredictors[i], m_StringPredictors[i], m_DatePredictors[i],
        m_RelationalPredictors[i], m_multiInstanceHandler, i,
        m_handleMissingPredictors[i], m_handleMissingClass[i]);

      if (!result[0] && !result[1]) {
        fail(""Training set is altered during training (""
          + getClassTypeString(i) + "" class)!"");
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testUseOfTestClassValue() {
    boolean[] result;
    int i;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      result = m_Tester.doesntUseTestClassVal(m_NominalPredictors[i],
        m_NumericPredictors[i], m_StringPredictors[i], m_DatePredictors[i],
        m_RelationalPredictors[i], m_multiInstanceHandler, i);

      if (!result[0]) {
        fail(""Uses test class values ("" + getClassTypeString(i) + "" class)!"");
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testUpdatingEquality() {
    boolean[] result;
    int i;

    if (m_updateableClassifier) {
      for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
        // does the classifier support this type of class at all?
        if (!canPredict(i)) {
          continue;
        }

        result = m_Tester.updatingEquality(m_NominalPredictors[i],
          m_NumericPredictors[i], m_StringPredictors[i], m_DatePredictors[i],
          m_RelationalPredictors[i], m_multiInstanceHandler, i);

        if (!result[0]) {
          System.err
            .println(""Incremental training does not produce same result as ""
              + ""batch training ("" + getClassTypeString(i) + "" class)!"");
        }
      }
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testRegression() throws Exception {
    int i;
    boolean succeeded;
    Regression reg;
    Instances train;

    // don't bother if not working correctly
    if (m_Tester.hasClasspathProblems()) {
      return;
    }

    reg = new Regression(this.getClass());
    succeeded = false;
    train = null;

    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the classifier support this type of class at all?
      if (!canPredict(i)) {
        continue;
      }

      train = m_Tester.makeTestDataset(42, m_Tester.getNumInstances(),
        m_NominalPredictors[i] ? m_Tester.getNumNominal() : 0,
        m_NumericPredictors[i] ? m_Tester.getNumNumeric() : 0,
        m_StringPredictors[i] ? m_Tester.getNumString() : 0,
        m_DatePredictors[i] ? m_Tester.getNumDate() : 0,
        m_RelationalPredictors[i] ? m_Tester.getNumRelational() : 0, 2, i,
        m_multiInstanceHandler);

      try {
        m_RegressionResults[i] = useClassifier(train);
        succeeded = true;
        reg.println(predictionsToString(m_RegressionResults[i]));
      } catch (Exception e) {
        String msg = e.getMessage().toLowerCase();
        if (msg.indexOf(""not in classpath"") > -1) {
          return;
        }

        m_RegressionResults[i] = null;
      }
    }

    if (!succeeded) {
      fail(""Problem during regression testing: no successful predictions for any class type"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testListOptions() {
    if (!m_OptionTester.checkListOptions()) {
      fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testSetOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testDefaultOptions() {
    if (!m_OptionTester.checkDefaultOptions()) {
      fail(""Default options were not processed correctly."");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testRemainingOptions() {
    if (!m_OptionTester.checkRemainingOptions()) {
      fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (!m_OptionTester.checkCanonicalUserOptions()) {
      fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testResettingOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo()) {
      fail(""No globalInfo method"");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips()) {
      fail(""Tool tips inconsistent"");
    }
  }",./weka/src/test/java/weka/classifiers/AbstractClassifierTest.java,weka-master
public JRipTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/rules/JRipTest.java,weka-master
public DecisionTableTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/rules/DecisionTableTest.java,weka-master
public M5RulesTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/rules/M5RulesTest.java,weka-master
public PARTTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/rules/PARTTest.java,weka-master
public ZeroRTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/rules/ZeroRTest.java,weka-master
public OneRTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/rules/OneRTest.java,weka-master
public InputMappedClassifierTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"protected void performTest(boolean nomClass, int numClassesTrain,
      int numTrainAtts,
      boolean reorderAtts, boolean reorderNomLabels,
      boolean reorderClassLabels) {
    Instances train = null;
    Instances test = null;
    
    try {
      train = generateData(nomClass, numClassesTrain, numTrainAtts, 3);
    } catch (Exception ex) {
      fail(""Generating training data failed: "" + ex);
    }
    
    test = new Instances(train);
    
    if (reorderNomLabels) {
      // do the first attribute
      try {
        test = swapValues(1, test);
      } catch (Exception ex) {
        fail(""Reordering nominal labels failed: "" + ex);
      }
    }
    
    if (reorderClassLabels && nomClass) {
      try {
        test = swapValues(7, test);
      } catch (Exception ex) {
        fail(""Reordering class labels failed: "" + ex);
      }
    }

    if (reorderAtts) {
      try {
        test = reorderAtts(test);
      } catch (Exception ex) {
        fail(""Reordering test data failed: "" + ex);
      }
    }
    
    InputMappedClassifier toUse = null;
    
    try {
      toUse = trainClassifier(train, nomClass);
    } catch (Exception ex) {
      fail(""Training classifier failed: "" + ex);
    }
    
    double[] resultsOnTrainingStructure = null;
    try {
      resultsOnTrainingStructure = testClassifier(train, toUse);
    } catch (Exception ex) {
      fail(""Testing classifier on training data failed: "" + ex);
    }
    
    double[] resultsOnTestStructure = null;
    try {
      resultsOnTestStructure = testClassifier(test, toUse);
    } catch (Exception ex) {
      fail(""Testing classifier on test data failed: "" + ex);
    }
    
    try {
      for (int i = 0; i < resultsOnTrainingStructure.length; i++) {
        if (resultsOnTrainingStructure[i] != resultsOnTestStructure[i]) {
          throw new Exception(""Result #"" + (i+1) + "" differs!"");
        }
      }
    } catch (Exception ex) {
      fail(""Comparing results failed "" + ex);
    }
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNominaClass() {
    performTest(true, 4, 3, false, false, false);        
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNominaClassReorderedAtts() {    
    performTest(true, 4, 3, true, false, false);        
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNominalClassSwapNominalValues() {
    performTest(true, 4, 3, false, true, false);
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNominalClassSwapNominalValuesReorderAtts() {
    performTest(true, 4, 3, true, true, false);
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNominalClassSwapClassValues() {
    performTest(true, 4, 3, false, false, true);        
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNominalClassSwapNominalValuesSwapClassValues() {
    performTest(true, 4, 3, false, true, true);        
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNominalClassSwapNominalValuesSwapClassValuesReorderAtts() {
    performTest(true, 4, 3, true, true, true);        
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNumericClass() {
    performTest(false, 4, 3, false, false, false);        
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNumericClassReorderedAtts() {    
    performTest(false, 4, 3, true, false, false);        
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNumericClassSwapNominalValues() {
    performTest(false, 4, 3, false, true, false);
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public void testNumericClassSwapNominalValuesReorderAtts() {
    performTest(false, 4, 3, true, true, false);
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"protected double[] testClassifier(Instances test, InputMappedClassifier classifier) {
    double[] result = new double[test.numInstances()];
    
    try {
    for (int i = 0; i < test.numInstances(); i++) {
      result[i] = classifier.classifyInstance(test.instance(i));
    }
    
    } catch (Exception ex) {
      fail(""Testing InputMappedClassifier failed: "" + ex);
      return null;
    }
    
    return result;
  }",./weka/src/test/java/weka/classifiers/misc/InputMappedClassifierTest.java,weka-master
"public SerializedClassifierTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"protected void performTest(boolean nomClass) {
    TestInstances test;
    Instances data;
    double[] originalResults;
    double[] testResults;
    int i;

    // generate data
    try {
      test = new TestInstances();
      if (nomClass) {
        test.setClassType(Attribute.NOMINAL);
        test.setNumNominal(5);
        test.setNumNominalValues(4);
        test.setNumNumeric(0);
      } else {
        test.setClassType(Attribute.NUMERIC);
        test.setNumNominal(0);
        test.setNumNumeric(5);
      }
      test.setNumDate(0);
      test.setNumString(0);
      test.setNumRelational(0);
      test.setNumInstances(100);
      data = test.generate();
    } catch (Exception e) {
      fail(""Generating test data failed: "" + e);
      return;
    }

    // train and save base classifier
    try {
      originalResults = trainAndSerializeClassifier(data);
    } catch (Exception e) {
      fail(""Training base classifier failed: "" + e);
      return;
    }

    // test loading
    try {
      m_Classifier = new SerializedClassifier();
      m_Classifier.setModelFile(new File(MODEL_FILENAME));
      m_Classifier.buildClassifier(data);
    } catch (Exception e) {
      fail(""Loading/testing of classifier failed: "" + e);
    }

    // compare results
    try {
      // get results from serialized model
      testResults = new double[data.numInstances()];
      for (i = 0; i < testResults.length; i++) {
        testResults[i] = m_Classifier.classifyInstance(data.instance(i));
      }

      // compare
      for (i = 0; i < originalResults.length; i++) {
        if (originalResults[i] != testResults[i]) {
          throw new Exception(""Result #"" + (i + 1) + "" differs!"");
        }
      }
    } catch (Exception e) {
      fail(""Comparing results failed: "" + e);
    }
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testNominalClass() {
    performTest(true);
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testNumericClass() {
    performTest(true);
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testRegression() {
    Regression reg;
    Instances train;
    Instances test;
    Instances data;
    TestInstances testInst;
    int tot;
    int mid;
    EvaluationUtils evaluation;
    ArrayList<Prediction> regressionResults;

    reg = new Regression(this.getClass());

    // generate test data
    try {
      testInst = new TestInstances();
      testInst.setClassType(Attribute.NOMINAL);
      testInst.setNumNominal(5);
      testInst.setNumNominalValues(4);
      testInst.setNumNumeric(0);
      testInst.setNumDate(0);
      testInst.setNumString(0);
      testInst.setNumRelational(0);
      testInst.setNumInstances(100);
      data = testInst.generate();
    } catch (Exception e) {
      fail(""Failed generating data: "" + e);
      return;
    }

    // split data into train/test
    tot = data.numInstances();
    mid = tot / 2;
    train = null;
    test = null;

    try {
      train = new Instances(data, 0, mid);
      test = new Instances(data, mid, tot - mid);
      m_Classifier = new SerializedClassifier();
      m_Classifier.setModelFile(new File(MODEL_FILENAME));
    } catch (Exception e) {
      e.printStackTrace();
      fail(""Problem setting up to use classifier: "" + e);
    }

    evaluation = new EvaluationUtils();
    try {
      trainAndSerializeClassifier(train);
      regressionResults = evaluation.getTrainTestPredictions(m_Classifier,
        train, test);
      reg.println(predictionsToString(regressionResults));
    } catch (Exception e) {
      fail(""Failed obtaining classifier predictions: "" + e);
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testListOptions() {
    if (!m_OptionTester.checkListOptions()) {
      fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testSetOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testRemainingOptions() {
    if (!m_OptionTester.checkRemainingOptions()) {
      fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (!m_OptionTester.checkCanonicalUserOptions()) {
      fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
"public void testResettingOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/classifiers/misc/SerializedClassifierTest.java,weka-master
public SGDTextTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/SGDTextTest.java,weka-master
public VotedPerceptronTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/VotedPerceptronTest.java,weka-master
"public SimpleLinearRegressionTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/SimpleLinearRegressionTest.java,weka-master
"public GaussianProcessesTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/GaussianProcessesTest.java,weka-master
public SGDTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/SGDTest.java,weka-master
public MultilayerPerceptronTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/MultilayerPerceptronTest.java,weka-master
"public StringKernelTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/StringKernelTest.java,weka-master
"public PukTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/PukTest.java,weka-master
"public NormalizedPolyKernelTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/NormalizedPolyKernelTest.java,weka-master
"public PrecomputedKernelMatrixKernelTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/PrecomputedKernelMatrixKernelTest.java,weka-master
"public PolyKernelTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/PolyKernelTest.java,weka-master
"public AbstractKernelTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"protected CheckKernel getTester() {
    CheckKernel	result;
    
    result = new CheckKernel();
    result.setSilent(true);
    result.setKernel(m_Kernel);
    result.setNumInstances(20);
    result.setDebug(DEBUG);
    result.setPostProcessor(getPostProcessor());
    
    return result;
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = new CheckOptionHandler();
    if (getKernel() instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) getKernel());
    else
      result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;
    
    result = new CheckGOE();
    result.setObject(getKernel());
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testAttributes() {
    // nominal
    checkAttributes(true,  false, false, false, false, true);
    // numeric
    checkAttributes(false, true,  false, false, false, true);
    // string
    checkAttributes(false, false, true,  false, false, true);
    // date
    checkAttributes(false, false, false, true,  false, true);
    // relational
    if (!m_multiInstanceHandler)
      checkAttributes(false, false, false, false, true,  true);
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testSerialVersionUID() {
    boolean[]     result;

    result = m_Tester.declaresSerialVersionUID();

    if (!result[0])
      fail(""Doesn't declare serialVersionUID!"");
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testInstanceWeights() {
    boolean[]     result;
    int           i;
    
    if (m_weightedInstancesHandler) {
      for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
        // does the Kernel support this type of class at all?
        if (!canPredict(i))
          continue;
        
        result = m_Tester.instanceWeights(
            m_NominalPredictors[i], 
            m_NumericPredictors[i], 
            m_StringPredictors[i], 
            m_DatePredictors[i], 
            m_RelationalPredictors[i], 
            m_multiInstanceHandler, 
            i);

        if (!result[0])
          System.err.println(""Error handling instance weights ("" + getClassTypeString(i) 
              + "" class)!"");
      }
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testNClasses() {
    boolean[]     result;

    if (!canPredict(Attribute.NOMINAL))
      return;

    result = m_Tester.canHandleNClasses(
        m_NominalPredictors[Attribute.NOMINAL],
        m_NumericPredictors[Attribute.NOMINAL],
        m_StringPredictors[Attribute.NOMINAL],
        m_DatePredictors[Attribute.NOMINAL],
        m_RelationalPredictors[Attribute.NOMINAL],
        m_multiInstanceHandler,
        m_NClasses);

    if (!result[0] && !result[1])
      fail(""Error handling "" + m_NClasses + "" classes!"");
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testClassAsNthAttribute() {
    int           i;
    
    // multi-Instance data has fixed format!
    if (m_multiInstanceHandler)
      return;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Kernel support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // first attribute
      m_handleClassAsFirstAttribute[i] = checkClassAsNthAttribute(i, 0);

      // second attribute
      m_handleClassAsSecondAttribute[i] = checkClassAsNthAttribute(i, 1);
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testZeroTraining() {
    boolean[]     result;
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Kernel support this type of class at all?
      if (!canPredict(i))
        continue;
      
      result = m_Tester.canHandleZeroTraining(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          i);

      if (!result[0] && !result[1])
        fail(""Error handling zero training instances ("" + getClassTypeString(i) 
            + "" class)!"");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testMissingPredictors() {
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Kernel support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // 20% missing
      checkMissingPredictors(i, 20, true);

      // 100% missing
      if (m_handleMissingPredictors[i])
        checkMissingPredictors(i, 100, true);
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testMissingClass() {
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Kernel support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // 20% missing
      checkMissingClass(i, 20, true);

      // 100% missing
      if (m_handleMissingClass[i])
        checkMissingClass(i, 100, true);
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testBuildInitialization() {
    boolean[]     result;
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Kernel support this type of class at all?
      if (!canPredict(i))
        continue;
      
      result = m_Tester.correctBuildInitialisation(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          i);

      if (!result[0] && !result[1])
        fail(""Incorrect build initialization ("" + getClassTypeString(i) 
            + "" class)!"");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testDatasetIntegrity() {
    boolean[]     result;
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Kernel support this type of class at all?
      if (!canPredict(i))
        continue;
      
      result = m_Tester.datasetIntegrity(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          i,
          m_handleMissingPredictors[i],
          m_handleMissingClass[i]);

      if (!result[0] && !result[1])
        fail(""Training set is altered during training ("" 
            + getClassTypeString(i) + "" class)!"");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testRegression() throws Exception {
    int		i;
    boolean	succeeded;
    Regression 	reg;
    Instances   train;
    
    // don't bother if not working correctly
    if (m_Tester.hasClasspathProblems())
      return;
    
    reg = new Regression(this.getClass());
    succeeded = false;
    train = null;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Kernel support this type of class at all?
      if (!canPredict(i))
        continue;
        
      train = m_Tester.makeTestDataset(
          42, m_Tester.getNumInstances(), 
  	  m_NominalPredictors[i] ? 2 : 0,
  	  m_NumericPredictors[i] ? 1 : 0, 
          m_StringPredictors[i] ? 1 : 0,
          m_DatePredictors[i] ? 1 : 0,
          m_RelationalPredictors[i] ? 1 : 0,
          2, 
          i,
          m_multiInstanceHandler);
  
      try {
        m_RegressionResults[i] =   CheckKernel.attributeTypeToString(i) 
        			 + "" class:\n"" 
        			 + useKernel(train);
        succeeded = true;
        reg.println(m_RegressionResults[i]);
      }
      catch (Exception e) {
	String msg = e.getMessage().toLowerCase();
	if (msg.indexOf(""not in classpath"") > -1)
	  return;

	m_RegressionResults[i] = null;
      }
    }
    
    if (!succeeded) {
      fail(""Problem during regression testing: no successful predictions for any class type"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating.""); 
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } 
    catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions())
	fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions())
	fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions())
	fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo())
      fail(""No globalInfo method"");
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips())
      fail(""Tool tips inconsistent"");
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/AbstractKernelTest.java,weka-master
"public RBFKernelTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/supportVector/RBFKernelTest.java,weka-master
public SMOTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/SMOTest.java,weka-master
public LinearRegressionTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/LinearRegressionTest.java,weka-master
"public SimpleLogisticTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/functions/SimpleLogisticTest.java,weka-master
public LogisticTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/LogisticTest.java,weka-master
public SMOregTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/functions/SMOregTest.java,weka-master
public KStarTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/lazy/KStarTest.java,weka-master
public LWLTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/lazy/LWLTest.java,weka-master
public IBkTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/lazy/IBkTest.java,weka-master
"public TreeModelTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/TreeModelTest.java,weka-master
"public NeuralNetworkTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/NeuralNetworkTest.java,weka-master
"public RuleSetModelTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/RuleSetModelTest.java,weka-master
"public AbstractPMMLClassifierTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/AbstractPMMLClassifierTest.java,weka-master
"public void testRegression() throws Exception {

    PMMLClassifier classifier = null;
    Instances testData = null;
    EvaluationUtils evalUtils = null;
    weka.test.Regression reg = new weka.test.Regression(this.getClass());

    ArrayList<Prediction> predictions = null;
    boolean success = false;
    for (int i = 0; i < m_modelNames.size(); i++) {
      classifier = getClassifier(m_modelNames.get(i));
      testData = getData(m_dataSetNames.get(i));
      evalUtils = new EvaluationUtils();

      try {
        String className = classifier.getMiningSchema().getFieldsAsInstances()
          .classAttribute().name();
        Attribute classAtt = testData.attribute(className);
        testData.setClass(classAtt);
        predictions = evalUtils.getTestPredictions(classifier, testData);
        success = true;
        String predsString = weka.classifiers.AbstractClassifierTest
          .predictionsToString(predictions);
        reg.println(predsString);
      } catch (Exception ex) {
        ex.printStackTrace();
        String msg = ex.getMessage().toLowerCase();
        if (msg.indexOf(""not in classpath"") > -1) {
          return;
        }
      }
    }

    if (!success) {
      fail(""Problem during regression testing: no successful predictions generated"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/AbstractPMMLClassifierTest.java,weka-master
"public RegressionTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/RegressionTest.java,weka-master
"public GeneralRegressionTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/GeneralRegressionTest.java,weka-master
"public SupportVectorMachineModelTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/pmml/consumer/SupportVectorMachineModelTest.java,weka-master
"public EvaluationTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/classifiers/evaluation/EvaluationTest.java,weka-master
"public void testRegression() throws Exception {
    Instances inst = new Instances(new StringReader(DATA));
    inst.setClassIndex(inst.numAttributes() - 1);
    Evaluation eval = new Evaluation(inst);

    for (int i = 0; i < inst.numInstances(); i++) {
      eval.evaluateModelOnceAndRecordPrediction(PREDS[i], inst.instance(i));
    }

    String standard = eval.toSummaryString();
    String info = eval.toClassDetailsString();

    weka.test.Regression reg = new weka.test.Regression(getClass());

    reg.println(standard);
    reg.println(info);

    try {
      String diff = reg.diff();

      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression tst failed. Difference:\n"" + diff);
      }
    } catch (IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/classifiers/evaluation/EvaluationTest.java,weka-master
"public void testIncorrectSize() throws Exception {
    CostMatrix matrix = new CostMatrix(3);
    Instances data = getData();

    try {
      matrix.applyCostMatrix(data, null);
      fail(""Was expecting an exception as the cost matrix represents more classes than ""
        + ""are present in the data"");
    } catch (Exception ex) {
      // expected
    }
  }",./weka/src/test/java/weka/classifiers/CostMatrixTest.java,weka-master
"public void test2ClassCostMatrixNoExpressions() throws Exception {
    CostMatrix matrix = get2ClassCostMatrixNoExpressions(2, 6);
    Instances data = getData();

    Instances weighted = matrix.applyCostMatrix(data, null);

    assertEquals(0.5, weighted.instance(0).weight());
    assertEquals(1.5, weighted.instance(1).weight());
  }",./weka/src/test/java/weka/classifiers/CostMatrixTest.java,weka-master
"public void test2ClassCostMatrixOneSimpleExpression() throws Exception {
    CostMatrix matrix = get2ClassCostMatrixNoExpressions(2, 6);
    matrix.setCell(0, 1, ""a2"");

    Instances data = getData();
    Instances weighted = matrix.applyCostMatrix(data, null);

    assertEquals(5.0, weighted.instance(0).weight());
    assertEquals(6.0, weighted.instance(1).weight());
  }",./weka/src/test/java/weka/classifiers/CostMatrixTest.java,weka-master
"public void test2ClassCostMatrixOneExpression() throws Exception {
    CostMatrix matrix = get2ClassCostMatrixNoExpressions(2, 6);
    matrix.setCell(0, 1, ""log(a2^2)*a1-1"");

    Instances data = getData();
    Instances weighted = matrix.applyCostMatrix(data, null);
    assertEquals(-4.218876, weighted.instance(0).weight(), 1e-6);
    assertEquals(6.0, weighted.instance(1).weight());
  }",./weka/src/test/java/weka/classifiers/CostMatrixTest.java,weka-master
"public void test2ClassCostMatrixTwoExpressions() throws Exception {
    CostMatrix matrix = get2ClassCostMatrixNoExpressions(2, 6);
    matrix.setCell(0, 1, ""log(a2^2)*a1-1"");
    matrix.setCell(1, 0, ""exp(a1*cos(a2))/sqrt(a1/2)"");

    Instances data = getData();
    Instances weighted = matrix.applyCostMatrix(data, null);
    assertEquals(-4.218876, weighted.instance(0).weight(), 1e-6);
    assertEquals(0.241157, weighted.instance(1).weight(), 1e-6);
  }",./weka/src/test/java/weka/classifiers/CostMatrixTest.java,weka-master
public StackingTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/StackingTest.java,weka-master
public RegressionByDiscretizationTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/RegressionByDiscretizationTest.java,weka-master
public AdaBoostM1Test(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/AdaBoostM1Test.java,weka-master
public BaggingTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/BaggingTest.java,weka-master
public IterativeClassifierOptimizerTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/IterativeClassifierOptimizerTest.java,weka-master
"public WeightedInstancesHandlerWrapperTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/meta/WeightedInstancesHandlerWrapperTest.java,weka-master
public MultiClassClassifierTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/MultiClassClassifierTest.java,weka-master
public LogitBoostTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/LogitBoostTest.java,weka-master
"public VoteTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/meta/VoteTest.java,weka-master
public FilteredClassifierTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/FilteredClassifierTest.java,weka-master
"public RandomCommitteeTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/meta/RandomCommitteeTest.java,weka-master
public AdditiveRegressionTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/AdditiveRegressionTest.java,weka-master
"public CostSensitiveClassifierTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/meta/CostSensitiveClassifierTest.java,weka-master
public MultiClassClassifierUpdateableTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/MultiClassClassifierUpdateableTest.java,weka-master
public ClassificationViaRegressionTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/ClassificationViaRegressionTest.java,weka-master
public RandomizableFilteredClassifierTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/RandomizableFilteredClassifierTest.java,weka-master
public CVParameterSelectionTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/CVParameterSelectionTest.java,weka-master
"public AttributeSelectedClassifierTest(String name) { 
    super(name);
  }",./weka/src/test/java/weka/classifiers/meta/AttributeSelectedClassifierTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = super.getOptionTester();
    result.setUserOptions(new String[]{
	""-E"",
	""weka.attributeSelection.CfsSubsetEval"",
	""-S"",
	""weka.attributeSelection.BestFirst""});
    
    return result;
  }",./weka/src/test/java/weka/classifiers/meta/AttributeSelectedClassifierTest.java,weka-master
public MultiSchemeTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/meta/MultiSchemeTest.java,weka-master
"public RandomSubSpaceTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/meta/RandomSubSpaceTest.java,weka-master
public J48Test(String name) { super(name);  },./weka/src/test/java/weka/classifiers/trees/J48Test.java,weka-master
public HoeffdingTreeTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/trees/HoeffdingTreeTest.java,weka-master
"public RandomForestTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/trees/RandomForestTest.java,weka-master
"public LMTTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/trees/LMTTest.java,weka-master
public M5PTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/trees/M5PTest.java,weka-master
public DecisionStumpTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/trees/DecisionStumpTest.java,weka-master
public REPTreeTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/trees/REPTreeTest.java,weka-master
"public RandomTreeTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/trees/RandomTreeTest.java,weka-master
public NaiveBayesTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/bayes/NaiveBayesTest.java,weka-master
public BayesNetTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/bayes/BayesNetTest.java,weka-master
public NaiveBayesUpdateableTest(String name) { super(name);  },./weka/src/test/java/weka/classifiers/bayes/NaiveBayesUpdateableTest.java,weka-master
"public NaiveBayesMultinomialTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/bayes/NaiveBayesMultinomialTest.java,weka-master
"public NaiveBayesMultinomialUpdateableTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/bayes/NaiveBayesMultinomialUpdateableTest.java,weka-master
"public NaiveBayesMultinomialTextTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/classifiers/bayes/NaiveBayesMultinomialTextTest.java,weka-master
"public UtilsTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/core/UtilsTest.java,weka-master
"public void testVariance() {
    
    assertTrue(""Incorrect behaviour when count <= 1!"",
        Double.isNaN(Utils.variance(new double[]{})));
    assertTrue(""Incorrect behaviour when count <= 1!"",
        Double.isNaN(Utils.variance(new double[]{3})));
    
    checkAccuracy(generatedVar1, generatedValues1);
    checkAccuracy(generatedVar2, generatedValues2, 1e-2);
    checkAccuracy(generatedVar3, generatedValues3);
    checkAccuracy(generatedVar4, generatedValues4);
    checkAccuracy(generatedVar5, generatedValues5);
    checkAccuracy(generatedVar6, generatedValues6, 2);
    checkAccuracy(generatedVar7, generatedValues7);
    checkAccuracy(generatedVar8, generatedValues8, 2);
    checkAccuracy(generatedVar9, generatedValues9);
    checkAccuracy(generatedVar10, generatedValues10);
  }",./weka/src/test/java/weka/core/UtilsTest.java,weka-master
"public void testSplittingAndJoining() {
    String[] 	options;
    String[] 	newOptions;
    String 	joined;
    int		i;
    
    try {
      options    = new StringToWordVector().getOptions();
      joined     = Utils.joinOptions(options);
      newOptions = Utils.splitOptions(joined);
      assertEquals(""Same number of options"", options.length, newOptions.length);
      for (i = 0; i < options.length; i++) {
	if (!options[i].equals(newOptions[i]))
	  fail(""Option "" + (i+1) + "" differs"");
      }
    }
    catch (Exception e) {
      fail(""Exception: "" + e);
    }
  }",./weka/src/test/java/weka/core/UtilsTest.java,weka-master
"public void testQuoting() {
    String 	input;
    String 	output;
    
    input  = ""blahblah"";
    output = Utils.quote(input);
    assertTrue(""No quoting necessary"", !output.startsWith(""'"") && !output.endsWith(""'""));
    
    input  = """";
    output = Utils.quote(input);
    assertTrue(""Empty string quoted"", output.startsWith(""'"") && output.endsWith(""'""));
    assertTrue(""Empty string restored"", input.equals(Utils.unquote(output)));
    
    input  = "" "";
    output = Utils.quote(input);
    assertTrue(""Blank quoted"", output.startsWith(""'"") && output.endsWith(""'""));
    assertTrue(""Blank restored"", input.equals(Utils.unquote(output)));
    
    input  = ""{"";
    output = Utils.quote(input);
    assertTrue("">"" + input + ""< quoted"", output.startsWith(""'"") && output.endsWith(""'""));
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unquote(output)));
    
    input  = ""}"";
    output = Utils.quote(input);
    assertTrue("">"" + input + ""< quoted"", output.startsWith(""'"") && output.endsWith(""'""));
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unquote(output)));
    
    input  = "","";
    output = Utils.quote(input);
    assertTrue("">"" + input + ""< quoted"", output.startsWith(""'"") && output.endsWith(""'""));
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unquote(output)));
    
    input  = ""?"";
    output = Utils.quote(input);
    assertTrue("">"" + input + ""< quoted"", output.startsWith(""'"") && output.endsWith(""'""));
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unquote(output)));
    
    input  = ""\r\n\t'\""%"";
    output = Utils.quote(input);
    assertTrue("">"" + input + ""< quoted"", output.startsWith(""'"") && output.endsWith(""'""));
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unquote(output)));
  }",./weka/src/test/java/weka/core/UtilsTest.java,weka-master
"public void testBackQuoting() {
    String 	input;
    String 	output;
    
    input  = ""blahblah"";
    output = Utils.backQuoteChars(input);
    assertTrue(""No backquoting necessary"", input.equals(output));
    
    input  = ""\r\n\t'\""%"";
    output = Utils.backQuoteChars(input);
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unbackQuoteChars(output)));
    
    input  = ""\\r\\n\\t\\'\\\""\\%"";
    output = Utils.backQuoteChars(input);
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unbackQuoteChars(output)));
    
    input  = Utils.joinOptions(new StringToWordVector().getOptions());
    output = Utils.backQuoteChars(input);
    assertTrue("">"" + input + ""< restored"", input.equals(Utils.unbackQuoteChars(output)));
  }",./weka/src/test/java/weka/core/UtilsTest.java,weka-master
"public SingleIndexTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/core/SingleIndexTest.java,weka-master
"public void testDefaultConstructor() throws Exception {
    int upper = 10;
    int indexInt = 0;
    String indexStr = """" + (indexInt + 1);
    SingleIndex index = new SingleIndex();
    index.setSingleIndex(indexStr);
    index.setUpper(upper);

    assertEquals(indexStr, index.getSingleIndex());
    assertEquals(indexInt, index.getIndex());
  }",./weka/src/test/java/weka/core/SingleIndexTest.java,weka-master
"public void testInitialValueConstructor() throws Exception {
    int upper = 10;
    int indexInt = 0;
    String indexStr = """" + (indexInt + 1);
    SingleIndex index = getIndex(""1"", upper);

    assertEquals(indexStr, index.getSingleIndex());
    assertEquals(indexInt, index.getIndex());
  }",./weka/src/test/java/weka/core/SingleIndexTest.java,weka-master
"public void testFirst() throws Exception {
    int upper = 10;
    SingleIndex index = getIndex(""first"", upper);

    assertEquals(0, index.getIndex());
    assertEquals(""first"", index.getSingleIndex());
  }",./weka/src/test/java/weka/core/SingleIndexTest.java,weka-master
"public void testLast() throws Exception {
    int upper = 10;
    SingleIndex index = getIndex(""last"", upper);

    assertEquals(upper, index.getIndex());
    assertEquals(""last"", index.getSingleIndex());
  }",./weka/src/test/java/weka/core/SingleIndexTest.java,weka-master
"public RegExpFromFileTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/stopwords/RegExpFromFileTest.java,weka-master
"public AbstractStopwordsTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler result;

    result = new CheckOptionHandler();
    if (getStopwords() instanceof OptionHandler) {
      result.setOptionHandler((OptionHandler) getStopwords());
    } else {
      result.setOptionHandler(null);
    }
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE result;

    result = new CheckGOE();
    result.setObject(getStopwords());
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testSerialVersionUID() {
    boolean result;

    result = !SerializationHelper.needsUID(m_Stopwords.getClass());

    if (!result) {
      fail(""Doesn't declare serialVersionUID!"");
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testBuildInitialization() {
    boolean result;
    int i;
    int n;
    int m;
    boolean[][][] processed;
    String[] data;
    String msg;

    // process data twice
    processed = new boolean[2][m_Data.length][];
    for (n = 0; n < 2; n++) {
      for (i = 0; i < m_Data.length; i++) {
        try {
          data = tokenize(m_Data[i]);
          processed[n][i] = new boolean[data.length];
          for (m = 0; m < data.length; m++)
            processed[n][i][m] = m_Stopwords.isStopword(data[m]);
        } catch (Exception e) {
          processed[n][i] = new boolean[]{false};
        }
      }
    }

    // was the same data produced?
    result = true;
    msg = """";
    for (i = 0; i < m_Data.length; i++) {
      if (processed[0].length == processed[1].length) {
        for (n = 0; n < processed[0][i].length; n++) {
          if (processed[0][i][n] != processed[1][i][n]) {
            result = false;
            msg = ""different stopwords results"";
            break;
          }
        }
      } else {
        result = false;
        msg = ""different number of stopwords"";
        break;
      }
    }

    if (!result) {
      fail(""Incorrect build initialization ("" + msg + "")!"");
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testRegression() {
    int i;
    boolean succeeded;
    Regression reg;
    String[] tokens;
    Boolean[] results;

    reg = new Regression(this.getClass());
    succeeded = false;

    for (i = 0; i < m_Data.length; i++) {
      try {
	tokens = tokenize(m_Data[i]);
	results = useStopwords(tokens);
        succeeded = true;
        reg.println(predictionsToString(tokens, results));
      } catch (Exception e) {
	results = new Boolean[0];
      }
    }

    if (!succeeded) {
      fail(""Problem during regression testing: no successful results generated for any string"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions()) {
        fail(""Options cannot be listed via listOptions."");
      }
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions()) {
        fail(""setOptions method failed."");
      }
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testDefaultOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkDefaultOptions()) {
        fail(""Default options were not processed correctly."");
      }
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions()) {
        fail(""There were 'left-over' options."");
      }
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions()) {
        fail(""setOptions method failed"");
      }
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions()) {
        fail(""Resetting of options failed"");
      }
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo()) {
      fail(""No globalInfo method"");
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips()) {
      fail(""Tool tips inconsistent"");
    }
  }",./weka/src/test/java/weka/core/stopwords/AbstractStopwordsTest.java,weka-master
"public RainbowTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/stopwords/RainbowTest.java,weka-master
"public MultiStopwordsTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/stopwords/MultiStopwordsTest.java,weka-master
"public NullTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/stopwords/NullTest.java,weka-master
"public WordsFromFileTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/stopwords/WordsFromFileTest.java,weka-master
"public RangeTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testDefaultConstructor() throws Exception {
    int upper = 10;
    int indexInt = 0;
    String indexStr = """" + (indexInt + 1);
    Range index = new Range();
    index.setRanges(indexStr);
    index.setUpper(upper);

    assertEquals(indexStr, index.getRanges());
    assertEquals(1, index.getSelection().length);
    assertEquals(indexInt, index.getSelection()[0]);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testInitialValueConstructor() throws Exception {
    int upper = 10;
    int indexInt = 0;
    String indexStr = """" + (indexInt + 1);
    Range index = getRange(""1"", upper);

    assertEquals(indexStr, index.getRanges());
    assertEquals(1, index.getSelection().length);
    assertEquals(indexInt, index.getSelection()[0]);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testFirst() throws Exception {
    int upper = 10;
    Range index = getRange(""first"", upper);

    assertEquals(""first"", index.getRanges());
    assertEquals(1, index.getSelection().length);
    assertEquals(0, index.getSelection()[0]);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testLast() throws Exception {
    int upper = 10;
    Range index = getRange(""last"", upper);

    assertEquals(""last"", index.getRanges());
    assertEquals(1, index.getSelection().length);
    assertEquals(upper, index.getSelection()[0]);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testFirstLast() throws Exception {
    int upper = 10;
    Range index = getRange(""first-last"", upper);

    assertEquals(""first-last"", index.getRanges());
    assertEquals(upper + 1, index.getSelection().length);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testSimpleRange() throws Exception {
    int upper = 10;
    String range = ""1-3"";
    Range index = getRange(range, upper);
    int[] expected = new int[]{0,1,2};

    assertEquals(range, index.getRanges());
    assertEquals(expected.length, index.getSelection().length);
    for (int i = 0; i < expected.length; i++)
      assertEquals(expected[i], index.getSelection()[i]);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testMixedRange() throws Exception {
    int upper = 10;
    String range = ""1-3,6,8-last"";
    Range index = getRange(range, upper);
    int[] expected = new int[]{0,1,2,5,7,8,9,10};

    assertEquals(range, index.getRanges());
    assertEquals(expected.length, index.getSelection().length);
    for (int i = 0; i < expected.length; i++)
      assertEquals(expected[i], index.getSelection()[i]);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public void testUnorderedRange() throws Exception {
    int upper = 10;
    String range = ""8-last,1-3,6"";
    Range index = getRange(range, upper);
    int[] expected = new int[]{7,8,9,10,0,1,2,5};

    assertEquals(range, index.getRanges());
    assertEquals(expected.length, index.getSelection().length);
    for (int i = 0; i < expected.length; i++)
      assertEquals(expected[i], index.getSelection()[i]);
  }",./weka/src/test/java/weka/core/RangeTest.java,weka-master
"public OptionHandlersTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/OptionHandlersTest.java,weka-master
"public void testDummy() throws Exception {
    // does nothing, only to prevent JUnit from complaining about ""no tests""
  }",./weka/src/test/java/weka/core/OptionHandlersTest.java,weka-master
"public DictionaryBuilderTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testInit() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    // should be just one dictionary (i.e. no class attribute, so no per-class
    // dictionaries)
    assertEquals(1, builder.getDictionaries(false).length);
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testTypicalNoClass() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    assertEquals(15, builder.getDictionaries(false)[0].size());

    // check a couple of words
    assertTrue(builder.getDictionaries(false)[0].get(""the"") != null);

    // word count (index 0) should be 4
    assertEquals(4, builder.getDictionaries(false)[0].get(""the"")[0]);

    // doc count (index 1) should be 2
    assertEquals(2, builder.getDictionaries(false)[0].get(""the"")[1]);
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testFinalizeDictionaryNoClass() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    assertEquals(15, builder.getDictionaries(false)[0].size());

    Map<String, int[]> consolidated = builder.finalizeDictionary();

    // all but ""the"" and ""over"" should have been pruned from the dictionary
    // according to the default min freq of 2
    assertEquals(2, consolidated.size());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testPruneMinFreq() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(1);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    assertEquals(15, builder.getDictionaries(false)[0].size());

    Map<String, int[]> consolidated = builder.finalizeDictionary();

    // min freq of 1 should keep all terms
    assertEquals(15, consolidated.size());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testGetVectorizedStructureNoClass() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    builder.finalizeDictionary();

    Instances format = builder.getVectorizedFormat();
    assertTrue(format != null);
    assertEquals(2, format.numAttributes());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testVectorizeInstanceWordPresenceNoClass() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    builder.finalizeDictionary();

    Instance vectorized = builder.vectorizeInstance(data1.instance(0));
    assertEquals(2, vectorized.numAttributes());

    // values of the two attributes should be 1 (presence indicators)
    assertEquals(1, (int) vectorized.value(0));
    assertEquals(1, (int) vectorized.value(1));
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testVectorizeInstanceWordCountsNoClass() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setOutputWordCounts(true);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    builder.finalizeDictionary();

    Instance vectorized = builder.vectorizeInstance(data1.instance(0));
    assertEquals(2, vectorized.numAttributes());

    // ""the"" occurs twice in the first index and ""over"" once
    assertEquals(2, (int) vectorized.value(0));
    assertEquals(1, (int) vectorized.value(1));
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testTypicalNoClassExtraAtts() throws Exception {
    Instances data1 = getData3();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    assertEquals(15, builder.getDictionaries(false)[0].size());

    // check a couple of words
    assertTrue(builder.getDictionaries(false)[0].get(""the"") != null);

    // word count (index 0) should be 4
    assertEquals(4, builder.getDictionaries(false)[0].get(""the"")[0]);

    // doc count (index 1) should be 2
    assertEquals(2, builder.getDictionaries(false)[0].get(""the"")[1]);
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testFinalizeDictionaryNoClassExtraAtts() throws Exception {
    Instances data1 = getData3();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    assertEquals(15, builder.getDictionaries(false)[0].size());

    Map<String, int[]> consolidated = builder.finalizeDictionary();

    // all but ""the"" and ""over"" should have been pruned from the dictionary
    assertEquals(2, consolidated.size());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testGetVectorizedStructureNoClassExtraAtts() throws Exception {
    Instances data1 = getData3();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    builder.finalizeDictionary();

    Instances format = builder.getVectorizedFormat();
    assertTrue(format != null);
    assertEquals(4, format.numAttributes());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testTypicalClassAttPresent() throws Exception {
    Instances data2 = getData2();
    Instances structure = new Instances(data2, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data2.numInstances(); i++) {
      builder.processInstance(data2.instance(i));
    }

    // should be two dictionaries (one for each class)
    assertEquals(2, builder.getDictionaries(false).length);

    assertEquals(8, builder.getDictionaries(false)[0].size());
    assertEquals(9, builder.getDictionaries(false)[1].size());

    // check a couple of words
    assertTrue(builder.getDictionaries(false)[0].get(""the"") != null);

    // first dictionary: word count (index 0) should be 2
    assertEquals(2, builder.getDictionaries(false)[0].get(""the"")[0]);

    // first dictionary: doc count (index 1) should be 1
    assertEquals(1, builder.getDictionaries(false)[0].get(""the"")[1]);
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testAggregateDictionaries() throws Exception {
    Instances data1 = getData1();
    Instances data4 = getData4();

    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(1);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }

    Instances structure2 = new Instances(data4, 0);

    DictionaryBuilder builder2 = new DictionaryBuilder();
    builder2.setMinTermFreq(1);
    builder2.setup(structure2);

    for (int i = 0; i < data4.numInstances(); i++) {
      builder2.processInstance(data4.instance(i));
    }

    builder = builder.aggregate(builder2);

    builder.finalizeAggregation();
    Map<String, int[]> consolidated = builder.finalizeDictionary();
    assertEquals(17, consolidated.size());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testSaveLoadDictionaryPlainTextNoNormalize() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }
    builder.finalizeDictionary();

    StringWriter sw = new StringWriter();
    builder.saveDictionary(sw);

    StringReader sr = new StringReader(sw.toString());
    DictionaryBuilder builder2 = new DictionaryBuilder();
    builder2.setup(structure);
    builder2.loadDictionary(sr);

    // just returns the loaded dictionary
    Map<String, int[]> consolidated = builder2.finalizeDictionary();

    assertEquals(2, consolidated.size());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testSaveLoadDictionaryPlainTextNormalize() throws Exception {
    Instances data1 = getData1();
    Instances structure = new Instances(data1, 0);

    DictionaryBuilder builder = new DictionaryBuilder();
    builder.setMinTermFreq(2);
    builder.setNormalize(true);
    builder.setup(structure);

    for (int i = 0; i < data1.numInstances(); i++) {
      builder.processInstance(data1.instance(i));
    }
    builder.finalizeDictionary();

    StringWriter sw = new StringWriter();
    builder.saveDictionary(sw);
    String dictText = sw.toString();
    assertTrue(dictText.startsWith(""@@@3.39036""));

    StringReader sr = new StringReader(dictText);
    DictionaryBuilder builder2 = new DictionaryBuilder();
    builder2.setup(structure);
    builder2.loadDictionary(sr);

    // just returns the loaded dictionary
    Map<String, int[]> consolidated = builder2.finalizeDictionary();

    assertEquals(2, consolidated.size());
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testListOptions() {
    CheckOptionHandler optionHandler = new CheckOptionHandler();
    DictionaryBuilder builder = new DictionaryBuilder();
    optionHandler.setOptionHandler(builder);

    if (!optionHandler.checkListOptions()) {
      fail(""Options cannot be listed via listOptions"");
    }
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testSetOptions() {
    CheckOptionHandler optionHandler = new CheckOptionHandler();
    DictionaryBuilder builder = new DictionaryBuilder();
    optionHandler.setOptionHandler(builder);

    if (!optionHandler.checkSetOptions()) {
      fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testCanonicalUserOptions() {
    CheckOptionHandler optionHandler = new CheckOptionHandler();
    DictionaryBuilder builder = new DictionaryBuilder();
    optionHandler.setOptionHandler(builder);

    if (!optionHandler.checkCanonicalUserOptions()) {
      fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testResettingOptions() {
    CheckOptionHandler optionHandler = new CheckOptionHandler();
    DictionaryBuilder builder = new DictionaryBuilder();
    optionHandler.setOptionHandler(builder);

    if (!optionHandler.checkResettingOptions()) {
      fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public void testRemainingOptions() {
    CheckOptionHandler optionHandler = new CheckOptionHandler();
    DictionaryBuilder builder = new DictionaryBuilder();
    optionHandler.setOptionHandler(builder);

    if (!optionHandler.checkRemainingOptions()) {
      fail(""There were leftover options"");
    }
  }",./weka/src/test/java/weka/core/DictionaryBuilderTest.java,weka-master
"public KDTreeTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/neighboursearch/KDTreeTest.java,weka-master
"public LinearNNSearchTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/neighboursearch/LinearNNSearchTest.java,weka-master
"public AbstractNearestNeighbourSearchTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler result;

    result = new CheckOptionHandler();
    result.setOptionHandler(getNearestNeighbourSearch());
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE result;

    result = new CheckGOE();
    result.setObject(getNearestNeighbourSearch());
    result.setIgnoredProperties(result.getIgnoredProperties() + "",instances"");
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testSerialVersionUID() {
    boolean result;

    result = !SerializationHelper.needsUID(m_NearestNeighbourSearch.getClass());

    if (!result) {
      fail(""Doesn't declare serialVersionUID!"");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testListOptions() {
    if (!m_OptionTester.checkListOptions()) {
      fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testSetOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testDefaultOptions() {
    if (!m_OptionTester.checkDefaultOptions()) {
      fail(""Default options were not processed correctly."");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testRemainingOptions() {
    if (!m_OptionTester.checkRemainingOptions()) {
      fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (!m_OptionTester.checkCanonicalUserOptions()) {
      fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testResettingOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo()) {
      fail(""No globalInfo method"");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips()) {
      fail(""Tool tips inconsistent"");
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testNumberOfNeighbors() {
    int i;
    int instIndex;
    Instances neighbors;

    try {
      m_NearestNeighbourSearch.setInstances(m_Instances);
    } catch (Exception e) {
      fail(""Failed setting the instances: "" + e);
    }

    for (i = 1; i <= m_NumNeighbors; i++) {
      instIndex = m_Random.nextInt(m_Instances.numInstances());
      try {
        neighbors = m_NearestNeighbourSearch.kNearestNeighbours(
          m_Instances.instance(instIndex), i);
        assertEquals(""Returned different number of neighbors than requested"",
          i, neighbors.numInstances());
      } catch (Exception e) {
        fail(""Failed for "" + i + "" neighbors on instance "" + (instIndex + 1)
          + "": "" + e);
      }
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testBuildInitialization() {
    String[][][] results;
    Instances inst;
    int i;
    int n;
    int m;

    results = new String[2][m_Instances.numInstances()][m_NumNeighbors];

    // two runs of determining neighbors
    for (i = 0; i < 2; i++) {
      try {
        m_NearestNeighbourSearch.setInstances(m_Instances);

        for (n = 0; n < m_Instances.numInstances(); n++) {
          for (m = 1; m <= m_NumNeighbors; m++) {
            inst = m_NearestNeighbourSearch.kNearestNeighbours(
              m_Instances.instance(n), m);
            results[i][n][m - 1] = inst.toString();
          }
        }
      } catch (Exception e) {
        fail(""Build "" + (i + 1) + "" failed: "" + e);
      }
    }

    // compare the results
    for (n = 0; n < m_Instances.numInstances(); n++) {
      for (m = 1; m <= m_NumNeighbors; m++) {
        if (!results[0][n][m - 1].equals(results[1][n][m - 1])) {
          fail(""Results differ: instance #"" + (n + 1) + "" with "" + m
            + "" neighbors"");
        }
      }
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public void testRegression() {
    Regression reg;
    ArrayList<String> regressionResult;

    reg = new Regression(this.getClass());

    try {
      regressionResult = useNearestNeighbourSearch(m_Instances);
      reg.println(resultsToString(regressionResult));
    } catch (Exception e) {
      fail(""Regression test failed: "" + e);
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/core/neighboursearch/AbstractNearestNeighbourSearchTest.java,weka-master
"public BallTreeTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/neighboursearch/BallTreeTest.java,weka-master
"public CoverTreeTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/neighboursearch/CoverTreeTest.java,weka-master
"public AlgVectorTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/core/AlgVectorTest.java,weka-master
"public void testArrayConstructor() {
    double[] data = {2.3, 1.2, 5.0};
    AlgVector v = new AlgVector(data);
    assertEquals(""Length differs"", data.length, v.numElements());
    for (int i = 0; i < data.length; i++)
      assertEquals((i+1) + "". value differs"", data[i], v.getElement(i));
  }",./weka/src/test/java/weka/core/AlgVectorTest.java,weka-master
"protected void runTestOnData(Instances data) {
    // count numeric atts
    int numeric = 0;
    for (int n = 0; n < data.numAttributes(); n++) {
      if (data.attribute(n).isNumeric())
	numeric++;
    }
    
    // perform tests
    for (int n = 0; n < data.numInstances(); n++) {
      try {
	AlgVector v = new AlgVector(data.instance(n));
	
	// 1. is length correct?
	assertEquals((n+1) + "": length differs"", numeric, v.numElements());
	
	// 2. are values correct?
	int index = 0;
	for (int i = 0; i < data.numAttributes(); i++) {
	  if (!data.attribute(i).isNumeric())
	    continue;
	  assertEquals((n+1) + ""/"" + (i+1) + "": value differs"", data.instance(n).value(i), v.getElement(index));
	  index++;
	}
	
	// 3. is instance returned correct?
	Instance inst = v.getAsInstance(data, new Random(1));
	for (int i = 0; i < data.numAttributes(); i++) {
	  if (!data.attribute(i).isNumeric())
	    continue;
	  assertEquals((n+1) + ""/"" + (i+1) + "": returned value differs"", data.instance(n).value(i), inst.value(i));
	}
      }
      catch (Exception e) {
	if (!(e instanceof IllegalArgumentException))
	  fail(e.toString());
      }
    }
  }",./weka/src/test/java/weka/core/AlgVectorTest.java,weka-master
"public void testNumericInstances() {
    runTestOnData(generateData(0, 5, 5));
  }",./weka/src/test/java/weka/core/AlgVectorTest.java,weka-master
"public void testNominalInstances() {
    runTestOnData(generateData(5, 0, 5));
  }",./weka/src/test/java/weka/core/AlgVectorTest.java,weka-master
"public void testMixedInstances() {
    runTestOnData(generateData(5, 5, 5));
  }",./weka/src/test/java/weka/core/AlgVectorTest.java,weka-master
"public MatlabTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/MatlabTest.java,weka-master
"protected TestInstances getTestInstances() {
    return TestInstances.forCapabilities(new MatlabSaver().getCapabilities());
  }",./weka/src/test/java/weka/core/converters/MatlabTest.java,weka-master
"public SerializedInstancesTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/SerializedInstancesTest.java,weka-master
"public ArffTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/ArffTest.java,weka-master
"public CSVTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/CSVTest.java,weka-master
"public LibSVMTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/LibSVMTest.java,weka-master
"public AbstractConverterTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"protected CheckOptionHandler getOptionTester(Object o) {
    CheckOptionHandler		result;
    
    result = new CheckOptionHandler();
    if (o instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) o);
    else
      result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"protected CheckGOE getGOETester(Object o) {
    CheckGOE		result;
    
    result = new CheckGOE();
    result.setObject(o);
    result.setIgnoredProperties(result.getIgnoredProperties() + "",instances"");
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"protected CheckOptionHandler getOptionTesterLoader() {
    return getOptionTester(getLoader());
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"protected CheckOptionHandler getOptionTesterSaver() {
    return getOptionTester(getSaver());
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"protected CheckGOE getGOETesterLoader() {
    return getGOETester(getLoader());
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"protected CheckGOE getGOETesterSaver() {
    return getGOETester(getSaver());
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"protected TestInstances getTestInstances() {
    return new TestInstances();
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkListOptions())
	fail(""Loader: Options cannot be listed via listOptions."");
    }

    if (m_OptionTesterSaver.getOptionHandler() != null) {
      if (!m_OptionTesterSaver.checkListOptions())
	fail(""Saver: Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public void testSetOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;
    
    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkSetOptions())
	fail(""Loader: setOptions method failed."");
    }

    if (m_OptionTesterSaver.getOptionHandler() != null) {
      if (!m_OptionTesterSaver.checkSetOptions())
	fail(""Saver: setOptions method failed."");
    }
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public void testRemainingOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;
    
    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkRemainingOptions())
	fail(""Loader: There were 'left-over' options."");
    }

    if (m_OptionTesterSaver.getOptionHandler() != null) {
      if (!m_OptionTesterSaver.checkRemainingOptions())
	fail(""Saver: There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public void testCanonicalUserOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;
    
    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkCanonicalUserOptions())
	fail(""Loader: setOptions method failed"");
    }

    if (m_OptionTesterSaver.getOptionHandler() != null) {
      if (!m_OptionTesterSaver.checkCanonicalUserOptions())
	fail(""Saver: setOptions method failed"");
    }
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public void testResettingOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;
    
    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkSetOptions())
	fail(""Loader: Resetting of options failed"");
    }

    if (m_OptionTesterSaver.getOptionHandler() != null) {
      if (!m_OptionTesterSaver.checkSetOptions())
	fail(""Saver: Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETesterLoader.checkGlobalInfo())
      fail(""Loader: No globalInfo method"");

    if (!m_GOETesterSaver.checkGlobalInfo())
      fail(""Saver: No globalInfo method"");
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETesterLoader.checkToolTips())
      fail(""Loader: Tool tips inconsistent"");

    if (!m_GOETesterSaver.checkToolTips())
      fail(""Saver: Tool tips inconsistent"");
  }",./weka/src/test/java/weka/core/converters/AbstractConverterTest.java,weka-master
"public SVMLightTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/SVMLightTest.java,weka-master
"public XRFFTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/XRFFTest.java,weka-master
"public C45Test(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/C45Test.java,weka-master
"public void testLoaderWithStream() {
    System.out.println(""testLoaderWithStream is ignored!"");
  }",./weka/src/test/java/weka/core/converters/C45Test.java,weka-master
"public JSONTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/core/converters/JSONTest.java,weka-master
"public AbstractFileConverterTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public void testBatch() {
    Instances data;

    try {
      // save
      m_Saver.setInstances(m_Instances);
      m_Saver.setFile(new File(m_ExportFilename));
      m_Saver.writeBatch();

      // load
      ((AbstractFileLoader) m_Loader).setFile(new File(m_ExportFilename));
      data = m_Loader.getDataSet();

      // compare data
      try {
        if (m_Instances.classIndex() != data.classIndex()) {
          data.setClassIndex(m_Instances.classIndex());
        }
        compareDatasets(m_Instances, data);
      } catch (Exception e) {
        fail(""Incremental load failed (datasets differ): "" + e.toString());
      }
    } catch (Exception e) {
      e.printStackTrace();
      fail(""Batch save/load failed: "" + e.toString());
    }
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public void testIncrementalLoader() {
    Instance temp;
    Instances data;

    if (!(getLoader() instanceof IncrementalConverter)) {
      return;
    }

    try {
      // save
      m_Saver.setInstances(m_Instances);
      m_Saver.setFile(new File(m_ExportFilename));
      m_Saver.writeBatch();

      // load
      ((AbstractFileLoader) m_Loader).setFile(new File(m_ExportFilename));
      data = new Instances(m_Loader.getStructure());
      do {
        temp = m_Loader.getNextInstance(data);
        if (temp != null) {
          data.add(temp);
        }
      } while (temp != null);

      // compare data
      try {
        if (m_Instances.classIndex() != data.classIndex()) {
          data.setClassIndex(m_Instances.classIndex());
        }
        compareDatasets(m_Instances, data);
      } catch (Exception e) {
        fail(""Incremental load failed (datasets differ): "" + e.toString());
      }
    } catch (Exception e) {
      e.printStackTrace();
      fail(""Incremental load failed: "" + e.toString());
    }
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public void testIncrementalSaver() {
    int i;
    File file;

    if (!(getSaver() instanceof IncrementalConverter)) {
      return;
    }

    try {
      // remove output file if it exists
      file = new File(m_ExportFilename);
      if (file.exists()) {
        file.delete();
      }

      // save
      m_Saver.setFile(new File(m_ExportFilename));
      m_Saver.setRetrieval(AbstractSaver.INCREMENTAL);
      m_Saver.setStructure(new Instances(m_Instances, 0));
      for (i = 0; i < m_Instances.numInstances(); i++) {
        m_Saver.writeIncremental(m_Instances.instance(i));
      }
      m_Saver.writeIncremental(null);
    } catch (Exception e) {
      e.printStackTrace();
      fail(""Incremental save failed: "" + e.toString());
    }
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public void testLoaderCommandlineArgs() {
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public void testSaverCommandlineArgs() {
    String[] options;

    options = getCommandlineOptions(false);

    try {
      ((OptionHandler) m_Saver).setOptions(options);
    } catch (Exception e) {
      e.printStackTrace();
      fail(""Command line test failed ('"" + Utils.arrayToString(options)
        + ""'): "" + e.toString());
    }
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public void testURLSourcedLoader() {
    Instances data;

    if (!(getLoader() instanceof URLSourcedLoader)) {
      return;
    }

    try {
      // save
      m_Saver.setInstances(m_Instances);
      m_Saver.setFile(new File(m_ExportFilename));
      m_Saver.writeBatch();

      // load
      ((URLSourcedLoader) m_Loader).setURL(new File(m_ExportFilename).toURI()
        .toURL().toString());
      data = m_Loader.getDataSet();

      // compare data
      try {
        if (m_Instances.classIndex() != data.classIndex()) {
          data.setClassIndex(m_Instances.classIndex());
        }
        compareDatasets(m_Instances, data);
      } catch (Exception e) {
        fail(""URL load failed (datasets differ): "" + e.toString());
      }
    } catch (Exception e) {
      e.printStackTrace();
      fail(""URL load failed: "" + e.toString());
    }
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public void testLoaderWithStream() {
    Instances data;

    try {
      // save
      m_Saver.setInstances(m_Instances);
      m_Saver.setFile(new File(m_ExportFilename));
      m_Saver.writeBatch();

      // load
      m_Loader.setSource(new FileInputStream(new File(m_ExportFilename)));
      data = m_Loader.getDataSet();

      // compare data
      try {
        if (m_Instances.classIndex() != data.classIndex()) {
          data.setClassIndex(m_Instances.classIndex());
        }
        compareDatasets(m_Instances, data);
      } catch (Exception e) {
        fail(""File stream loading failed (datasets differ): "" + e.toString());
      }
    } catch (Exception e) {
      e.printStackTrace();
      fail(""File stream loading failed: "" + e.toString());
    }
  }",./weka/src/test/java/weka/core/converters/AbstractFileConverterTest.java,weka-master
"public TrieTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testCorrectBuild() {
    // retrieve data
    Iterator<String> iter = m_Trie.iterator();
    HashSet<String> set = new HashSet<String>();
    while (iter.hasNext())
      set.add(iter.next());

    // correct size?
    assertEquals(
	""size() does not reflect number of added strings"", 
	m_Data.length, m_Trie.size());
    
    // different size?
    assertEquals(
	""Iterator returns different number of strings"", 
	m_Data.length, set.size());
    
    // different elements?
    for (int i = 0; i < m_Data.length; i++) {
      if (!set.contains(m_Data[i]))
	fail(""Cannot find string '"" + m_Data[i] + ""'"");
    }
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testDifferentBuildOrder() {
    // build 2. trie
    String[] newData = new String[m_Data.length];
    for (int i = 0; i < m_Data.length; i++)
      newData[i] = m_Data[m_Data.length - i - 1];
    Trie t2 = buildTrie(m_Data);
    
    if (!m_Trie.equals(t2))
      fail(""Tries differ"");
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testClone() {
    // clone trie
    Trie clone = (Trie) m_Trie.clone();
    
    if (!m_Trie.equals(clone))
      fail(""Tries differ"");
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testRemoveAllPartial() {
    Trie remove = buildTrie(m_Data[0]);
    Trie clone = (Trie) m_Trie.clone();
    m_Trie.removeAll(remove);
    assertEquals(""Removing of 1 string"", clone.size(), m_Trie.size() + 1);
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testRemoveAllFull() {
    Trie remove = buildTrie(m_Data);
    Trie clone = (Trie) m_Trie.clone();
    m_Trie.removeAll(remove);
    assertEquals(""Removing all strings"", clone.size(), m_Trie.size() + m_Data.length);
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testRetainAllPartial() {
    Trie retain = buildTrie(m_Data[0]);
    m_Trie.retainAll(retain);
    assertEquals(""Retaining of 1 string"", 1, m_Trie.size());
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testRetainAllFull() {
    Trie retain = buildTrie(m_Data);
    Trie clone = (Trie) m_Trie.clone();
    m_Trie.retainAll(retain);
    assertEquals(""Retaining all strings"", clone.size(), m_Trie.size());
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testCommonPrefix() {
    String returned = m_Trie.getCommonPrefix();
    assertEquals(""Common prefixes differ"", 0, returned.length());

    String expected = ""this is a"";
    Trie t = buildTrie(new String[]{m_Data[0], m_Data[1]});
    returned = t.getCommonPrefix();
    assertEquals(""Common prefixes differ"", expected.length(), returned.length());
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public void testFindPrefixes() {
    Vector<String> prefixes = m_Trie.getWithPrefix(""this"");
    assertEquals(""Different number of prefixes returned"", 2, prefixes.size());

    prefixes = m_Trie.getWithPrefix(""blah"");
    assertEquals(""Different number of prefixes returned"", 0, prefixes.size());
  }",./weka/src/test/java/weka/core/TrieTest.java,weka-master
"public InstancesTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public void testVarianceBehavior() {
    Instances inst;
    
    // weight <= 1 leads to NaN variance:
    inst = getNumericInstances();
    addWeightedValues(inst, 100, 0.5);

    assertTrue(""Instances.variance not NaN for weight <= 1!"",
        Double.isNaN(inst.variance(0)));
    assertTrue(""Instances.variance not NaN for weight <= 1!"",
        Double.isNaN(inst.variances()[0]));

    // even if count > 1, weight <= 1 leads to NaN variance:
    inst = getNumericInstances();
    addWeightedValues(inst, 100, 0.5, 100, 0.3);

    assertTrue(""Instances.variance not NaN for weight <= 1!"",
        Double.isNaN(inst.variance(0)));
    assertTrue(""Instances.variance not NaN for weight <= 1!"",
        Double.isNaN(inst.variances()[0]));
    
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public void testVarianceAccuracy() {
    checkVariance(generatedWeightedValues1, generatedVar1);
    checkVariance(generatedWeightedValues2, generatedVar2);
    checkVariance(generatedWeightedValues3, generatedVar3);
    checkVariance(generatedWeightedValues4, generatedVar4);
    checkVariance(generatedWeightedValues5, generatedVar5, 1e-2);
    checkVariance(generatedWeightedValues6, generatedVar6, 2);
    checkVariance(generatedWeightedValues7, generatedVar7);
    checkVariance(generatedWeightedValues8, generatedVar8);
    checkVariance(generatedWeightedValues9, generatedVar9);
    checkVariance(generatedWeightedValues10, generatedVar10);
    checkVariance(generatedWeightedValues11, generatedVar11);
    checkVariance(generatedWeightedValues12, generatedVar12);
    checkVariance(generatedWeightedValues13, generatedVar13);
    checkVariance(generatedWeightedValues14, generatedVar14, 3);
    checkVariance(generatedWeightedValues15, generatedVar15);
    checkVariance(generatedWeightedValues16, generatedVar16, 2);
    checkVariance(generatedWeightedValues17, generatedVar17);
    checkVariance(generatedWeightedValues18, generatedVar18, 2);
    checkVariance(generatedWeightedValues19, generatedVar19);
    checkVariance(generatedWeightedValues20, generatedVar20, 2);
    checkVariance(generatedWeightedValues21, generatedVar21);
    checkVariance(generatedWeightedValues22, generatedVar22);
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public void testCreationUnique() {
    Instances			data;
    ArrayList<Attribute>	atts;
    String			relName;
    
    relName = ""testCreationUnique"";
    atts    = new ArrayList<Attribute>();
    atts.add(new Attribute(""att-numeric_1""));
    atts.add(new Attribute(""att-numeric_2""));
    atts.add(new Attribute(""att-data_1"", ""yyyy-MM-dd HH:mm""));
    atts.add(new Attribute(""att-nominal_1"", new ArrayList<String>(Arrays.asList(new String[]{""1"", ""2"", ""3""}))));
    atts.add(new Attribute(""att-nominal_2"", new ArrayList<String>(Arrays.asList(new String[]{""yes"", ""no""}))));
    atts.add(new Attribute(""att-string_1"", (ArrayList<String>) null));
    data = new Instances(relName, atts, 0);
    
    assertEquals(""relation name differs"", relName, data.relationName());
    assertEquals(""# of attributes differ"", atts.size(), data.numAttributes());
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public void testCreationAmbiguous() {
    Instances			data;
    ArrayList<Attribute>	atts;
    String			relName;
    
    relName = ""testCreationAmbiguous"";
    atts    = new ArrayList<Attribute>();
    atts.add(new Attribute(""att-numeric_1""));
    atts.add(new Attribute(""att-numeric_1""));
    atts.add(new Attribute(""att-data_1"", ""yyyy-MM-dd HH:mm""));
    atts.add(new Attribute(""att-nominal_1"", new ArrayList<String>(Arrays.asList(new String[]{""1"", ""2"", ""3""}))));
    atts.add(new Attribute(""att-nominal_1"", new ArrayList<String>(Arrays.asList(new String[]{""yes"", ""no""}))));
    atts.add(new Attribute(""att-string_1"", (ArrayList<String>) null));
    
    try {
      data = new Instances(relName, atts, 0);
    }
    catch (IllegalArgumentException e) {
      data = null;
    }
    assertNull(""dataset created with ambiguous attribute names"", data);
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public void testHeaderCopy() {
    Instances 	data;
    
    data = new Instances(m_Instances, 0);
    assertEquals(""# of attributes differ"", m_Instances.numAttributes(), data.numAttributes());
    assertEquals(""class index differs"", m_Instances.classIndex(), data.classIndex());
    assertEquals(""Unexpected instances"", 0, data.numInstances());

    m_Instances.setClassIndex(m_Instances.numAttributes() - 1);
    data = new Instances(m_Instances, 0);
    assertEquals(""class index differs"", m_Instances.classIndex(), data.classIndex());
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public void testFullCopy() {
    Instances data;
    
    data = new Instances(m_Instances);
    assertEquals(""# of attributes differ"", m_Instances.numAttributes(), data.numAttributes());
    assertEquals(""class index differs"", m_Instances.classIndex(), data.classIndex());
    assertEquals(""# of instances differ"", m_Instances.numInstances(), data.numInstances());

    m_Instances.setClassIndex(m_Instances.numAttributes() - 1);
    data = new Instances(m_Instances);
    assertEquals(""class index differs"", m_Instances.classIndex(), data.classIndex());
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public void testPartialCopy() {
    Instances data;
    
    data = new Instances(m_Instances, 0, m_Instances.numInstances());
    assertEquals(""# of instances differ"", m_Instances.numInstances(), data.numInstances());

    data = new Instances(m_Instances, 5, 10);
    assertEquals(""# of instances differ"", 10, data.numInstances());
  }",./weka/src/test/java/weka/core/InstancesTest.java,weka-master
"public ExpressionLanguageTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"private static String evaluateString(String expr, Object... values) throws Exception {
  
    Node node = compile(expr, values);

    if (!(node instanceof StringExpression))
      throw new Exception(""Type error in expression!"");
  
    return ((StringExpression) node).evaluate();
  
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testParsing() throws Exception {
    
    // bug in AttributeExpression
    evaluateDouble(""0.0 + (-0.0 + 0.0)"");

    // bug in MathematicalExpression
    evaluateDouble(""(4.0-2.0)"");
    
    // basic strings
    assertEquals(""asdf"", evaluateString(""'asdf'""));
    assertEquals(""asdf"", evaluateString(""\""asdf\""""));
    
    // escape sequences
    assertEquals(""\b\f\n\r\t\\\""\'"", evaluateString(""'\\b\\f\\n\\r\\t\\\\\\\""\\''""));
    assertEquals(""\b\f\n\r\t\\\""\'"", evaluateString(""\""\\b\\f\\n\\r\\t\\\\\\\""\\'\""""));
    
    // incorrect escaping
    try {
      evaluateString(""'\\a\\b'"");
      fail(""Didn't detect improper string escaping"");
    } catch (Exception e) {
      //ok
    }
    try {
      evaluateString(""\""\\a\\b\"""");
      fail(""Didn't detect improper string escaping"");
    } catch (Exception e) {
      //ok
    }

    // parser respects brackets:
    assertEquals(4.0,
        evaluateDouble(""8.0/(4.0/2.0)""));
    assertEquals(6.0,
        evaluateDouble(""8.0 - (4.0 - 2.0)""));
    
    // parser can handle brackets
    evaluateDouble(""((((((((((((1))))))))))))"");
    evaluateDouble(""((((((((((((1)))))))))))) + ((((((((((((1))))))))))))"");
    evaluateDouble(""((((((((((((1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1"");

    // parser can handle many operators in a row
    evaluateDouble(""1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1"");
    evaluateDouble(""1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1"");
    evaluateDouble(""1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1"");
    evaluateDouble(""1 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1 / 1"");
    evaluateDouble(""1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1"");
     
    // unary operators
    evaluateDouble(""--------1"");
    evaluateDouble(""1--------1"");
    evaluateDouble(""++++++++1"");
    evaluateDouble(""1++++++++1"");
    evaluateDouble(""-+-+-+-+1"");
    evaluateDouble(""1-+-+-+-+1"");
    evaluateBoolean(""not not not not not not true"");
    evaluateBoolean(""! ! ! ! ! true"");
    evaluateBoolean(""!!!!!true"");
    evaluateBoolean(""not ! not ! not true"");
    evaluateBoolean(""not!not!not true"");

    // float parsing
    try {
      assertEquals(1.0, evaluateDouble(""1""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(1.0, evaluateDouble(""1.0""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(1.0, evaluateDouble(""1.0000000000000000000000000000000""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(0.0, evaluateDouble(""0""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(0.0, evaluateDouble(""0.0""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(0.0, evaluateDouble(""0.00000000000000000000000000000000""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(-1.0, evaluateDouble(""-1""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(-1.0, evaluateDouble(""-1.0""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      assertEquals(-1.0, evaluateDouble(""-1.00000000000000000000000000000000""));
    } catch (Exception e) {
      fail(""Parsing failure!"");
    }
    try {
      // parser error
      evaluateDouble(""1.0 & 5"");
      fail(""Failed to find syntax error!"");
    } catch (Exception e) {
      // ok
    }
    try {
      // scanner error
      evaluateDouble(""1.000a0"");
      fail(""Failed to find syntax error!"");
    } catch (Exception e) {
      // ok
    }
 
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testVariables() throws Exception {

    SimpleVariableDeclarations vars = new SimpleVariableDeclarations();
    vars.addBoolean(""someBool"");
    vars.addDouble(""someDouble"");
    vars.addString(""someString"");
    vars.addString(""__weird_NAME_0123456789__"");
  
    DoubleExpression root = (DoubleExpression) Parser.parse(
        ""someDouble + ifelse(someBool, 0.0, ifelse(someString + __weird_NAME_0123456789__ regexp 'asdf', 1.0, 2.0))"",
        vars,
        new MacroDeclarationsCompositor(
            new IfElseMacro(), new MathFunctions()
            )
        );
  
    double[] values = { 0.0, 1.0, Double.NaN, Double.POSITIVE_INFINITY};
    
    vars.getInitializer().setBoolean(""someBool"", true);
    for (double value : values) {
      vars.getInitializer().setDouble(""someDouble"", value);
      assertEquals(value + 0.0, root.evaluate());
    }
    
    vars.getInitializer().setBoolean(""someBool"", false);
    for (double value : values) {
      vars.getInitializer().setDouble(""someDouble"", value);
  
      vars.getInitializer().setString(""someString"", ""as"");
      vars.getInitializer().setString(""__weird_NAME_0123456789__"", ""df"");
      assertEquals(value + 1.0, root.evaluate());
  
      vars.getInitializer().setString(""someString"", ""clearly not matchin!"");
      vars.getInitializer().setString(""__weird_NAME_0123456789__"", ""and neither is this one"");
      assertEquals(value + 2.0, root.evaluate());
    }
 
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testPlusOperator() throws Exception {
    
    double[] values = {0.0,  1.0,  2.0,  3.0,  100.0,  1000.0,  1e8,  1e-8,  0.1,
                       -0.0, -1.0, -2.0, -3.0, -100.0, -1000.0, -1e8, -1e-8, -0.1};
    
    // Note: assertEquals(0.0, -0.0) fails, thus we're using asserTrue(... == ...)

    for (double left : values) {
      
      // neutral element:
      assertTrue(left == evaluateDouble(String.format(""%.20f + 0.0"", left)));
      assertTrue(left == evaluateDouble(String.format(""0.0 + %.20f"", left)));

      for (double right: values) {
        // basics
        assertTrue(left + right == evaluateDouble(String.format(""%.20f + %.20f"", left, right)));
        
        // commutativity
        assertTrue(evaluateDouble(String.format(""%.20f + %.20f"", left, right)) == 
                   evaluateDouble(String.format(""%.20f + %.20f"", right, left)));
      }
    }

    double[] safe_values = {0.0, 1.0, 2.0, -0.0, -1.0, -2.0};
    for (double first : safe_values) {
      for (double second : safe_values) {
        for (double third : safe_values) {
          // due to commutativity the operator is both left and right associative
          // so we test both

          // left associativity
          assertTrue(
              evaluateDouble(String.format(
                  ""%.20f + %.20f + %.20f"", first, second, third))
              == 
              evaluateDouble(String.format(
                  ""(%.20f + %.20f) + %.20f"", first, second, third))
              );

          // right associativity
          assertTrue(
              evaluateDouble(String.format(
                  ""%.20f + %.20f + %.20f"", first, second, third))
              == 
              evaluateDouble(String.format(
                  ""%.20f + (%.20f + %.20f)"", first, second, third))
              );
        }
      }
    }

    // basic double semantics
    // NaN + v == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) + 1.0"")));
    // NaN + NaN == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) + sqrt(-1.0)"")));
    // overflow -> +inf
    assertTrue(Double.isInfinite(evaluateDouble(String.format(
        ""%.20f + %.20f"", Double.MAX_VALUE, Double.MAX_VALUE))));
    // inf + (-inf) == NaN
    assertTrue(Double.isNaN(evaluateDouble(""1/0 + -1/0"")));
    // inf + inf == inf 
    assertTrue(Double.isInfinite(evaluateDouble(""1/0 + 1/0"")));
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testStringConcatenation() throws Exception {
    
    assertEquals(""asdf"", evaluateString(""'asdf'""));
    assertEquals(""asdf"", evaluateString(""\""asdf\""""));
    assertEquals(""asdf"", evaluateString(""'as' + 'df'""));
    assertEquals(""asdf"", evaluateString(""\""as\"" + \""df\""""));
    assertEquals(""asdf"", evaluateString(""'as' + \""df\""""));
    assertEquals(""asdf"", evaluateString(""\""as\"" + 'df'""));
    assertEquals(""Hello World from WEKA :)"",
        evaluateString(""'Hello' + \"" W\"" + \""o\"" + ('r' + (\""l\"" + (('d'))) + \"" from\"")+' WEKA :)'""));
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testMinusOperator() throws Exception {
    
    double[] values = {0.0,  1.0,  2.0,  3.0,  100.0,  1000.0,  1e8,  1e-8,  0.1,
                      -0.0, -1.0, -2.0, -3.0, -100.0, -1000.0, -1e8, -1e-8, -0.1};
    
    // Note: assertEquals(0.0, -0.0) fails, thus we're using asserTrue(... == ...)

    for (double left : values) {
      
      // neutral element:
      assertTrue(left == evaluateDouble(String.format(""%.20f - 0.0"", left)));

      for (double right: values) {
        // basics
        assertTrue(left - right == evaluateDouble(String.format(""%.20f - %.20f"", left, right)));
      }
    }

    double[] safe_values = {0.0, 1.0, 2.0, -0.0, -1.0, -2.0};
    for (double first : safe_values) {
      for (double second : safe_values) {
        for (double third : safe_values) {
          // left associativity
          assertTrue(
              evaluateDouble(String.format(
                  ""%.20f - %.20f - %.20f"", first, second, third))
              == 
              evaluateDouble(String.format(
                  ""(%.20f - %.20f) - %.20f"", first, second, third))
              );
        }
      }
    }

    // basic double semantics
    // NaN - v == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) - 1.0"")));
    // NaN - NaN == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) - sqrt(-1.0)"")));
    // underflow -> -inf
    assertTrue(Double.isInfinite(evaluateDouble(String.format(
        ""%.20f - %.20f"", -Double.MAX_VALUE, Double.MAX_VALUE))));
    // inf - inf == NaN
    assertTrue(Double.isNaN(evaluateDouble(""1/0 - 1/0"")));
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testTimesOperator() throws Exception {
    
    double[] values = {0.0,  1.0,  2.0,  3.0,  100.0,  1000.0,  1e8,  1e-8,  0.1,
                       -0.0, -1.0, -2.0, -3.0, -100.0, -1000.0, -1e8, -1e-8, -0.1};
    
    // Note: assertEquals(0.0, -0.0) fails, thus we're using asserTrue(... == ...)

    for (double left : values) {
      
      // neutral element:
      assertTrue(left == evaluateDouble(String.format(""%.20f * 1.0"", left)));
      assertTrue(left == evaluateDouble(String.format(""1.0 * %.20f"", left)));

      for (double right: values) {
        // basics
        assertTrue(left * right == evaluateDouble(String.format(""%.20f * %.20f"", left, right)));
        
        // commutativity
        assertTrue(evaluateDouble(String.format(""%.20f * %.20f"", left, right)) == 
                   evaluateDouble(String.format(""%.20f * %.20f"", right, left)));
      }
    }

    double[] safe_values = {0.0, 1.0, 2.0, -0.0, -1.0, -2.0};
    for (double first : safe_values) {
      for (double second : safe_values) {
        for (double third : safe_values) {
          // due to commutativity the operator is both left and right associative
          // so we test both

          // left associativity
          assertTrue(
              evaluateDouble(String.format(
                  ""%.20f * %.20f * %.20f"", first, second, third))
              == 
              evaluateDouble(String.format(
                  ""(%.20f * %.20f) * %.20f"", first, second, third))
              );

          // right associativity
          assertTrue(
              evaluateDouble(String.format(
                  ""%.20f * %.20f * %.20f"", first, second, third))
              == 
              evaluateDouble(String.format(
                  ""%.20f * (%.20f * %.20f)"", first, second, third))
              );
        }
      }
    }

    // basic double semantics
    // NaN * v == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) * 1.0"")));
    // NaN * NaN == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) * sqrt(-1.0)"")));
    // overflow -> +inf
    assertTrue(Double.isInfinite(evaluateDouble(String.format(
        ""%.20f * %.20f"", Double.MAX_VALUE, Double.MAX_VALUE))));
    // inf + (-inf) == -inf 
    assertTrue(Double.isInfinite(evaluateDouble(""(1/0) * (-1/0)"")));
    // inf * inf == inf 
    assertTrue(Double.isInfinite(evaluateDouble(""(1/0) * (1/0)"")));
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testDivisionOperator() throws Exception {
    
    double[] values = {0.0,  1.0,  2.0,  3.0,  100.0,  1000.0,  1e8,  1e-8,  0.1,
                       -0.0, -1.0, -2.0, -3.0, -100.0, -1000.0, -1e8, -1e-8, -0.1};
    
    // Note: assertEquals(0.0, -0.0) fails, thus we're using asserTrue(... == ...)

    for (double left : values) {
      
      // neutral element:
      assertTrue(left == evaluateDouble(String.format(""%.20f / 1.0"", left)));

      for (double right: values) {
        // basics
        if (left == 0.0 && right == 0.0)
          continue; // NaN == NaN always evaluates to false
        assertTrue(left / right == evaluateDouble(String.format(""%.20f / %.20f"", left, right)));
      }
    }

    double[] safe_values = {0.0, 1.0, 2.0, -0.0, -1.0, -2.0};
    for (double first : safe_values) {
      for (double second : safe_values) {
        for (double third : safe_values) {
          if (first == 0.0 && (second == 0.0 || third == 0.0))
            continue; // NaN == NaN always evaluates to false
          // left associativity
          try {
          assertTrue(
              evaluateDouble(String.format(
                  ""%.20f / %.20f / %.20f"", first, second, third))
              == 
              evaluateDouble(String.format(
                  ""(%.20f / %.20f) / %.20f"", first, second, third))
              );
          } catch (AssertionFailedError e) {
            System.out.println(""failed"");
          assertTrue(
              evaluateDouble(String.format(
                  ""%.20f / %.20f / %.20f"", first, second, third))
              == 
              evaluateDouble(String.format(
                  ""(%.20f / %.20f) / %.20f"", first, second, third))
              );
          }
        }
      }
    }

    // basic double semantics
    // NaN / v == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) / 1.0"")));
    // NaN / NaN == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) / sqrt(-1.0)"")));
    // overflow -> +inf
    assertTrue(Double.isInfinite(evaluateDouble(String.format(
        ""%.20f + %.20f"", Double.MAX_VALUE, Double.MAX_VALUE))));
    // inf / inf == NaN 
    assertTrue(Double.isNaN(evaluateDouble(""(1/0) / (1/0)"")));
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testPowOperator() throws Exception {
    
    double[] values = {0.0,  1.0,  2.0,  3.0,  100.0,  1000.0,  1e8,  1e-8,  0.1,
                       -0.0, -1.0, -2.0, -3.0, -100.0, -1000.0, -1e8, -1e-8, -0.1};
    
    // Note: assertEquals(0.0, -0.0) fails, thus we're using asserTrue(... == ...)

    for (double left : values) {
      
      // neutral element:
      assertTrue(left == evaluateDouble(String.format(""%.20f ^ 1.0"", left)));
      assertTrue(1.0 == evaluateDouble(String.format(""1.0 ^ %.20f"", left)));

      for (double right: values) {
        // basics
        if (!Double.isNaN(Math.pow(left, right)))
          assertTrue(Math.pow(left, right) == evaluateDouble(String.format(""(%.20f) ^ (%.20f)"", left, right)));
      }
    }

    double[] safe_values = {0.0, 1.0, 2.0, -0.0, -1.0, -2.0};
    for (double first : safe_values) {
      for (double second : safe_values) {
        for (double third : safe_values) {
      
          // right associativity
          if (!Double.isNaN(Math.pow(first, Math.pow(second, third))))
            assertTrue(
                evaluateDouble(String.format(
                    ""(%.20f) ^ (%.20f) ^ (%.20f)"", first, second, third))
                    == 
                    evaluateDouble(String.format(
                        ""(%.20f) ^ ((%.20f) ^ (%.20f))"", first, second, third))
                );
        }
      }
    }

    // basic double semantics
    // NaN ^ v == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) ^ 1.0"")));
    // v ^ NaN == NaN
    assertTrue(Double.isNaN(evaluateDouble(""1.0 ^ sqrt(-1)"")));
    // NaN ^ NaN == NaN
    assertTrue(Double.isNaN(evaluateDouble(""sqrt(-1) ^ sqrt(-1.0)"")));
    // overflow -> ^inf
    assertTrue(Double.isInfinite(evaluateDouble(String.format(
        ""%.20f ^ 2"", Double.MAX_VALUE))));
    // inf ^ (-inf) == NaN
    assertTrue(Double.isNaN(evaluateDouble(""1/0 ^ -1/0"")));
    // inf ^ inf == inf 
    assertTrue(Double.isInfinite(evaluateDouble(""1/0 + 1/0"")));
    

  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testAndOperator() throws Exception {
    
    boolean[] values = {true, false};
    for (boolean left : values) {
      for (boolean right : values) {
        // basics
        assertEquals(
            left && right,
            evaluateBoolean(left + "" and "" + right)
            );
        assertEquals(
            left && right,
            evaluateBoolean(left + "" & "" + right)
            );
        
        // commutativity
        assertEquals(
            evaluateBoolean(right + "" and "" + left),
            evaluateBoolean(left + "" and "" + right)
            );
        assertEquals(
            evaluateBoolean(right + "" & "" + left),
            evaluateBoolean(left + "" & "" + right)
            );
        
        for (boolean third : values) {
          // due to commutativity the operator is both left and right associative
          // so we test both
          
          // left associativity
          assertEquals(
              left && right && third,
              evaluateBoolean(""("" + left + "" and "" + right + "") and "" + third)
              );
          assertEquals(
              left && right && third,
              evaluateBoolean(""("" + left + "" & "" + right + "") & "" + third)
              );
  
          // right associativity
          assertEquals(
              left && right && third,
              evaluateBoolean(left + "" and ("" + right + "" and "" + third + "")"")
              );
          assertEquals(
              left && right && third,
              evaluateBoolean(left + "" & ("" + right + "" & "" + third + "")"")
              );
          
          // interchangeability
          assertEquals(
              left && right && third,
              evaluateBoolean(left + "" & "" + right + "" and "" + third)
              );
  
        }
      }
    }
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testOrOperator() throws Exception {
    
    boolean[] values = {true, false};
    for (boolean left : values) {
      for (boolean right : values) {
        // basics
        assertEquals(
            left || right,
            evaluateBoolean(left + "" or "" + right)
            );
        assertEquals(
            left || right,
            evaluateBoolean(left + "" | "" + right)
            );
        
        // commutativity
        assertEquals(
            evaluateBoolean(right + "" or "" + left),
            evaluateBoolean(left + "" or "" + right)
            );
        assertEquals(
            evaluateBoolean(right + "" | "" + left),
            evaluateBoolean(left + "" | "" + right)
            );
        
        for (boolean third : values) {
          // due to commutativity the operator is both left and right associative
          // so we test both
          
          // left associativity
          assertEquals(
              left || right || third,
              evaluateBoolean(""("" + left + "" or "" + right + "") or "" + third)
              );
          assertEquals(
              left || right || third,
              evaluateBoolean(""("" + left + "" | "" + right + "") | "" + third)
              );
  
          // right associativity
          assertEquals(
              left || right || third,
              evaluateBoolean(left + "" or ("" + right + "" or "" + third + "")"")
              );
          assertEquals(
              left || right || third,
              evaluateBoolean(left + "" | ("" + right + "" | "" + third + "")"")
              );
          
          // interchangeability
          assertEquals(
              left || right || third,
              evaluateBoolean(left + "" or "" + right + "" | "" + third)
              );
  
        }
      }
    }
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testEqualsOperator() throws Exception {
    
    double[] values = {0.0,  1.0,  2.0,  3.0,  100.0,  1000.0,  1e8,  1e-8,  0.1,
                       -0.0, -1.0, -2.0, -3.0, -100.0, -1000.0, -1e8, -1e-8, -0.1};
    
  
    for (double left : values) {
      
      // reflexivity
      assertTrue(evaluateBoolean(String.format(""%.20f = %.20f"", left, left)));
      
      for (double right: values) {
        // basics
        assertEquals(
            left == right,
            evaluateBoolean(String.format(
                ""%.20f = %.20f"", left, right))
            );
        
        // commutativity
        assertEquals(
            evaluateBoolean(String.format(
                ""%.20f = %.20f"", left, right)),
            evaluateBoolean(String.format(
                ""%.20f = %.20f"", right, left))
            );
      }
    }
  
    // non-associativity
    try {
      evaluateBoolean(""1.0 == 1.0 == 1.0"");
      fail(""non-associativity!"");
    } catch (Exception e) {
      // ok
    }
  
    // basic double semantics
    // inf = inf -> true
    assertTrue(evaluateBoolean(""1/0 = 1/0""));
    // -inf = inf -> false
    assertFalse(evaluateBoolean(""-1/0 = 1/0""));
    // NaN = NaN -> false
    assertFalse(evaluateBoolean(""sqrt(-1) = sqrt(-1)""));
    // 0 = NaN -> false
    assertFalse(evaluateBoolean(""0.0 = sqrt(-1)""));
    // inf = NaN -> false
    assertFalse(evaluateBoolean(""1/0 = sqrt(-1)""));
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testLtLeGtGeOperator() throws Exception {
  
    double[] values = {0.0,  1.0,  2.0,  3.0,  100.0,  1000.0,  1e8,  1e-8,  0.1,
                       -0.0, -1.0, -2.0, -3.0, -100.0, -1000.0, -1e8, -1e-8, -0.1};
    
    for (double left : values) {
      
      assertFalse(evaluateBoolean(String.format(""%.20f < %.20f"", left, left)));
      assertTrue(evaluateBoolean(String.format(""%.20f <= %.20f"", left, left)));
      assertFalse(evaluateBoolean(String.format(""%.20f > %.20f"", left, left)));
      assertTrue(evaluateBoolean(String.format(""%.20f >= %.20f"", left, left)));
      
      for (double right: values) {
        // basics
        assertEquals(
            left < right,
            evaluateBoolean(String.format(""%.20f < %.20f"", left, right))
            );
        assertEquals(
            left <= right,
            evaluateBoolean(String.format(""%.20f <= %.20f"", left, right))
            );
        assertEquals(
            left > right,
            evaluateBoolean(String.format(""%.20f > %.20f"", left, right))
            );
        assertEquals(
            left >= right,
            evaluateBoolean(String.format(""%.20f >= %.20f"", left, right))
            );
      }
    }
  
    // non-associativity
    try {
      evaluateBoolean(""1.0 < 1.0 < 1.0"");
      fail(""non-associativity!"");
    } catch (Exception e) {
      // ok
    }
    try {
      evaluateBoolean(""1.0 <= 1.0 <= 1.0"");
      fail(""non-associativity!"");
    } catch (Exception e) {
      // ok
    }
    try {
      evaluateBoolean(""1.0 > 1.0 > 1.0"");
      fail(""non-associativity!"");
    } catch (Exception e) {
      // ok
    }
    try {
      evaluateBoolean(""1.0 >= 1.0 >= 1.0"");
      fail(""non-associativity!"");
    } catch (Exception e) {
      // ok
    }
  
    // basic double semantics
    // inf < inf -> false
    assertFalse(evaluateBoolean(""1/0 < 1/0""));
    // inf <= inf -> true
    assertTrue(evaluateBoolean(""1/0 <= 1/0""));
    // inf > inf -> false
    assertFalse(evaluateBoolean(""1/0 > 1/0""));
    // inf >= inf -> true
    assertTrue(evaluateBoolean(""1/0 >= 1/0""));
  
    // -inf < inf -> true
    assertTrue(evaluateBoolean(""-1/0 < 1/0""));
    // -inf <= inf -> true
    assertTrue(evaluateBoolean(""-1/0 <= 1/0""));
    // -inf > inf -> false
    assertFalse(evaluateBoolean(""-1/0 > 1/0""));
    // -inf >= inf -> false
    assertFalse(evaluateBoolean(""-1/0 >= 1/0""));
  
    // NaN < NaN -> false
    assertFalse(evaluateBoolean(""sqrt(-1) < sqrt(-1)""));
    // NaN <= NaN -> false
    assertFalse(evaluateBoolean(""sqrt(-1) <= sqrt(-1)""));
    // NaN > NaN -> false
    assertFalse(evaluateBoolean(""sqrt(-1) > sqrt(-1)""));
    // NaN >= NaN -> false
    assertFalse(evaluateBoolean(""sqrt(-1) >= sqrt(-1)""));
  
    // 0 < NaN -> false
    assertFalse(evaluateBoolean(""0.0 < sqrt(-1)""));
    // 0 <= NaN -> false
    assertFalse(evaluateBoolean(""0.0 <= sqrt(-1)""));
    // 0 > NaN -> false
    assertFalse(evaluateBoolean(""0.0 > sqrt(-1)""));
    // 0 >= NaN -> false
    assertFalse(evaluateBoolean(""0.0 >= sqrt(-1)""));
  
    // inf < NaN -> false
    assertFalse(evaluateBoolean(""1/0 < sqrt(-1)""));
    // inf <= NaN -> false
    assertFalse(evaluateBoolean(""1/0 <= sqrt(-1)""));
    // inf > NaN -> false
    assertFalse(evaluateBoolean(""1/0 > sqrt(-1)""));
    // inf >= NaN -> false
    assertFalse(evaluateBoolean(""1/0 >= sqrt(-1)""));
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testPrecedence() throws Exception {

    // ^ has higher precedence than *, /
    // bug in AttributeExpression
    assertEquals(32.0, evaluateDouble(""8*2^2""));
    assertEquals(2.0, evaluateDouble(""8/2^2""));
    
    // ^ has higher precedence than unary -
    assertEquals(-1.0, evaluateDouble(""-1^2""));

    // *, / have higher precedence than +, -
    assertEquals(10.0,evaluateDouble(""2.0*3.0 + 4.0""));
    assertEquals(2.0,evaluateDouble(""2.0*3.0 - 4.0""));
    assertEquals(-0.5,evaluateDouble(""2.0/4.0 - 1.0""));
    assertEquals(1.5,evaluateDouble(""2.0/4.0 + 1.0""));

    // unary - has higher precedence than +, -
    assertEquals(1.0,evaluateDouble(""-1.0 + 2.0""));
    assertEquals(-3.0,evaluateDouble(""-1.0 - 2.0""));
    // due to the associativity of *, / we don't have to test for unary - over *, /
    
    // +, -, /, * have higher precedence than =, <=, <, >, >=
    // if not, then the program will fail due to a type error
    assertTrue(evaluateBoolean(""1.0 + 2.0 >= 2.5""));
    assertFalse(evaluateBoolean(""-2.0 - 2.0 > -2.5""));
    assertFalse(evaluateBoolean(""2.0 * 2.0 <= 2.5""));
    assertFalse(evaluateBoolean(""1.0 / 0.5 < 1.0""));
    assertTrue(evaluateBoolean(""1.0 + 2.0 = 3.0""));
  
    // =, <=, <, >, >= have higher precedence than &&, ||
    // if not, then the program will fail due to a type error
    assertTrue(evaluateBoolean(""1.0 < 2.0 and true""));
    assertTrue(evaluateBoolean(""1.0 <= 2.0 or false""));
    assertFalse(evaluateBoolean(""1.0 > 2.0 and true""));
    assertFalse(evaluateBoolean(""1.0 >= 2.0 or false""));
    assertFalse(evaluateBoolean(""1.0 = 2.0 and true""));
    assertTrue(evaluateBoolean(""1.0 < 2.0 & true""));
    assertTrue(evaluateBoolean(""1.0 <= 2.0 | false""));
    assertFalse(evaluateBoolean(""1.0 > 2.0 & true""));
    assertFalse(evaluateBoolean(""1.0 >= 2.0 | false""));
    assertFalse(evaluateBoolean(""1.0 = 2.0 & true""));
    
    // ! has higher precedence than &&
    assertFalse(evaluateBoolean(""not true and false""));
    assertFalse(evaluateBoolean(""not false and false""));
    assertFalse(evaluateBoolean(""! true & false""));
    assertFalse(evaluateBoolean(""! false & false""));

    // ! has higher precedence than ||
    assertTrue(evaluateBoolean(""not true or true""));
    assertTrue(evaluateBoolean(""not false or true""));
    assertTrue(evaluateBoolean(""! true | true""));
    assertTrue(evaluateBoolean(""! false | true""));

    // && has higher precedence than ||
    assertTrue(evaluateBoolean(""false and false or true""));
    assertTrue(evaluateBoolean(""false and true or true""));
    assertTrue(evaluateBoolean(""false & false | true""));
    assertTrue(evaluateBoolean(""false & true | true""));

  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testCompositions() throws Exception {

    String[] binaryDoubleOperators = {""+"", ""-"", ""*"", ""/""};
    String[] comparisonOperators = {""="", ""<"", "">=""};
    String[] booleanBinaryOperators = {""&"", ""|"", ""and"", ""or""};
    
    for (String booleanBinaryOperator : booleanBinaryOperators) {
      for (String comparisonOperator : comparisonOperators) {
        for (String binaryDoubleOperator : binaryDoubleOperators) {
          evaluateDouble(
              String.format(""ifelse(exp(sin(A) %s B) %s C %s true, tan(A), rint(C) + 3.0)""
                  + "" + java('java.lang.Math', 'double nextUp(double)', C^3)"",
                  binaryDoubleOperator, comparisonOperator, booleanBinaryOperator),
              11.0, 43.0, 89.0
              );
        }
      }
    }
    
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testMathFunctions() throws Exception {
    
    for (double v : new double[]{1.0, 2.0, 100.0, -1.0, -2.0, -100.0, 0.0}) {
      assertEquals(Math.abs(v), evaluateDouble(""abs(A)"", v));
      assertEquals(Math.log(v), evaluateDouble(""log(A)"", v));
      assertEquals(Math.exp(v), evaluateDouble(""exp(A)"", v));
      assertEquals(Math.sin(v), evaluateDouble(""sin(A)"", v));
      assertEquals(Math.cos(v), evaluateDouble(""cos(A)"", v));
      assertEquals(Math.tan(v), evaluateDouble(""tan(A)"", v));
      assertEquals(Math.sqrt(v), evaluateDouble(""sqrt(A)"", v));
      assertEquals(Math.floor(v), evaluateDouble(""floor(A)"", v));
      assertEquals(Math.ceil(v), evaluateDouble(""ceil(A)"", v));
      assertEquals(Math.rint(v), evaluateDouble(""rint(A)"", v));
      assertEquals(Math.pow(v, v), evaluateDouble(""pow(A, A)"", v));
    }
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public void testCallingJavaFunctions() throws Exception {
    
    double[] values = {0.0, -1.0, 1.0, Double.NaN, Double.POSITIVE_INFINITY,
        100.0};

    for  (double value : values) {
      assertEquals(
          Math.sqrt(value),
          evaluateDouble(""java('java.lang.Math', 'double sqrt(double)', A)"", value)
          );
      assertEquals(
          String.valueOf(value),
          evaluateString(""java('java.lang.String', 'String valueOf(double)', A)"", value)
          );
      assertEquals(
          badRandom(value, value*value, 1/value),
          evaluateDouble(""java('weka.core.expressionlanguage.ExpressionLanguageTest', 'double badRandom(double, double, double)', A, A^2, 1/A)"", value)
          );
    }

    assertEquals(
        Thread.interrupted(),
        evaluateBoolean(""java('java.lang.Thread', 'boolean interrupted()')"")
        );
  }",./weka/src/test/java/weka/core/expressionlanguage/ExpressionLanguageTest.java,weka-master
"public AbstractTokenizerTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler result;

    result = new CheckOptionHandler();
    if (getTokenizer() instanceof OptionHandler) {
      result.setOptionHandler(getTokenizer());
    } else {
      result.setOptionHandler(null);
    }
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE result;

    result = new CheckGOE();
    result.setObject(getTokenizer());
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testSerialVersionUID() {
    boolean result;

    result = !SerializationHelper.needsUID(m_Tokenizer.getClass());

    if (!result) {
      fail(""Doesn't declare serialVersionUID!"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testBuildInitialization() {
    boolean result;
    int i;
    int n;
    String[][][] processed;
    String msg;

    // process data twice
    processed = new String[2][m_Data.length][];
    for (n = 0; n < 2; n++) {
      for (i = 0; i < m_Data.length; i++) {
        try {
          processed[n][i] = Tokenizer.tokenize(m_Tokenizer,
            new String[] { m_Data[i] });
        } catch (Exception e) {
          processed[n][i] = new String[0];
        }
      }
    }

    // was the same data produced?
    result = true;
    msg = """";
    for (i = 0; i < m_Data.length; i++) {
      if (processed[0].length == processed[1].length) {
        for (n = 0; n < processed[0][i].length; n++) {
          if (!processed[0][i][n].equals(processed[1][i][n])) {
            result = false;
            msg = ""different substrings"";
            break;
          }
        }
      } else {
        result = false;
        msg = ""different number of substrings"";
        break;
      }
    }

    if (!result) {
      fail(""Incorrect build initialization ("" + msg + "")!"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testRegression() {
    int i;
    boolean succeeded;
    Regression reg;

    reg = new Regression(this.getClass());
    succeeded = false;

    for (i = 0; i < m_Data.length; i++) {
      try {
        m_RegressionResults[i] = useTokenizer(m_Data[i]);
        succeeded = true;
        reg.println(predictionsToString(m_RegressionResults[i]));
      } catch (Exception e) {
        m_RegressionResults[i] = null;
      }
    }

    if (!succeeded) {
      fail(""Problem during regression testing: no successful tokens generated for any string"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions()) {
        fail(""Options cannot be listed via listOptions."");
      }
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions()) {
        fail(""setOptions method failed."");
      }
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testDefaultOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkDefaultOptions()) {
        fail(""Default options were not processed correctly."");
      }
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions()) {
        fail(""There were 'left-over' options."");
      }
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions()) {
        fail(""setOptions method failed"");
      }
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions()) {
        fail(""Resetting of options failed"");
      }
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo()) {
      fail(""No globalInfo method"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips()) {
      fail(""Tool tips inconsistent"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/AbstractTokenizerTest.java,weka-master
"public WordTokenizerTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/tokenizers/WordTokenizerTest.java,weka-master
"public void testNumberOfGeneratedTokens() {
    String 	s;
    String[]	result;
    
    s = ""HOWEVER, the egg only got larger and larger, and more and more human"";
    try {
      result = Tokenizer.tokenize(m_Tokenizer, new String[]{s});
      assertEquals(""number of tokens differ"", 13, result.length);
    }
    catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/WordTokenizerTest.java,weka-master
"public AlphabeticTokenizerTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/tokenizers/AlphabeticTokenizerTest.java,weka-master
"public void testNumberOfGeneratedTokens() {
    String 	s;
    String[]	result;
    
    // no numbers included
    s = ""HOWEVER, the egg only got larger and larger, and more and more human"";
    try {
      result = Tokenizer.tokenize(m_Tokenizer, new String[]{s});
      assertEquals(""number of tokens differ (1)"", 13, result.length);
    }
    catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }
    
    // numbers included
    s = ""The planet Mars, I scarcely need remind the reader, revolves about the sun at a mean distance of 140,000,000 miles"";
    try {
      result = Tokenizer.tokenize(m_Tokenizer, new String[]{s});
      assertEquals(""number of tokens differ (2)"", 19, result.length);
    }
    catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/AlphabeticTokenizerTest.java,weka-master
"public NGramTokenizerTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/tokenizers/NGramTokenizerTest.java,weka-master
"public void testNumberOfGeneratedTokens() {
    String s;
    String[] result;

    s = ""HOWEVER, the egg only got larger and larger, and more and more human"";

    // only 1-grams
    try {
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""1"", ""-max"",
          ""1"", s });
      assertEquals(""number of tokens differ (1)"", 13, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }

    // only 2-grams
    try {
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""2"", ""-max"",
          ""2"", s });
      assertEquals(""number of tokens differ (2)"", 12, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }

    // 1 to 3-grams
    try {
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""1"", ""-max"",
          ""3"", s });
      assertEquals(""number of tokens differ (3)"", 36, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }

    // 1 to 3-grams, but sentence only has 2 grams
    try {
      s = ""cannot split"";
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""1"", ""-max"",
          ""3"", s });
      assertEquals(""number of tokens differ (4)"", 3, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/NGramTokenizerTest.java,weka-master
"public CharacterNGramTokenizerTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/core/tokenizers/CharacterNGramTokenizerTest.java,weka-master
"public void testNumberOfGeneratedTokens() {
    String s;
    String[] result;

    s = ""HOWEVER, the egg only got larger and larger, and more and more human"";

    // only 1-grams
    try {
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""1"", ""-max"",
          ""1"", s });
      assertEquals(""number of tokens differ (1)"", 68, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }

    // only 2-grams
    try {
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""2"", ""-max"",
          ""2"", s });
      assertEquals(""number of tokens differ (2)"", 67, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }

    // 1 to 3-grams
    try {
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""1"", ""-max"",
          ""3"", s });
      assertEquals(""number of tokens differ (3)"", 201, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }

    // 1 to 3-grams, but sentence only has 1 and 2 grams
    try {
      s = ""ca"";
      result =
        Tokenizer.tokenize(m_Tokenizer, new String[] { ""-min"", ""1"", ""-max"",
          ""3"", s });
      assertEquals(""number of tokens differ (4)"", 3, result.length);
    } catch (Exception e) {
      fail(""Error tokenizing string '"" + s + ""'!"");
    }
  }",./weka/src/test/java/weka/core/tokenizers/CharacterNGramTokenizerTest.java,weka-master
"public FPGrowthTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/associations/FPGrowthTest.java,weka-master
"public AbstractAssociatorTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"protected CheckAssociator getTester() {
    CheckAssociator	result;
    
    result = new CheckAssociator();
    result.setSilent(true);
    result.setAssociator(m_Associator);
    result.setNumInstances(20);
    result.setDebug(DEBUG);
    result.setPostProcessor(getPostProcessor());
    
    return result;
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = new CheckOptionHandler();
    if (getAssociator() instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) getAssociator());
    else
      result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;
    
    result = new CheckGOE();
    result.setObject(getAssociator());
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testAttributes() {
    // nominal
    checkAttributes(true,  false, false, false, false, true);
    // numeric
    checkAttributes(false, true,  false, false, false, true);
    // string
    checkAttributes(false, false, true,  false, false, true);
    // date
    checkAttributes(false, false, false, true,  false, true);
    // relational
    if (!m_multiInstanceHandler)
      checkAttributes(false, false, false, false, true,  true);
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testSerialVersionUID() {
    boolean[]     result;

    result = m_Tester.declaresSerialVersionUID();

    if (!result[0])
      fail(""Doesn't declare serialVersionUID!"");
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testInstanceWeights() {
    boolean[]     result;
    int           i;
    int           type;
    
    if (m_weightedInstancesHandler) {
      for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE + 1; i++) {
        // does the Associator support this type of class at all?
        if (!canPredict(i))
          continue;

        if (i == LAST_CLASSTYPE + 1)
          type = CheckAssociator.NO_CLASS;
        else
          type = i;
        
        result = m_Tester.instanceWeights(
            m_NominalPredictors[i], 
            m_NumericPredictors[i], 
            m_StringPredictors[i], 
            m_DatePredictors[i], 
            m_RelationalPredictors[i], 
            m_multiInstanceHandler, 
            type);

        if (!result[0])
          System.err.println(""Error handling instance weights ("" + getClassTypeString(i) 
              + "" class)!"");
      }
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testNClasses() {
    boolean[]     result;

    if (!canPredict(Attribute.NOMINAL))
      return;

    result = m_Tester.canHandleNClasses(
        m_NominalPredictors[Attribute.NOMINAL],
        m_NumericPredictors[Attribute.NOMINAL],
        m_StringPredictors[Attribute.NOMINAL],
        m_DatePredictors[Attribute.NOMINAL],
        m_RelationalPredictors[Attribute.NOMINAL],
        m_multiInstanceHandler,
        m_NClasses);

    if (!result[0] && !result[1])
      fail(""Error handling "" + m_NClasses + "" classes!"");
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testClassAsNthAttribute() {
    int           i;
    
    // multi-Instance data has fixed format!
    if (m_multiInstanceHandler)
      return;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Associator support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // first attribute
      checkClassAsNthAttribute(i, 0);

      // second attribute
      checkClassAsNthAttribute(i, 1);
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testZeroTraining() {
    boolean[]     result;
    int           i;
    int           type;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE + 1; i++) {
      // does the Associator support this type of class at all?
      if (!canPredict(i))
        continue;
      
      if (i == LAST_CLASSTYPE + 1)
	type = CheckAssociator.NO_CLASS;
      else
	type = i;

      result = m_Tester.canHandleZeroTraining(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          type);

      if (!result[0] && !result[1])
        fail(""Error handling zero training instances ("" + getClassTypeString(i) 
            + "" class)!"");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testMissingPredictors() {
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE + 1; i++) {
      // does the Associator support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // 20% missing
      checkMissingPredictors(i, 20, true);

      // 100% missing
      if (m_handleMissingPredictors[i])
        checkMissingPredictors(i, 100, true);
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testMissingClass() {
    int           i;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE; i++) {
      // does the Associator support this type of class at all?
      if (!canPredict(i))
        continue;
      
      // 20% missing
      checkMissingClass(i, 20, true);

      // 100% missing
      if (m_handleMissingClass[i])
        checkMissingClass(i, 100, true);
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testBuildInitialization() {
    boolean[]     result;
    int           i;
    int           type;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE + 1; i++) {
      // does the Associator support this type of class at all?
      if (!canPredict(i))
        continue;
      
      if (i == LAST_CLASSTYPE + 1)
	type = CheckAssociator.NO_CLASS;
      else
	type = i;

      result = m_Tester.correctBuildInitialisation(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          type);

      if (!result[0] && !result[1])
        fail(""Incorrect build initialization ("" + getClassTypeString(i) 
            + "" class)!"");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testDatasetIntegrity() {
    boolean[]     result;
    int           i;
    int           type;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE + 1; i++) {
      // does the Associator support this type of class at all?
      if (!canPredict(i))
        continue;
      
      if (i == LAST_CLASSTYPE + 1)
	type = CheckAssociator.NO_CLASS;
      else
	type = i;

      result = m_Tester.datasetIntegrity(
          m_NominalPredictors[i], 
          m_NumericPredictors[i], 
          m_StringPredictors[i], 
          m_DatePredictors[i], 
          m_RelationalPredictors[i], 
          m_multiInstanceHandler, 
          type,
          m_handleMissingPredictors[i],
          m_handleMissingClass[i]);

      if (!result[0] && !result[1])
        fail(""Training set is altered during training ("" 
            + getClassTypeString(i) + "" class)!"");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testRegression() throws Exception {
    int		i;
    boolean	succeeded;
    Regression 	reg;
    Instances   train;
    int		type;
    
    // don't bother if not working correctly
    if (m_Tester.hasClasspathProblems())
      return;
    
    reg = new Regression(this.getClass());
    succeeded = false;
    train = null;
    
    for (i = FIRST_CLASSTYPE; i <= LAST_CLASSTYPE + 1; i++) {
      // does the Associator support this type of class at all?
      if (!canPredict(i))
        continue;
        
      if (i == LAST_CLASSTYPE + 1)
	type = CheckAssociator.NO_CLASS;
      else
	type = i;

      train = m_Tester.makeTestDataset(
          42, m_Tester.getNumInstances(), 
  	  m_NominalPredictors[i] ? 2 : 0,
  	  m_NumericPredictors[i] ? 1 : 0, 
          m_StringPredictors[i] ? 1 : 0,
          m_DatePredictors[i] ? 1 : 0,
          m_RelationalPredictors[i] ? 1 : 0,
          2, 
          type,
          m_multiInstanceHandler);
  
      try {
        m_RegressionResults[i] = useAssociator(train);
        succeeded = true;
        reg.println(m_RegressionResults[i]);
      }
      catch (Exception e) {
	String msg = e.getMessage().toLowerCase();
	if (msg.indexOf(""not in classpath"") > -1)
	  return;

	m_RegressionResults[i] = null;
      }
    }
    
    if (!succeeded) {
      fail(""Problem during regression testing: no successful predictions for any class type"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating.""); 
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } 
    catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions())
	fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testDefaultOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkDefaultOptions())
	fail(""Default options were not processed correctly."");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions())
	fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions())
	fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo())
      fail(""No globalInfo method"");
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips())
      fail(""Tool tips inconsistent"");
  }",./weka/src/test/java/weka/associations/AbstractAssociatorTest.java,weka-master
"public FilteredAssociatorTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/associations/FilteredAssociatorTest.java,weka-master
"public AprioriTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/associations/AprioriTest.java,weka-master
public AbstractTimeSeriesFilterTest(String name) { super(name);  },./weka/src/test/java/weka/filters/AbstractTimeSeriesFilterTest.java,weka-master
"public void testDefault() {
    testInstanceRange_X(((TimeSeriesTranslate)m_Filter).getInstanceRange());
  }",./weka/src/test/java/weka/filters/AbstractTimeSeriesFilterTest.java,weka-master
"public void testInstanceRange() {

    testInstanceRange_X(-5);
    testInstanceRange_X(-2);
    testInstanceRange_X(2);
    testInstanceRange_X(5);
  }",./weka/src/test/java/weka/filters/AbstractTimeSeriesFilterTest.java,weka-master
"public void testFillWithMissing() {

    ((TimeSeriesTranslate)m_Filter).setFillWithMissing(true);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // Check conversion looks OK
    for (int i = 0; i < result.numInstances(); i++) {
      Instance in = m_Instances.instance(i);
      Instance out = result.instance(i);
      for (int j = 0; j < result.numAttributes(); j++) {
        if ((j != 1) && (j != 2)) {
          if (in.isMissing(j)) {
            assertTrue(""Nonselected missing values should pass through"",
                   out.isMissing(j));
          } else if (result.attribute(j).isString()) {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         m_Instances.attribute(j).value((int)in.value(j)),
                         result.attribute(j).value((int)out.value(j)));
          } else {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         in.value(j),
                         out.value(j), TOLERANCE);
          }
        }
      }
    }    
  }",./weka/src/test/java/weka/filters/AbstractTimeSeriesFilterTest.java,weka-master
"private void testInstanceRange_X(int range) {
    ((TimeSeriesTranslate)m_Filter).setInstanceRange(range);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances() - Math.abs(range), result.numInstances());
    // Check conversion looks OK
    for (int i = 0; i < result.numInstances(); i++) {
      Instance in = m_Instances.instance(i - ((range > 0) ? 0 : range));
      Instance out = result.instance(i);
      for (int j = 0; j < result.numAttributes(); j++) {
        if ((j != 1) && (j != 2)) {
          if (in.isMissing(j)) {
            assertTrue(""Nonselected missing values should pass through"",
                   out.isMissing(j));
          } else if (result.attribute(j).isString()) {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         m_Instances.attribute(j).value((int)in.value(j)),
                         result.attribute(j).value((int)out.value(j)));
          } else {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         in.value(j),
                         out.value(j), TOLERANCE);
          }
        }
      }
    }    
  }",./weka/src/test/java/weka/filters/AbstractTimeSeriesFilterTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNumeric()) {
	  ((TimeSeriesTranslate) m_FilteredClassifier.getFilter()).setAttributeIndices("""" + (i + 1));
	  ((TimeSeriesTranslate) m_FilteredClassifier.getFilter()).setFillWithMissing(true);
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/AbstractTimeSeriesFilterTest.java,weka-master
"public RenameRelationTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/RenameRelationTest.java,weka-master
"public void testTypical() {
    String originalRelationName = m_Instances.relationName();
    ((RenameRelation) m_Filter).setModificationText(""GoofyGoober"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());

    assertEquals(m_Instances.relationName(), originalRelationName);
    assertEquals(result.relationName(), ""GoofyGoober"");
  }",./weka/src/test/java/weka/filters/RenameRelationTest.java,weka-master
"public void testPrepend() {
    String originalRelationName = m_Instances.relationName();
    m_Filter = getFilter();
    ((RenameRelation) m_Filter).setModificationText(""GoofyGoober"");
    ((RenameRelation) m_Filter).setModType(RenameRelation.ModType.PREPEND);
    Instances result = useFilter();

    assertEquals(result.relationName(), ""GoofyGoober"" + originalRelationName);
  }",./weka/src/test/java/weka/filters/RenameRelationTest.java,weka-master
"public void testAppend() {
    String originalRelationName = m_Instances.relationName();
    m_Filter = getFilter();
    ((RenameRelation) m_Filter).setModificationText(""GoofyGoober"");
    ((RenameRelation) m_Filter).setModType(RenameRelation.ModType.APPEND);
    Instances result = useFilter();

    assertEquals(result.relationName(), originalRelationName + ""GoofyGoober"");
  }",./weka/src/test/java/weka/filters/RenameRelationTest.java,weka-master
"public void testRegex() {
    m_Filter = getFilter();
    ((RenameRelation) m_Filter).setModificationText(""GoofyGoober"");
    ((RenameRelation) m_Filter).setModType(RenameRelation.ModType.REGEX);
    ((RenameRelation) m_Filter).setRegexMatch(""Test"");
    Instances result = useFilter();

    assertEquals(result.relationName(), ""FilterGoofyGoober"");
  }",./weka/src/test/java/weka/filters/RenameRelationTest.java,weka-master
"public AbstractFilterTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
    result = new CheckOptionHandler();
    if (getFilter() instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) getFilter());
    else
      result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;
    
    result = new CheckGOE();
    result.setObject(getFilter());
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testSerialVersionUID() {
    if (SerializationHelper.needsUID(m_Filter.getClass()))
      fail(""Doesn't declare serialVersionUID!"");
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testBuffered() {

    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // Check the output is valid for printing by trying to write out to 
    // a stringbuffer
    StringWriter sw = new StringWriter(2000);
    sw.write(result.toString());

    // Check the input hasn't been modified
    // We just check the headers are the same and that the instance
    // count is the same.
    assertTrue(icopy.equalHeaders(m_Instances));
    assertEquals(icopy.numInstances(), m_Instances.numInstances());

    // Try repeating the filtering and check we get the same results
    Instances result2 = null;
    try {
      m_Filter.setInputFormat(icopy);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result2 = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result2);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // Again check the input hasn't been modified
    // We just check the headers are the same and that the instance
    // count is the same.
    assertTrue(icopy.equalHeaders(m_Instances));
    assertEquals(icopy.numInstances(), m_Instances.numInstances());

    // Check the same results for both runs
    assertTrue(result.equalHeaders(result2));
    assertEquals(result.numInstances(), result2.numInstances());
    
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testIncremental() {

    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    boolean headerImmediate = false;
    try {
      headerImmediate = m_Filter.setInputFormat(icopy);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    if (headerImmediate) {
      if (VERBOSE) System.err.println(""Filter makes header immediately available."");
      result = m_Filter.getOutputFormat();
    }
    // Pass all the instances to the filter
    for (int i = 0; i < icopy.numInstances(); i++) {
      if (VERBOSE) System.err.println(""Input instance to filter"");
      boolean collectNow = false;
      try {
        collectNow = m_Filter.input(icopy.instance(i));
      } catch (Exception ex) {
        ex.printStackTrace();
        fail(""Exception thrown on input(): \n"" + ex.getMessage());
      }
      if (collectNow) {
        if (VERBOSE) System.err.println(""Filter said collect immediately"");
	if (!headerImmediate) {
	  fail(""Filter didn't return true from setInputFormat() earlier!"");
	}
        if (VERBOSE) System.err.println(""Getting output instance"");
	result.add(m_Filter.output());
      }
    }
    // Say that input has finished, and print any pending output instances
    if (VERBOSE) System.err.println(""Setting end of batch"");
    boolean toCollect = false;
    try {
      toCollect = m_Filter.batchFinished();
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on batchFinished(): \n"" + ex.getMessage());
    }
    if (toCollect) {
      if (VERBOSE) System.err.println(""Filter said collect output"");
      if (!headerImmediate) {
        if (VERBOSE) System.err.println(""Getting output format"");
	result = m_Filter.getOutputFormat();
      }
      if (VERBOSE) System.err.println(""Getting output instance"");
      while (m_Filter.numPendingOutput() > 0) {
	result.add(m_Filter.output());
        if (VERBOSE) System.err.println(""Getting output instance"");
      }
    }
    
    assertNotNull(result);

    // Check the output iss valid for printing by trying to write out to 
    // a stringbuffer
    StringWriter sw = new StringWriter(2000);
    sw.write(result.toString());
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testRegression() {

    Regression reg = new Regression(this.getClass());
    Instances result = useFilter();
    reg.println(result.toString());
    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating.""); 
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }

    reg = new Regression(this.getClass());

    // Run the filter using deprecated calls to check it still works the same
    Instances icopy = new Instances(m_Instances);
    try {
      m_Filter.setInputFormat(icopy);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      for (int i = 0; i < icopy.numInstances(); i++) {
        m_Filter.input(icopy.instance(i));
      }
      m_Filter.batchFinished();
      result = m_Filter.getOutputFormat();
      weka.core.Instance processed;
      while ((processed = m_Filter.output()) != null) {
        result.add(processed);
      }
      assertNotNull(result);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }
    reg.println(result.toString());
    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating.""); 
      } else if (!diff.equals("""")) {
        fail(""Regression test failed when using deprecated methods. Difference:\n"" + diff);
      }
    } catch (java.io.IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testThroughput() {

    if (VERBOSE) {
      Instances icopy = new Instances(m_Instances);
      // Make a bigger dataset
      Instances result = null;
      for (int i = 0; i < 20000; i++) {
        icopy.add(m_Instances.instance(i%m_Instances.numInstances()));
      }
      long starttime, endtime;
      double secs, rate;


      // Time incremental usage
      starttime = System.currentTimeMillis();
      boolean headerImmediate = false;
      try {
        headerImmediate = m_Filter.setInputFormat(icopy);
        if (headerImmediate) {
          result = m_Filter.getOutputFormat();
        }
        for (int i = 0; i < icopy.numInstances(); i++) {
          boolean collectNow = false;
          collectNow = m_Filter.input(icopy.instance(i));
          if (collectNow) {
            if (!headerImmediate) {
              fail(""Filter didn't return true from setInputFormat() earlier!"");
            }
            result.add(m_Filter.output());
          }
        }
        // Say that input has finished, and print any pending output instances
        boolean toCollect = false;
        toCollect = m_Filter.batchFinished();
        if (toCollect) {
          if (!headerImmediate) {
            result = m_Filter.getOutputFormat();
          }
          while (m_Filter.numPendingOutput() > 0) {
            result.add(m_Filter.output());
          }
        }
      } catch (Exception ex) {
        ex.printStackTrace();
        fail(""Exception thrown during incremental filtering: \n"" + ex.getMessage());
      }
      endtime = System.currentTimeMillis();
      secs = (double)(endtime - starttime) / 1000;
      rate = (double)icopy.numInstances() / secs;
      System.err.println(""\n"" + m_Filter.getClass().getName() 
                         + "" incrementally processed "" 
                         + rate + "" instances per sec""); 
      
      // Time batch usage
      starttime = System.currentTimeMillis();
      try {
        m_Filter.setInputFormat(icopy);
        result = Filter.useFilter(icopy, m_Filter);
        assertNotNull(result);
      } catch (Exception ex) {
        ex.printStackTrace();
        fail(""Exception thrown during batch filtering: \n"" + ex.getMessage());
      }
      endtime = System.currentTimeMillis();
      secs = (double)(endtime - starttime) / 1000;
      rate = (double)icopy.numInstances() / secs;
      System.err.println(""\n"" + m_Filter.getClass().getName() 
                         + "" batch processed "" 
                         + rate + "" instances per sec""); 


    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions())
	fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testDefaultOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkDefaultOptions())
	fail(""Default options were not processed correctly."");
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions())
	fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions())
	fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions())
	fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testFilteredClassifier() {
    Instances		data;
    int			i;
    
    // skip this test if a subclass has set the
    // filtered classifier to null
    if (m_FilteredClassifier == null) {
      return;
    }
    
    try {
      // generate data
      data = getFilteredClassifierData();
      
      // build classifier
      m_FilteredClassifier.buildClassifier(data);

      // test classifier
      for (i = 0; i < data.numInstances(); i++) {
	m_FilteredClassifier.classifyInstance(data.instance(i));
      }
    }
    catch (Exception e) {
      fail(""Problem with FilteredClassifier: "" + e.toString());
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testBatchFiltering() {
    Instances result = null;
    Instances icopy = new Instances(m_Instances);
    
    // setup filter
    try {
      if (m_Filter.setInputFormat(icopy)) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (setup)"", result);
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex);
    }

    // first batch
    try {
      for (int i = 0; i < icopy.numInstances(); i++) {
	if (m_Filter.input(icopy.instance(i))) {
	  Instance out = m_Filter.output();
	  assertNotNull(""Instance not made available immediately (1. batch)"", out);
	  result.add(out);
	}
      }
      m_Filter.batchFinished();

      if (result == null) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (1. batch)"", result);
	assertTrue(""Pending output instances (1. batch)"", m_Filter.numPendingOutput() > 0);
      }

      while (m_Filter.numPendingOutput() > 0)
	result.add(m_Filter.output());
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown during 1. batch: \n"" + ex);
    }

    // second batch
    try {
      result = null;
      if (m_Filter.isOutputFormatDefined())
	result = m_Filter.getOutputFormat();
      
      for (int i = 0; i < icopy.numInstances(); i++) {
	if (m_Filter.input(icopy.instance(i))) {
	  if (result == null) {
	    fail(""Filter didn't return true from isOutputFormatDefined() (2. batch)"");
	  }
	  else {
	    Instance out = m_Filter.output();
	    assertNotNull(""Instance not made available immediately (2. batch)"", out);
	    result.add(out);
	  }
	}
      }
      m_Filter.batchFinished();
      
      if (result == null) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (2. batch)"", result);
	assertTrue(""Pending output instances (2. batch)"", m_Filter.numPendingOutput() > 0);
      }

      while (m_Filter.numPendingOutput() > 0)
	result.add(m_Filter.output());
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown during 2. batch: \n"" + ex);
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testBatchFilteringSmaller() {
    Instances result = null;
    Instances icopy = new Instances(m_Instances);
    
    // setup filter
    try {
      if (m_Filter.setInputFormat(icopy)) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (setup)"", result);
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex);
    }

    // first batch
    try {
      for (int i = 0; i < icopy.numInstances(); i++) {
	if (m_Filter.input(icopy.instance(i))) {
	  Instance out = m_Filter.output();
	  assertNotNull(""Instance not made available immediately (1. batch)"", out);
	  result.add(out);
	}
      }
      m_Filter.batchFinished();

      if (result == null) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (1. batch)"", result);
	assertTrue(""Pending output instances (1. batch)"", m_Filter.numPendingOutput() > 0);
      }

      while (m_Filter.numPendingOutput() > 0)
	result.add(m_Filter.output());
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown during 1. batch: \n"" + ex);
    }

    // second batch
    try {
      result = null;
      if (m_Filter.isOutputFormatDefined())
	result = m_Filter.getOutputFormat();
      
      // delete some instances
      int num = (int) ((double) icopy.numInstances() * 0.3);
      for (int i = 0; i < num; i++)
	icopy.delete(0);
      
      for (int i = 0; i < icopy.numInstances(); i++) {
	if (m_Filter.input(icopy.instance(i))) {
	  if (result == null) {
	    fail(""Filter didn't return true from isOutputFormatDefined() (2. batch)"");
	  }
	  else {
	    Instance out = m_Filter.output();
	    assertNotNull(""Instance not made available immediately (2. batch)"", out);
	    result.add(out);
	  }
	}
      }
      m_Filter.batchFinished();
      
      if (result == null) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (2. batch)"", result);
	assertTrue(""Pending output instances (2. batch)"", m_Filter.numPendingOutput() > 0);
      }

      while (m_Filter.numPendingOutput() > 0)
	result.add(m_Filter.output());
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown during 2. batch: \n"" + ex);
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testBatchFilteringLarger() {
    Instances result = null;
    Instances icopy = new Instances(m_Instances);
    
    // setup filter
    try {
      if (m_Filter.setInputFormat(icopy)) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (setup)"", result);
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex);
    }

    // first batch
    try {
      for (int i = 0; i < icopy.numInstances(); i++) {
	if (m_Filter.input(icopy.instance(i))) {
	  Instance out = m_Filter.output();
	  assertNotNull(""Instance not made available immediately (1. batch)"", out);
	  result.add(out);
	}
      }
      m_Filter.batchFinished();

      if (result == null) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (1. batch)"", result);
	assertTrue(""Pending output instances (1. batch)"", m_Filter.numPendingOutput() > 0);
      }

      while (m_Filter.numPendingOutput() > 0)
	result.add(m_Filter.output());
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown during 1. batch: \n"" + ex);
    }

    // second batch
    try {
      result = null;
      if (m_Filter.isOutputFormatDefined())
	result = m_Filter.getOutputFormat();
      
      // add some instances
      int num = (int) ((double) icopy.numInstances() * 0.3);
      for (int i = 0; i < num; i++)
	icopy.add(icopy.instance(i));
      
      for (int i = 0; i < icopy.numInstances(); i++) {
	if (m_Filter.input(icopy.instance(i))) {
	  if (result == null) {
	    fail(""Filter didn't return true from isOutputFormatDefined() (2. batch)"");
	  }
	  else {
	    Instance out = m_Filter.output();
	    assertNotNull(""Instance not made available immediately (2. batch)"", out);
	    result.add(out);
	  }
	}
      }
      m_Filter.batchFinished();
      
      if (result == null) {
	result = m_Filter.getOutputFormat();
	assertNotNull(""Output format defined (2. batch)"", result);
	assertTrue(""Pending output instances (2. batch)"", m_Filter.numPendingOutput() > 0);
      }

      while (m_Filter.numPendingOutput() > 0)
	result.add(m_Filter.output());
    }
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown during 2. batch: \n"" + ex);
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo())
      fail(""No globalInfo method"");
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips())
      fail(""Tool tips inconsistent"");
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
"public void testChangesInputData() {
    Instances 	result;
    String 	msg;
    Instances 	icopy;

    icopy = new Instances(m_Instances);

    // initializing filter
    try {
      m_Filter.setInputFormat(m_Instances);
    }
    catch (Exception e) {
      fail(""Failed to use setInputFormat: "" + e);
    }

    // 1st filtering
    try {
      result = Filter.useFilter(m_Instances, m_Filter);
      msg = compareDatasets(m_Instances, icopy);
      assertNotNull(""Filtered data is null"", result);
      assertNull(""1st filtering changed input data: "" + msg, msg);
    }
    catch (Exception e) {
      fail(""Failed to apply filter for 1st time: "" + e);
    }

    // 1st filtering
    try {
      result = Filter.useFilter(m_Instances, m_Filter);
      msg = compareDatasets(m_Instances, icopy);
      assertNotNull(""Filtered data is null"", result);
      assertNull(""2nd filtering changed input data: "" + msg, msg);
    }
    catch (Exception e) {
      fail(""Failed to apply filter for 2nd time: "" + e);
    }
  }",./weka/src/test/java/weka/filters/AbstractFilterTest.java,weka-master
public SpreadSubsampleTest(String name) { super(name);  },./weka/src/test/java/weka/filters/supervised/instance/SpreadSubsampleTest.java,weka-master
"public void testDistributionSpread() throws Exception {
    
    testDistributionSpread_X(1.0);
    testDistributionSpread_X(2.0);
    testDistributionSpread_X(3.0);
  }",./weka/src/test/java/weka/filters/supervised/instance/SpreadSubsampleTest.java,weka-master
"public void testAdjustWeights() {

    ((SpreadSubsample)m_Filter).setAdjustWeights(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    double origWeight = 0;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      origWeight += m_Instances.instance(i).weight();
    }
    double outWeight = 0;
    for (int i = 0; i < result.numInstances(); i++) {
      outWeight += result.instance(i).weight();
    }
    assertEquals(origWeight, outWeight, TOLERANCE);
  }",./weka/src/test/java/weka/filters/supervised/instance/SpreadSubsampleTest.java,weka-master
"private void testDistributionSpread_X(double factor) throws Exception {
    AttributeStats origs = m_Instances.attributeStats(1);
    assertNotNull(origs.nominalCounts);
    
    ((SpreadSubsample)m_Filter).setDistributionSpread(factor);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    AttributeStats outs = result.attributeStats(1);

    // Check distributions are pretty similar
    assertNotNull(outs.nominalCounts);
    assertEquals(origs.nominalCounts.length, outs.nominalCounts.length);
    int min = outs.nominalCounts[0];
    int max = outs.nominalCounts[0];
    for (int i = 1; i < outs.nominalCounts.length; i++) {
      if (outs.nominalCounts[i] < min) {
        min = outs.nominalCounts[i];
      }
      if (outs.nominalCounts[i] > max) {
        max = outs.nominalCounts[i];
      }
    }
    assertTrue(max / factor <= min);
  }",./weka/src/test/java/weka/filters/supervised/instance/SpreadSubsampleTest.java,weka-master
public ResampleTest(String name) { super(name);  },./weka/src/test/java/weka/filters/supervised/instance/ResampleTest.java,weka-master
"public void testSampleSizePercent() {
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 50% of input"",
                 m_Instances.numInstances() / 2,  result.numInstances());

    ((Resample)m_Filter).setSampleSizePercent(200);
    result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 200% of input"",
                 m_Instances.numInstances() * 2,  result.numInstances());
  }",./weka/src/test/java/weka/filters/supervised/instance/ResampleTest.java,weka-master
"public void testSampleSizePercentNoReplacement() {
    ((Resample) m_Filter).setSampleSizePercent(20);
    ((Resample) m_Filter).setNoReplacement(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 3"",
                 3,  result.numInstances());
  }",./weka/src/test/java/weka/filters/supervised/instance/ResampleTest.java,weka-master
"public void testSampleSizePercentNoReplacementInverted() {
    ((Resample) m_Filter).setSampleSizePercent(20);
    ((Resample) m_Filter).setNoReplacement(true);
    ((Resample) m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 18"",
                 18,  result.numInstances());
  }",./weka/src/test/java/weka/filters/supervised/instance/ResampleTest.java,weka-master
"public void testNoBias() throws Exception {
    m_Instances.setClassIndex(1);
    AttributeStats origs = m_Instances.attributeStats(1);
    assertNotNull(origs.nominalCounts);

    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    AttributeStats outs = result.attributeStats(1);

    // Check distributions are pretty similar
    assertNotNull(outs.nominalCounts);
    assertEquals(origs.nominalCounts.length, outs.nominalCounts.length);
    for (int i = 0; i < origs.nominalCounts.length; i++) {
      int est = origs.nominalCounts[i] / 2 - 1;
      assertTrue(""Counts for value:"" + i 
             + "" orig:"" + origs.nominalCounts[i] 
             + "" out50%:"" + outs.nominalCounts[i], 
             (est <= outs.nominalCounts[i]) &&
             (outs.nominalCounts[i] <= (est + 3)));
    }
  }",./weka/src/test/java/weka/filters/supervised/instance/ResampleTest.java,weka-master
"public void testBiasToUniform() throws Exception {
    m_Instances.setClassIndex(1);
    AttributeStats origs = m_Instances.attributeStats(1);
    assertNotNull(origs.nominalCounts);
    
    ((Resample)m_Filter).setBiasToUniformClass(1.0);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    AttributeStats outs = result.attributeStats(1);

    // Check distributions are pretty similar
    assertNotNull(outs.nominalCounts);
    assertEquals(origs.nominalCounts.length, outs.nominalCounts.length);
    int est = (origs.totalCount - origs.missingCount) / origs.distinctCount;
    est = est / 2 - 1;
    for (int i = 0; i < origs.nominalCounts.length; i++) {
      assertTrue(""Counts for value:"" + i 
             + "" orig:"" + origs.nominalCounts[i] 
             + "" out50%:"" + outs.nominalCounts[i]
             + "" ~wanted:"" + est,
             (est <= outs.nominalCounts[i]) &&
             (outs.nominalCounts[i] <= (est + 3)));
    }
  }",./weka/src/test/java/weka/filters/supervised/instance/ResampleTest.java,weka-master
public StratifiedRemoveFoldsTest(String name) { super(name);  },./weka/src/test/java/weka/filters/supervised/instance/StratifiedRemoveFoldsTest.java,weka-master
"public void testAllFolds() {
    
    int totInstances = 0;
    for (int i = 0; i < 10; i++) {
      ((StratifiedRemoveFolds)m_Filter).setFold(i + 1);
      Instances result = useFilter();
      assertEquals(m_Instances.numAttributes(), result.numAttributes());
      totInstances += result.numInstances();
    }
    assertEquals(""Expecting output number of instances to match"",
                 m_Instances.numInstances(),  totInstances);
  }",./weka/src/test/java/weka/filters/supervised/instance/StratifiedRemoveFoldsTest.java,weka-master
public ClassBalancerTest(String name) { super(name);  },./weka/src/test/java/weka/filters/supervised/instance/ClassBalancerTest.java,weka-master
"public ClassConditionalProbabilitiesTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/supervised/attribute/ClassConditionalProbabilitiesTest.java,weka-master
public AttributeSelectionTest(String name) { super(name);  },./weka/src/test/java/weka/filters/supervised/attribute/AttributeSelectionTest.java,weka-master
"public void testPrincipalComponent() {
    m_Filter = getFilter(new weka.attributeSelection.PrincipalComponents(), 
                         new weka.attributeSelection.Ranker());
    Instances result = useFilter();
    assertTrue(m_Instances.numAttributes() != result.numAttributes());
  }",./weka/src/test/java/weka/filters/supervised/attribute/AttributeSelectionTest.java,weka-master
"public PartitionMembershipTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/supervised/attribute/PartitionMembershipTest.java,weka-master
"public void testNominal() {
    m_Filter = getFilter();
    m_Instances.setClassIndex(0);
    Instances result = useFilter();
    // classes must be still the same
    assertEquals(m_Instances.numClasses(), result.numClasses());
    // at least one attribute besides class
    assertTrue(result.numAttributes() >= 1 + 1);
  }",./weka/src/test/java/weka/filters/supervised/attribute/PartitionMembershipTest.java,weka-master
"public void testNumeric() {
    m_Filter = getFilter();
    m_Instances.setClassIndex(2);
    Instances result = useFilter();
    // at least one attribute besides class
    assertTrue(result.numAttributes() >= 1 + 1);
  }",./weka/src/test/java/weka/filters/supervised/attribute/PartitionMembershipTest.java,weka-master
"public AddClassificationTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"protected void performTest(boolean num, boolean cl, boolean dist, boolean error, boolean remove) {
    Instances	icopy;
    int		numAtts;
    
    // setup dataset
    if (num)
      m_Instances.setClassIndex(1);
    else
      m_Instances.setClassIndex(0);
    icopy = new Instances(m_Instances);

    // setup filter
    m_Filter = getFilter();
    if (num)
      ((AddClassification) m_Filter).setClassifier(new weka.classifiers.trees.M5P());
    else
      ((AddClassification) m_Filter).setClassifier(new weka.classifiers.trees.J48());
    
    ((AddClassification) m_Filter).setOutputClassification(cl);
    ((AddClassification) m_Filter).setOutputDistribution(dist);
    ((AddClassification) m_Filter).setOutputErrorFlag(error);
    ((AddClassification) m_Filter).setRemoveOldClass(remove);
    
    numAtts = icopy.numAttributes();
    if (cl)
      numAtts++;
    if (dist)
      numAtts += icopy.numClasses();
    if (error)
      numAtts++;
    if (remove)
      numAtts--;
    
    Instances result = useFilter();
    assertEquals(result.numAttributes(), numAtts);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testDefault() {
    Instances icopy = new Instances(m_Instances);
    
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(result.numAttributes(), icopy.numAttributes());
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testNoneNominal() {
    performTest(false, false, false, false, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testErrorFlagNominal() {
    performTest(false, false, false, true, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testClassificationNominal() {
    performTest(false, true, false, false, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testDistributionNominal() {
    performTest(false, false, true, false, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testNoneNumeric() {
    performTest(true, false, false, false, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testErrorFlagNumeric() {
    performTest(true, false, false, true, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testClassificationNumeric() {
    performTest(true, true, false, false, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testDistributionNumeric() {
    performTest(true, false, true, false, false);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testClassificationRemoveNominal() {
    performTest(false, true, false, false, true);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testClassificationRemoveNumeric() {
    performTest(true, true, false, false, true);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testClassificationOnlyRemoveNominal() {
    performTest(false, false, false, false, true);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
"public void testClassificationOnlyRemoveNumeric() {
    performTest(true, false, false, false, true);
  }",./weka/src/test/java/weka/filters/supervised/attribute/AddClassificationTest.java,weka-master
public DiscretizeTest(String name) { super(name);  },./weka/src/test/java/weka/filters/supervised/attribute/DiscretizeTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter(""1,2"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    // None of the attributes should have changed, since 1,2 aren't numeric
    for (int i = 0; i < result.numAttributes(); i++) {
      assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
      assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
    }
  }",./weka/src/test/java/weka/filters/supervised/attribute/DiscretizeTest.java,weka-master
"public void testTypical2() {
    m_Filter = getFilter(""3-4"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    for (int i = 0; i < result.numAttributes(); i++) {
      if (i != 2) {
        assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
        assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
      } else {
        assertEquals(Attribute.NOMINAL, result.attribute(i).type());
        assertEquals(1, result.attribute(i).numValues());
      }
    }
  }",./weka/src/test/java/weka/filters/supervised/attribute/DiscretizeTest.java,weka-master
"public void testInverted() {
    m_Filter = getFilter(""1,2"");
    ((Discretize)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    for (int i = 0; i < result.numAttributes(); i++) {
      if ((i < 2) || !m_Instances.attribute(i).isNumeric()) {
        assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
        assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
      } else {
        assertEquals(Attribute.NOMINAL, result.attribute(i).type());
        assertEquals(1, result.attribute(i).numValues());
      }
    }
  }",./weka/src/test/java/weka/filters/supervised/attribute/DiscretizeTest.java,weka-master
"public void testNonInverted2() {
    m_Filter = getFilter(""first-3"");
    ((Discretize)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    for (int i = 0; i < result.numAttributes(); i++) {
      if ((i < 3) || !m_Instances.attribute(i).isNumeric()) {
        assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
        assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
      } else {
        assertEquals(Attribute.NOMINAL, result.attribute(i).type());
        assertEquals(1, result.attribute(i).numValues());
      }
    }
  }",./weka/src/test/java/weka/filters/supervised/attribute/DiscretizeTest.java,weka-master
"public void testBetterEncoding() {
    m_Filter = getFilter(""3"");
    ((Discretize)m_Filter).setUseBetterEncoding(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(Attribute.NOMINAL, result.attribute(2).type());
  }",./weka/src/test/java/weka/filters/supervised/attribute/DiscretizeTest.java,weka-master
"public void testUseKononenko() {
    m_Filter = getFilter(""3"");
    ((Discretize)m_Filter).setUseKononenko(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(Attribute.NOMINAL, result.attribute(2).type());
  }",./weka/src/test/java/weka/filters/supervised/attribute/DiscretizeTest.java,weka-master
"public MergeNominalValuesTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/supervised/attribute/MergeNominalValuesTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());

    Attribute mergedAtt = result.attribute(4);
    // All values should be merged for this attribute
    assertTrue(""Attribute 5 has all values merged in result"", mergedAtt
      .value(0).equals(""a_or_b_or_c_or_d""));
  }",./weka/src/test/java/weka/filters/supervised/attribute/MergeNominalValuesTest.java,weka-master
"public void testDifferentRange() {
    // ((MergeNominalValues)m_Filter).setMinimumFrequency(5);
    ((MergeNominalValues) m_Filter).setAttributeIndices(""1,3"");
    ((MergeNominalValues) m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/supervised/attribute/MergeNominalValuesTest.java,weka-master
"public void testAttributeWithMissing() {
    ((MergeNominalValues) m_Filter).setAttributeIndices(""5"");
    // ((MergeNominalValues)m_Filter).setMinimumFrequency(100);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).isMissing(4)) {
        assertTrue(""Missing in input should give missing in result"", result
          .instance(i).isMissing(4));
      }
    }
  }",./weka/src/test/java/weka/filters/supervised/attribute/MergeNominalValuesTest.java,weka-master
"@Override
  public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
        if (data.classIndex() == i) {
          continue;
        }
        if (data.attribute(i).isNominal()) {
          ((MergeNominalValues) m_FilteredClassifier.getFilter())
            .setAttributeIndices("""" + (i + 1));
          break;
        }
      }
    } catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }

    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/supervised/attribute/MergeNominalValuesTest.java,weka-master
public NominalToBinaryTest(String name) { super(name);  },./weka/src/test/java/weka/filters/supervised/attribute/NominalToBinaryTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes changes
    assertEquals(m_Instances.numAttributes() + 3, result.numAttributes());
    // Number of instances shouldn't change
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Eibe can enhance this to check the binarizing is correct.
  }",./weka/src/test/java/weka/filters/supervised/attribute/NominalToBinaryTest.java,weka-master
"public ClassOrderTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/supervised/attribute/ClassOrderTest.java,weka-master
"protected void performTests(Instances result) {
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // None of the attributes should have changed
    for (int i = 0; i < result.numAttributes(); i++) {
      assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
      assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
    }
    // did the order change?
    boolean orderEqual = true;
    for (int i = 0; i < result.numClasses(); i++) {
      if (!m_Instances.classAttribute().value(i).equals(
            result.classAttribute().value(i))) {
        orderEqual = false;
        break;
      }
    }
    if (orderEqual)
      fail(""Order wasn't changed!"");
  }",./weka/src/test/java/weka/filters/supervised/attribute/ClassOrderTest.java,weka-master
"public void testRandom() {
    m_Filter = getFilter();
    ((ClassOrder) m_Filter).setClassOrder(ClassOrder.RANDOM);
    Instances result = useFilter();
    performTests(result);
  }",./weka/src/test/java/weka/filters/supervised/attribute/ClassOrderTest.java,weka-master
"public void testFreqAscend() {
    m_Filter = getFilter();
    ((ClassOrder) m_Filter).setClassOrder(ClassOrder.FREQ_ASCEND);
    Instances result = useFilter();
    performTests(result);
  }",./weka/src/test/java/weka/filters/supervised/attribute/ClassOrderTest.java,weka-master
"public void testFreqDescend() {
    m_Filter = getFilter();
    ((ClassOrder) m_Filter).setClassOrder(ClassOrder.FREQ_DESCEND);
    Instances result = useFilter();
    performTests(result);
  }",./weka/src/test/java/weka/filters/supervised/attribute/ClassOrderTest.java,weka-master
"public MultiFilterTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/MultiFilterTest.java,weka-master
"public void testDefault() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
  }",./weka/src/test/java/weka/filters/MultiFilterTest.java,weka-master
"public void testConfigured() {
    m_Filter = getConfiguredFilter();
    Instances result = useFilter();
    // Number of attributes should be 2 more
    assertEquals(m_Instances.numAttributes() + 2, result.numAttributes());
    // Number of instances shouldn't change
    assertEquals(m_Instances.numInstances(),  result.numInstances());
  }",./weka/src/test/java/weka/filters/MultiFilterTest.java,weka-master
"public void testConfiguredVariant() {
    m_Filter = getConfiguredFilterVariant();
    Instances result = useFilter();
    // Number of atytributes + instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
  }",./weka/src/test/java/weka/filters/MultiFilterTest.java,weka-master
public RemoveWithValuesTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/instance/RemoveWithValuesTest.java,weka-master
"public void testString() {
    Instances icopy = new Instances(m_Instances);
    try {
      ((RemoveWithValues)m_Filter).setAttributeIndex(""1"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception selecting on a STRING attribute!"");
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveWithValuesTest.java,weka-master
"public void testNominal() {
    ((RemoveWithValues)m_Filter).setAttributeIndex(""2"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Default nominal selection matches all values"",
                 m_Instances.numInstances(),  result.numInstances());

    try {
      ((RemoveWithValues)m_Filter).setNominalIndices(""1-2"");
    } catch (Exception ex) {
      fail(""Shouldn't ever get here unless Range chamges incompatibly"");
    }
    result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertTrue(m_Instances.numInstances() > result.numInstances());

    try {
      ((RemoveWithValues)m_Filter).setNominalIndices(""3-last"");
    } catch (Exception ex) {
      fail(""Shouldn't ever get here unless Range chamges incompatibly"");
    }
    Instances result2 = useFilter();
    assertEquals(m_Instances.numAttributes(), result2.numAttributes());
    assertTrue(m_Instances.numInstances() > result2.numInstances());
    assertEquals(m_Instances.numInstances(), result.numInstances() + result2.numInstances());

    ((RemoveWithValues)m_Filter).setInvertSelection(false);
    result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances() + result2.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveWithValuesTest.java,weka-master
"public void testNumeric() {
    ((RemoveWithValues)m_Filter).setAttributeIndex(""3"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Default split point matches values less than 0"",
                 0,  result.numInstances());

    ((RemoveWithValues)m_Filter).setSplitPoint(3);
    result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertTrue(m_Instances.numInstances() > result.numInstances());

    // Test inversion is working.
    ((RemoveWithValues)m_Filter).setInvertSelection(false);
    Instances result2 = useFilter();
    assertEquals(m_Instances.numAttributes(), result2.numAttributes());
    assertTrue(m_Instances.numInstances() > result2.numInstances());
    assertEquals(m_Instances.numInstances(), result.numInstances() + result2.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveWithValuesTest.java,weka-master
"public void testMatchMissingValues() {
    ((RemoveWithValues)m_Filter).setAttributeIndex(""5"");
    ((RemoveWithValues)m_Filter).setInvertSelection(false);
    ((RemoveWithValues)m_Filter).setMatchMissingValues(false);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertTrue(result.numInstances() > 0);
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Should select only instances with missing values"",
             result.instance(i).isMissing(4));
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveWithValuesTest.java,weka-master
"public void testFilteredClassifier() {
    // nothing
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveWithValuesTest.java,weka-master
public RemoveFoldsTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/instance/RemoveFoldsTest.java,weka-master
"public void testAllFolds() {
    
    int totInstances = 0;
    for (int i = 0; i < 10; i++) {
      ((RemoveFolds)m_Filter).setFold(i + 1);
      Instances result = useFilter();
      assertEquals(m_Instances.numAttributes(), result.numAttributes());
      totInstances += result.numInstances();
    }
    assertEquals(""Expecting output number of instances to match"",
                 m_Instances.numInstances(),  totInstances);
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveFoldsTest.java,weka-master
public NonSparseToSparseTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/instance/NonSparseToSparseTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check conversion is OK
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Instance should be an instanceof SparseInstance"",
             result.instance(i) instanceof SparseInstance);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/NonSparseToSparseTest.java,weka-master
"public ReservoirSampleTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/instance/ReservoirSampleTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    
    // instances should be indentical as default settings ask for
    // a larger sample than there is number of instances in the test
    // dataset
    boolean equal = true;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      if (m_Comparator.compare(
            m_Instances.instance(i), result.instance(i)) != 0) {
        equal = false;
        break;
      }
    }
    if (!equal) {
      fail(""Result should be equal"");
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/ReservoirSampleTest.java,weka-master
"public void testSubSample() {
    m_Filter = getFilter();
    ((ReservoirSample)m_Filter).setSampleSize(10);
    
    Instances result = useFilter();
    assertEquals(result.numInstances(), 10);

    // instances should be different from the first 10 instances in
    // the original data

    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Comparator.compare(
            m_Instances.instance(i), result.instance(i)) != 0) {
        equal = false;
        break;
      }
    }

    if (equal) {
      fail(""Result should be different than the first 10 instances"");
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/ReservoirSampleTest.java,weka-master
"public void testHeaderOnlyInput() {
    m_Filter = getFilter();
    m_Instances = new Instances(m_Instances, 0);
    Instances result = useFilter();
    assertEquals(result.numInstances(), m_Instances.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/ReservoirSampleTest.java,weka-master
"public RemoveDuplicatesTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveDuplicatesTest.java,weka-master
"public SubsetByExpressionTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testIsmissing() {
    m_Filter = getFilter(""ismissing(ATT3)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(3, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testNotIsmissing() {
    m_Filter = getFilter(""not ismissing(ATT3)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances() - 3, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testClassIs() {
    m_Filter = getFilter(""CLASS is 'g'"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(3, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testClassRegexp() {
    m_Filter = getFilter(""CLASS regexp '(r|g)'"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(15, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testClassIs2() {
    m_Filter = getFilter(""(CLASS is 'r') or (CLASS is 'g') or (CLASS is 'b')"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testAttIs() {
    m_Filter = getFilter(""ATT1 is 'r'"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(12, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testAttRegexp() {
    m_Filter = getFilter(""ATT1 regexp '(r|g)'"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(15, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testGreater() {
    m_Filter = getFilter(""ATT2 > 4"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(13, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testLess() {
    m_Filter = getFilter(""ATT2 < 4"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(7, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testGreaterOrEqual() {
    m_Filter = getFilter(""ATT2 >= 4"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(14, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testLessOrEqual() {
    m_Filter = getFilter(""ATT2 <= 4"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(8, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testEqual() {
    m_Filter = getFilter(""ATT2 = 4"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(1, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
"public void testAnd() {
    m_Filter = getFilter(""(ATT1 is 'r') and (ATT2 <= 5)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(6, result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SubsetByExpressionTest.java,weka-master
public RandomizeTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/instance/RandomizeTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    boolean diff = false;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      String i1 = m_Instances.instance(i).toString();
      String i2 = result.instance(i).toString();
      if (!i1.equals(i2)) {
        diff = true;
      }
    }
    assertTrue(""All instances seem to be in the same positions"", diff);
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RandomizeTest.java,weka-master
"public RemovePercentageTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemovePercentageTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemovePercentageTest.java,weka-master
"public void testInverting() {
    // non-inverted
    m_Filter = getFilter();
    ((RemovePercentage) m_Filter).setPercentage(20.0);
    Instances result = useFilter();

    // inverted
    m_Filter = getFilter();
    ((RemovePercentage) m_Filter).setPercentage(20.0);
    ((RemovePercentage) m_Filter).setInvertSelection(true);
    Instances resultInv = useFilter();

    assertEquals(
        m_Instances.numInstances(), 
        result.numInstances() + resultInv.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemovePercentageTest.java,weka-master
"public RemoveFrequentValuesTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveFrequentValuesTest.java,weka-master
"public void testString() {
    Instances icopy = new Instances(m_Instances);
    try {
      ((RemoveFrequentValues) m_Filter).setAttributeIndex(Integer.toString(indexString + 1));
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception selecting on a STRING attribute!"");
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveFrequentValuesTest.java,weka-master
"public void testNominal() {
    Instances   icopy;
    Instances   result;

    // setting the nominal index
    ((RemoveFrequentValues) m_Filter).setAttributeIndex(Integer.toString(indexNominal));

    // don't modify header
    icopy    = new Instances(m_Instances);
    m_Filter = getFilter();
    try {
      m_Filter.setInputFormat(icopy);
      result = useFilter();
      assertEquals( ""Doesn't modify the header, i.e. removing labels"", 
	  m_Instances.attribute(indexNominal).numValues(), 
	  result.attribute(indexNominal).numValues() );
    } catch (Exception ex) {
      // OK
    }

    // modify header
    icopy    = new Instances(m_Instances);
    m_Filter = getFilter();
    try {
      ((RemoveFrequentValues) m_Filter).setModifyHeader(true);
      m_Filter.setInputFormat(icopy);
      result = useFilter();
      assertEquals(   ""Returns "" + ((RemoveFrequentValues) m_Filter).getNumValues() 
	  + "" out of the "" + m_Instances.attribute(indexNominal).numValues() + "" labels"", 
	  ((RemoveFrequentValues) m_Filter).getNumValues(),
	  result.attribute(indexNominal).numValues() );
    } catch (Exception ex) {
      // OK
    }

    // modify header + least common
    icopy    = new Instances(m_Instances);
    m_Filter = getFilter();
    try {
      ((RemoveFrequentValues) m_Filter).setModifyHeader(true);
      ((RemoveFrequentValues) m_Filter).setUseLeastValues(true);
      m_Filter.setInputFormat(icopy);
      result = useFilter();
      assertEquals(   ""Returns "" + ((RemoveFrequentValues) m_Filter).getNumValues() 
	  + "" out of the "" + m_Instances.attribute(indexNominal).numValues() + "" labels"", 
	  ((RemoveFrequentValues) m_Filter).getNumValues(),
	  result.attribute(indexNominal).numValues() );
    } catch (Exception ex) {
      // OK
    }

    // modify header + least common + inverse
    icopy    = new Instances(m_Instances);
    m_Filter = getFilter();
    try {
      ((RemoveFrequentValues) m_Filter).setModifyHeader(true);
      ((RemoveFrequentValues) m_Filter).setUseLeastValues(true);
      ((RemoveFrequentValues) m_Filter).setInvertSelection(true);
      ((RemoveFrequentValues) m_Filter).setNumValues(4);
      m_Filter.setInputFormat(icopy);
      result = useFilter();
      assertEquals(   ""Returns 1 out of the "" + m_Instances.attribute(indexNominal).numValues() 
	  + "" labels, even though we try to remove "" + ((RemoveFrequentValues) m_Filter).getNumValues()  
	  + "" labels, since it always returns at least 1 label"",
	  1,
	  result.attribute(indexNominal).numValues() );
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveFrequentValuesTest.java,weka-master
"public void testNumeric() {
    Instances icopy = new Instances(m_Instances);
    try {
      ((RemoveFrequentValues) m_Filter).setAttributeIndex(Integer.toString(indexNumeric + 1));
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception selecting on a NUMERIC attribute!"");
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveFrequentValuesTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((RemoveFrequentValues) m_FilteredClassifier.getFilter()).setAttributeIndex(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }

    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveFrequentValuesTest.java,weka-master
public ResampleTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/instance/ResampleTest.java,weka-master
"public void testSampleSizePercent() {
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 50% of input"",
                 m_Instances.numInstances() / 2,  result.numInstances());

    ((Resample)m_Filter).setSampleSizePercent(200);
    result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 200% of input"",
                 m_Instances.numInstances() * 2,  result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/ResampleTest.java,weka-master
"public void testSampleSizePercentNoReplacement() {
    ((Resample) m_Filter).setSampleSizePercent(20);
    ((Resample) m_Filter).setNoReplacement(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 20% of input"",
                 (int) (m_Instances.numInstances() * 20.0 / 100),  result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/ResampleTest.java,weka-master
"public void testSampleSizePercentNoReplacementInverted() {
    ((Resample) m_Filter).setSampleSizePercent(20);
    ((Resample) m_Filter).setNoReplacement(true);
    ((Resample) m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(""Expecting output to be 80% of input (20% inverted)"",
                 m_Instances.numInstances() 
                 - (int) (m_Instances.numInstances() * 20.0 / 100),  result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/ResampleTest.java,weka-master
"public RemoveMisclassifiedTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveMisclassifiedTest.java,weka-master
"public void testNominal() {
    m_Filter = getFilter(true);
    m_Instances.setClassIndex(0);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveMisclassifiedTest.java,weka-master
"public void testNumeric() {
    m_Filter = getFilter(false);
    m_Instances.setClassIndex(1);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveMisclassifiedTest.java,weka-master
"public void testInverting() {
    // not inverted
    m_Filter = getFilter();
    m_Instances.setClassIndex(0);
    Instances result = useFilter();
    
    // inverted
    m_Filter = getFilter();
    ((RemoveMisclassified) m_Filter).setInvert(true);
    m_Instances.setClassIndex(0);
    Instances resultInv = useFilter();

    assertEquals(
        m_Instances.numInstances(), 
        result.numInstances() + resultInv.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveMisclassifiedTest.java,weka-master
public RemoveRangeTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/instance/RemoveRangeTest.java,weka-master
"public void testSpecifiedRange() {
    
    ((RemoveRange)m_Filter).setInstancesIndices(""1-10"");
    ((RemoveRange)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(10,  result.numInstances());
    for (int i = 0; i < 10; i++) {
      assertEquals(m_Instances.instance(i).toString(), result.instance(i).toString());
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/RemoveRangeTest.java,weka-master
public SparseToNonSparseTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/instance/SparseToNonSparseTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check conversion is OK
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Instance should not be an instanceof SparseInstance:"" + (i + 1),
             !(result.instance(i) instanceof SparseInstance));
    }
  }",./weka/src/test/java/weka/filters/unsupervised/instance/SparseToNonSparseTest.java,weka-master
"public AddClusterTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddClusterTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes() + 1, result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddClusterTest.java,weka-master
"public ChangeDateFormatTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ChangeDateFormatTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    ((ChangeDateFormat) m_Filter).setDateFormat(""yyyy-MM"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // all instance's must be different
    boolean equal = false;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (m_Comparator.compare(
            m_Instances.instance(i), result.instance(i)) == 0) {
        equal = true;
        break;
      }
    }
    if (equal)
      fail(""Instances not changed!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ChangeDateFormatTest.java,weka-master
"public void testSameFormat() {
    m_Filter = getFilter();
    ((ChangeDateFormat) m_Filter).setDateFormat(""yyyy-MM-dd"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // all instance's must be the same
    boolean equal = true;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (m_Comparator.compare(
            m_Instances.instance(i), result.instance(i)) != 0) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Instances modified!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ChangeDateFormatTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isDate()) {
	  ((ChangeDateFormat) m_FilteredClassifier.getFilter()).setAttributeIndex(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ChangeDateFormatTest.java,weka-master
public NumericTransformTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/NumericTransformTest.java,weka-master
"public void testDefault() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // Check conversion is OK
    for (int i = 0; i < result.numInstances(); i++) {
      for (int j = 0; j < result.numAttributes(); j++) {
        if (m_Instances.instance(i).isMissing(j)) {
          assertTrue(result.instance(i).isMissing(j));
        } else if (result.attribute(j).isNumeric()) {
          assertEquals(""Value should be same as Math.abs()"",
                       Math.abs(m_Instances.instance(i).value(j)),
                       result.instance(i).value(j), TOLERANCE);
        } else {
          assertEquals(""Value shouldn't have changed"",
                       m_Instances.instance(i).value(j),
                       result.instance(i).value(j), TOLERANCE);
        }
      }
    }    
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericTransformTest.java,weka-master
"public void testInverted() {
    m_Filter = getFilter(""1-3"");
    ((NumericTransform)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // Check conversion is OK
    for (int i = 0; i < result.numInstances(); i++) {
      for (int j = 0; j < result.numAttributes(); j++) {
        if (m_Instances.instance(i).isMissing(j)) {
          assertTrue(result.instance(i).isMissing(j));
        } else if (result.attribute(j).isNumeric() && (j >=3)) {
          assertEquals(""Value should be same as Math.abs()"",
                       Math.abs(m_Instances.instance(i).value(j)),
                       result.instance(i).value(j), TOLERANCE);
        } else {
          assertEquals(""Value shouldn't have changed"",
                       m_Instances.instance(i).value(j),
                       result.instance(i).value(j), TOLERANCE);
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericTransformTest.java,weka-master
"public void testClassNameAndMethodName() throws Exception {
    ((NumericTransform)m_Filter).setClassName(""java.lang.Math"");
    ((NumericTransform)m_Filter).setMethodName(""rint"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // Check conversion is OK
    for (int i = 0; i < result.numInstances(); i++) {
      for (int j = 0; j < result.numAttributes(); j++) {
        if (m_Instances.instance(i).isMissing(j)) {
          assertTrue(result.instance(i).isMissing(j));
        } else if (result.attribute(j).isNumeric()) {
          assertEquals(""Value should be same as Math.rint()"",
                       Math.rint(m_Instances.instance(i).value(j)),
                       result.instance(i).value(j), TOLERANCE);
        } else {
          assertEquals(""Value shouldn't have changed"",
                       m_Instances.instance(i).value(j),
                       result.instance(i).value(j), TOLERANCE);
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericTransformTest.java,weka-master
"public MathExpressionTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testStats() {
    checkStatistics(
        ""MIN"", m_Instances.attributeStats(m_AttIndex).numericStats.min);
    checkStatistics(
        ""MAX"", m_Instances.attributeStats(m_AttIndex).numericStats.max);
    checkStatistics(
        ""MEAN"", m_Instances.attributeStats(m_AttIndex).numericStats.mean);
    checkStatistics(
        ""SD"", m_Instances.attributeStats(m_AttIndex).numericStats.stdDev);
    checkStatistics(
        ""COUNT"", m_Instances.attributeStats(m_AttIndex).numericStats.count);
    checkStatistics(
        ""SUM"", m_Instances.attributeStats(m_AttIndex).numericStats.sum);
    checkStatistics(
        ""SUMSQUARED"", m_Instances.attributeStats(m_AttIndex).numericStats.sumSq);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testEquality() {
    m_Filter = getFilter(""A"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            m_Instances.instance(i).value(m_AttIndex), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter modifies attribute values)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testAbs() {
    m_Filter = getFilter(""abs(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.abs(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testsqrt() {
    m_Filter = getFilter(""sqrt(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.sqrt(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testLog() {
    m_Filter = getFilter(""log(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.log(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testExp() {
    m_Filter = getFilter(""exp(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.exp(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testSin() {
    m_Filter = getFilter(""sin(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.sin(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testCos() {
    m_Filter = getFilter(""cos(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.cos(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testTan() {
    m_Filter = getFilter(""tan(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.tan(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testRint() {
    m_Filter = getFilter(""rint(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.rint(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testFloor() {
    m_Filter = getFilter(""floor(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.floor(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testPow2() {
    m_Filter = getFilter(""pow(A,2)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.pow(m_Instances.instance(i).value(m_AttIndex), 2), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public void testCeil() {
    m_Filter = getFilter(""ceil(A)"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // check equality
    boolean equal = true;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i) instanceof SparseInstance)
        continue;
      if (!Utils.eq(
            Math.ceil(m_Instances.instance(i).value(m_AttIndex)), 
            result.instance(i).value(m_AttIndex))) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Filter produces different result)!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MathExpressionTest.java,weka-master
"public InterquartileRangeTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/InterquartileRangeTest.java,weka-master
"public void testNominalClass() {
    // run filter
    m_Instances.setClassIndex(1);
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // test
    assertEquals(icopy.numAttributes() + 2, result.numAttributes());
    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/InterquartileRangeTest.java,weka-master
"public void testNominalClassSingleAttribute() {
    // run filter
    m_Instances.setClassIndex(1);
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    ((InterquartileRange) m_Filter).setAttributeIndices(""3"");
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // test
    assertEquals(icopy.numAttributes() + 2, result.numAttributes());
    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/InterquartileRangeTest.java,weka-master
"public void testNumericClass() {
    // run filter
    m_Instances.setClassIndex(2);
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // test
    assertEquals(icopy.numAttributes() + 2, result.numAttributes());
    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/InterquartileRangeTest.java,weka-master
"public void testWithoutClass() {
    // run filter
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // test
    assertEquals(icopy.numAttributes() + 2, result.numAttributes());
    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/InterquartileRangeTest.java,weka-master
"public void testPerAttribute() {
    // parameters
    ((InterquartileRange) m_Filter).setDetectionPerAttribute(true);
    
    // run filter
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // test
    int count = 0;
    for (int i = 0; i < icopy.numAttributes(); i++) {
      if (icopy.attribute(i).isNumeric())
	count++;
    }
    assertEquals(icopy.numAttributes() + 2*count, result.numAttributes());
    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/InterquartileRangeTest.java,weka-master
"public void testOffset() {
    // parameters
    ((InterquartileRange) m_Filter).setDetectionPerAttribute(true);
    ((InterquartileRange) m_Filter).setOutputOffsetMultiplier(true);

    // run filter
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    // test
    int count = 0;
    for (int i = 0; i < icopy.numAttributes(); i++) {
      if (icopy.attribute(i).isNumeric())
	count++;
    }
    assertEquals(icopy.numAttributes() + 3*count, result.numAttributes());
    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/InterquartileRangeTest.java,weka-master
public AddTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/AddTest.java,weka-master
"public void testAddFirst() {
    m_Filter = getFilter(0);
    testBuffered();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddTest.java,weka-master
"public void testAddLast() {
    m_Filter = getFilter(m_Instances.numAttributes() - 1);
    testBuffered();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddTest.java,weka-master
"protected void testType(int attType) {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }
    assertEquals(attType, result.attribute(result.numAttributes() - 1).type());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddTest.java,weka-master
"public void testAddNominal() {
    m_Filter = getFilter();
    ((Add)m_Filter).setNominalLabels(""hello,there,bob"");
    testBuffered();
    testType(Attribute.NOMINAL);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddTest.java,weka-master
"public void testAddString() {
    m_Filter = getFilter();
    ((Add) m_Filter).setAttributeType(new SelectedTag(Attribute.STRING, Add.TAGS_TYPE));
    testBuffered();
    testType(Attribute.STRING);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddTest.java,weka-master
"public void testAddDate() {
    m_Filter = getFilter();
    ((Add) m_Filter).setAttributeType(new SelectedTag(Attribute.DATE, Add.TAGS_TYPE));
    testBuffered();
    testType(Attribute.DATE);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddTest.java,weka-master
public StringToWordVectorTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/StringToWordVectorTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numInstances(),  result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/StringToWordVectorTest.java,weka-master
"public void testWordsToKeep() {
    ((StringToWordVector)m_Filter).setWordsToKeep(3);
    Instances result = useFilter();
    // Number of instances shouldn't change
    assertEquals(m_Instances.numInstances(),  result.numInstances());

    // Number of attributes will be minus 2 string attributes plus
    // the word attributes (aiming for 3 -- could be higher in the case of ties)
    assertEquals(m_Instances.numAttributes() - 2 + 3, result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/StringToWordVectorTest.java,weka-master
"public TransposeTest(String name) { 
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/TransposeTest.java,weka-master
"public void testBatchFiltering() {
    return;
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/TransposeTest.java,weka-master
"public void testBatchFilteringSmaller() {
    return;
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/TransposeTest.java,weka-master
"public void testBatchFilteringLarger() {
    return;
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/TransposeTest.java,weka-master
public void testChangesInputData() { return; },./weka/src/test/java/weka/filters/unsupervised/attribute/TransposeTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of instances should be number of attributes
    assertEquals(m_Instances.numAttributes(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/TransposeTest.java,weka-master
public RemoveTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter(""1,2"");
    ((Remove)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(2, result.numAttributes());
    assertEquals(m_Instances.attribute(0).name(), result.attribute(0).name());
    assertEquals(m_Instances.attribute(1).name(), result.attribute(1).name());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTest.java,weka-master
"public void testTypical2() {
    m_Filter = getFilter(""3-4"");
    ((Remove)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(2, result.numAttributes());
    assertEquals(m_Instances.attribute(2).name(), result.attribute(0).name());
    assertEquals(m_Instances.attribute(3).name(), result.attribute(1).name());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTest.java,weka-master
"public void testNonInverted() {
    m_Filter = getFilter(""1,2"");
    ((Remove)m_Filter).setInvertSelection(false);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes() - 2, result.numAttributes());
    assertEquals(m_Instances.attribute(2).name(), result.attribute(0).name());
    assertEquals(m_Instances.attribute(3).name(), result.attribute(1).name());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTest.java,weka-master
"public void testNonInverted2() {
    m_Filter = getFilter(""first-3"");
    ((Remove)m_Filter).setInvertSelection(false);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes() - 3, result.numAttributes());
    assertEquals(m_Instances.attribute(3).name(), result.attribute(0).name());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTest.java,weka-master
"public AddValuesTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddValuesTest.java,weka-master
"protected void performTest(Filter filter) {
    m_Filter = filter;
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    
    try {
      result = Filter.useFilter(m_Instances, m_Filter);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    try {
      compDatasets(icopy, result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Datasets differ: \n"" + ex.getMessage());
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddValuesTest.java,weka-master
"public void testDefault() {
    performTest(getFilter());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddValuesTest.java,weka-master
"public void testSort() {
    performTest(getFilter(true, """"));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddValuesTest.java,weka-master
"public void testLabels() {
    performTest(getFilter(false, ""__blah,__blubber""));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddValuesTest.java,weka-master
"public void testSortAndLabels() {
    performTest(getFilter(false, ""__blah,__blubber""));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddValuesTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((AddValues) m_FilteredClassifier.getFilter()).setAttributeIndex(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddValuesTest.java,weka-master
"public PartitionedMultiFilterTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PartitionedMultiFilterTest.java,weka-master
"public void testDisjoint() {
    Instances result = null;
    m_Instances.setClassIndex(2);
    
    try {
      result = applyFilter(
	  new Filter[]{new AllFilter(), new AllFilter()},
	  new Range[]{new Range(""1-2""),new Range(""4-5"")},
	  false);
    }
    catch (Exception e) {
      fail(""Problem applying the filter: "" + e);
    }
    
    assertEquals(m_Instances.numInstances(), result.numInstances());
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PartitionedMultiFilterTest.java,weka-master
"public void testDisjointRemoveUnused() {
    Instances result = null;
    m_Instances.setClassIndex(2);
    
    try {
      result = applyFilter(
	  new Filter[]{new AllFilter(), new AllFilter()},
	  new Range[]{new Range(""1-2""),new Range(""5"")},
	  true);
    }
    catch (Exception e) {
      fail(""Problem applying the filter: "" + e);
    }
    
    assertEquals(m_Instances.numInstances(), result.numInstances());
    assertEquals(m_Instances.numAttributes() - 1, result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PartitionedMultiFilterTest.java,weka-master
"public void testOverlapping() {
    Instances result = null;
    m_Instances.setClassIndex(2);
    
    try {
      result = applyFilter(
	  new Filter[]{new AllFilter(), new AllFilter()},
	  new Range[]{new Range(""1,2,4""),new Range(""2,4"")},
	  false);
    }
    catch (Exception e) {
      fail(""Problem applying the filter: "" + e);
    }
    
    assertEquals(m_Instances.numInstances(), result.numInstances());
    assertEquals(m_Instances.numAttributes() + 2, result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PartitionedMultiFilterTest.java,weka-master
"public void testOverlappingRemoveUnused() {
    Instances result = null;
    m_Instances.setClassIndex(2);
    
    try {
      result = applyFilter(
	  new Filter[]{new AllFilter(), new AllFilter()},
	  new Range[]{new Range(""1,2,4""),new Range(""2,4"")},
	  true);
    }
    catch (Exception e) {
      fail(""Problem applying the filter: "" + e);
    }
    
    assertEquals(m_Instances.numInstances(), result.numInstances());
    assertEquals(m_Instances.numAttributes() + 1, result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PartitionedMultiFilterTest.java,weka-master
"public AddIDTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddIDTest.java,weka-master
"protected void performTest() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals((icopy.numAttributes() + 1), result.numAttributes());
    assertEquals(icopy.numInstances(), m_Instances.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddIDTest.java,weka-master
"public void testAddFirst() {
    m_Filter = getFilter(0);
    testBuffered();
    performTest();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddIDTest.java,weka-master
"public void testAddLast() {
    m_Filter = getFilter(m_Instances.numAttributes() - 1);
    testBuffered();
    performTest();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddIDTest.java,weka-master
public CopyTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/CopyTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter(""1,2"");
    Instances result = useFilter();
    int origNum = m_Instances.numAttributes();
    assertEquals(origNum + 2, result.numAttributes());
    assertTrue(result.attribute(origNum).name().endsWith(m_Instances.attribute(0).name()));
    assertTrue(result.attribute(origNum + 1).name().endsWith(m_Instances.attribute(1).name()));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CopyTest.java,weka-master
"public void testTypical2() {
    m_Filter = getFilter(""3-4"");
    Instances result = useFilter();
    int origNum = m_Instances.numAttributes();
    assertEquals(origNum + 2, result.numAttributes());
    assertTrue(result.attribute(origNum).name().endsWith(m_Instances.attribute(2).name()));
    assertTrue(result.attribute(origNum + 1).name().endsWith(m_Instances.attribute(3).name()));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CopyTest.java,weka-master
"public void testNonInverted() {
    m_Filter = getFilter(""1,2"");
    ((Copy)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    int origNum = m_Instances.numAttributes();
    assertEquals(origNum + origNum - 2, result.numAttributes());
    assertTrue(result.attribute(origNum).name().endsWith(m_Instances.attribute(2).name()));
    assertTrue(result.attribute(origNum + 1).name().endsWith(m_Instances.attribute(3).name()));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CopyTest.java,weka-master
"public void testNonInverted2() {
    m_Filter = getFilter(""first-3"");
    ((Copy)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    int origNum = m_Instances.numAttributes();
    assertEquals(origNum + origNum - 3, result.numAttributes());
    assertTrue(result.attribute(origNum).name().endsWith(m_Instances.attribute(3).name()));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CopyTest.java,weka-master
public MergeTwoValuesTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/MergeTwoValuesTest.java,weka-master
"public void testInvalidAttributeTypes() {
    Instances icopy = new Instances(m_Instances);
    try {
      ((MergeTwoValues)m_Filter).setAttributeIndex(""1"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception selecting a STRING attribute!"");
    } catch (Exception ex) {
      // OK
    }
    try {
      ((MergeTwoValues)m_Filter).setAttributeIndex(""3"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception indicating a NUMERIC attribute!"");
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeTwoValuesTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if ((m_Instances.instance(i).value(1) == 0) || 
          (m_Instances.instance(i).value(1) == 2)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(1);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(1));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeTwoValuesTest.java,weka-master
"public void testFirstValueIndex() {
    ((MergeTwoValues)m_Filter).setFirstValueIndex(""2"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if ((m_Instances.instance(i).value(1) == 1) || 
          (m_Instances.instance(i).value(1) == 2)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(1);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(1));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeTwoValuesTest.java,weka-master
"public void testSecondValueIndex() {
    ((MergeTwoValues)m_Filter).setSecondValueIndex(""2"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if ((m_Instances.instance(i).value(1) == 0) || 
          (m_Instances.instance(i).value(1) == 1)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(1);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(1));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeTwoValuesTest.java,weka-master
"public void testAttributeWithMissing() {
    ((MergeTwoValues)m_Filter).setAttributeIndex(""5"");
    ((MergeTwoValues)m_Filter).setFirstValueIndex(""1"");
    ((MergeTwoValues)m_Filter).setSecondValueIndex(""2"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).isMissing(4)) {
        assertTrue(""Missing in input should give missing in result"",
               result.instance(i).isMissing(4));
      } else if ((m_Instances.instance(i).value(4) == 0) || 
                 (m_Instances.instance(i).value(4) == 1)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(4);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(4));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeTwoValuesTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((MergeTwoValues) m_FilteredClassifier.getFilter()).setAttributeIndex(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeTwoValuesTest.java,weka-master
"public RemoveUselessTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveUselessTest.java,weka-master
"public void testNoneRemoved() {
    m_Filter = getFilter(100);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveUselessTest.java,weka-master
"public void testSomeRemoved() {
    m_Filter = getFilter(5);
    Instances result = useFilter();
    assertTrue(m_Instances.numAttributes() > result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveUselessTest.java,weka-master
"public PKIDiscretizeTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PKIDiscretizeTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // the discretized attribute must be nominal
    assertTrue(result.attribute(m_AttIndex).isNominal());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PKIDiscretizeTest.java,weka-master
public NumericToBinaryTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToBinaryTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());

    // Check conversion is OK
    for (int j = 0; j < result.numAttributes(); j++) {
      if (m_Instances.attribute(j).isNumeric()) {
        assertTrue(""Numeric attribute should now be nominal"",
               result.attribute(j).isNominal());
        for (int i = 0; i < result.numInstances(); i++) {
          if (m_Instances.instance(i).isMissing(j)) {
            assertTrue(result.instance(i).isMissing(j));
          } else if (m_Instances.instance(i).value(j) == 0) {
            assertTrue(""Output value should be 0"", 
                   result.instance(i).value(j) == 0);
          } else {
            assertTrue(""Output value should be 1"", 
                   result.instance(i).value(j) == 1);
          }
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToBinaryTest.java,weka-master
"public void testSpecificIndex() {
	  int att1 = m_Instances.attribute(""NumericAtt1"").index();
	  int att2 = m_Instances.attribute(""NumericAtt2"").index();  
	  // Set the attribute index to point to NumericAtt1, so we expect that only this
	  // attribute will be binarized.
	  ((NumericToBinary)m_Filter).setAttributeIndices( String.valueOf(att1+1) );
	  Instances result = useFilter();
	  assertTrue(""NumericAtt1 should be nominal"", result.attribute(att1).isNominal());
	  assertTrue(""NumericAtt2 should be numeric"", result.attribute(att2).isNumeric());  
	  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToBinaryTest.java,weka-master
"public void testInvertSelection() {
	  int att1 = m_Instances.attribute(""NumericAtt1"").index();
	  int att2 = m_Instances.attribute(""NumericAtt2"").index(); 
	  // Set the attribute index to point to NumericAtt1, but invert the selection, so that
	  // it will try to apply the filter to *every other* attribute. Of course, because this
	  // only applies to numeric attributes, the filter should only change NumericAtt2
	  ((NumericToBinary)m_Filter).setAttributeIndices( String.valueOf(att2+1) );
	  ((NumericToBinary)m_Filter).setInvertSelection(true);
	  Instances result = useFilter();
	  assertTrue(""NumericAtt1 should be nominal"", result.attribute(att1).isNominal());
	  assertTrue(""NumericAtt2 should be numeric"", result.attribute(att2).isNumeric());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToBinaryTest.java,weka-master
"public void testRange() {
	  int att1 = m_Instances.attribute(""NumericAtt1"").index();
	  int att2 = m_Instances.attribute(""NumericAtt2"").index(); 
	  // Use the string expression ""first-last"" for the attribute index. This should
	  // change both numeric attributes.
	  ((NumericToBinary)m_Filter).setAttributeIndices(""first-last"");
	  ((NumericToBinary)m_Filter).setInvertSelection(false);
	  Instances result = useFilter();
	  assertTrue(""NumericAtt1 should be nominal"", result.attribute(att1).isNominal());
	  assertTrue(""NumericAtt2 should be nominal"", result.attribute(att2).isNominal());	
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToBinaryTest.java,weka-master
"public ReplaceMissingWithUserConstantTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReplaceMissingWithUserConstantTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    for (int j = 0; j < m_Instances.numAttributes(); j++) {
      for (int i = 0; i < m_Instances.numInstances(); i++) {
        assertTrue(
          ""All missing values should have been replaced "" + result.instance(i),
          !result.instance(i).isMissing(j));
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReplaceMissingWithUserConstantTest.java,weka-master
"public CartesianProductTest(String name) {
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CartesianProductTest.java,weka-master
"public void testTypical() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CartesianProductTest.java,weka-master
"public PrincipalComponentsTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PrincipalComponentsTest.java,weka-master
"protected void performTest() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PrincipalComponentsTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    performTest();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PrincipalComponentsTest.java,weka-master
"public void testCovariance() {
    m_Filter = getFilter();
    ((PrincipalComponents) m_Filter).setCenterData(true);
    performTest();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PrincipalComponentsTest.java,weka-master
"public void testVariance() {
    m_Filter = getFilter();
    ((PrincipalComponents) m_Filter).setVarianceCovered(0.8);
    performTest();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PrincipalComponentsTest.java,weka-master
"public void testMaxAttributes() {
    m_Filter = getFilter();
    ((PrincipalComponents) m_Filter).setMaximumAttributeNames(2);
    performTest();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/PrincipalComponentsTest.java,weka-master
"public CenterTest(String name) { 
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CenterTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/CenterTest.java,weka-master
"public RenameAttributeTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameAttributeTest.java,weka-master
"protected Instances performTest() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(icopy.numAttributes(), result.numAttributes());
    assertEquals(icopy.numInstances(), m_Instances.numInstances());
    
    return result;
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameAttributeTest.java,weka-master
"public void testReplaceFirst() {
    Instances	result;

    m_Filter = getFilter(""t"", ""_"", false, ""first-last"", false);
    result   = performTest();
    
    assertEquals(""S_ringAtt1"", result.attribute(0).name());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameAttributeTest.java,weka-master
"public void testReplaceAll() {
    Instances	result;

    m_Filter = getFilter(""t"", ""_"", true, ""first-last"", false);
    result   = performTest();
    
    assertEquals(""S_ringA__1"", result.attribute(0).name());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameAttributeTest.java,weka-master
"public void testInvertRange() {
    Instances	result;

    m_Filter = getFilter(""t"", ""_"", true, ""first"", true);
    result   = performTest();
    
    assertTrue(""The first attribute contains '_'!"", (result.attribute(0).name().indexOf(""_"") == -1));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameAttributeTest.java,weka-master
"public void testGroup() {
    Instances	result;
    int		i;

    m_Filter = getFilter(""(.+)(Att)(.+)"", ""$1$3"", true, ""first-last"", false);
    result   = performTest();
    
    for (i = 0; i < result.numAttributes(); i++)
      assertTrue(result.attribute(i).name() + "" still contains 'Att'"", (result.attribute(i).name().indexOf(""Att"") == -1));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameAttributeTest.java,weka-master
public DiscretizeTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/DiscretizeTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter(""1,2"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    // None of the attributes should have changed, since 1,2 aren't numeric
    for (int i = 0; i < result.numAttributes(); i++) {
      assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
      assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DiscretizeTest.java,weka-master
"public void testTypical2() {
    m_Filter = getFilter(""3-4"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    for (int i = 0; i < result.numAttributes(); i++) {
      if (i != 2) {
        assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
        assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
      } else {
        assertEquals(Attribute.NOMINAL, result.attribute(i).type());
        assertEquals(10, result.attribute(i).numValues());
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DiscretizeTest.java,weka-master
"public void testInverted() {
    m_Filter = getFilter(""1,2"");
    ((Discretize)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    for (int i = 0; i < result.numAttributes(); i++) {
      if ((i < 2) || !m_Instances.attribute(i).isNumeric()) {
        assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
        assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
      } else {
        assertEquals(Attribute.NOMINAL, result.attribute(i).type());
        assertEquals(10, result.attribute(i).numValues());
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DiscretizeTest.java,weka-master
"public void testNonInverted2() {
    m_Filter = getFilter(""first-3"");
    ((Discretize)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    for (int i = 0; i < result.numAttributes(); i++) {
      if ((i < 3) || !m_Instances.attribute(i).isNumeric()) {
        assertEquals(m_Instances.attribute(i).type(), result.attribute(i).type());
        assertEquals(m_Instances.attribute(i).name(), result.attribute(i).name());
      } else {
        assertEquals(Attribute.NOMINAL, result.attribute(i).type());
        assertEquals(10, result.attribute(i).numValues());
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DiscretizeTest.java,weka-master
"public void testBins() {
    m_Filter = getFilter(""3"");
    ((Discretize)m_Filter).setBins(5);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(Attribute.NOMINAL, result.attribute(2).type());
    assertEquals(5, result.attribute(2).numValues());

    ((Discretize)m_Filter).setBins(20);
    result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(Attribute.NOMINAL, result.attribute(2).type());
    assertEquals(20, result.attribute(2).numValues());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DiscretizeTest.java,weka-master
"public void testFindNumBins() {
    m_Filter = getFilter(""3"");
    ((Discretize)m_Filter).setFindNumBins(true);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(Attribute.NOMINAL, result.attribute(2).type());
    assertTrue(5 >= result.attribute(2).numValues());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DiscretizeTest.java,weka-master
public RemoveTypeTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTypeTest.java,weka-master
"public void testNominalFiltering() {
    m_Filter = getFilter(Attribute.NOMINAL);
    Instances result = useFilter();
    for (int i = 0; i < result.numAttributes(); i++) {
      assertTrue(result.attribute(i).type() != Attribute.NOMINAL);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTypeTest.java,weka-master
"public void testStringFiltering() {
    m_Filter = getFilter(Attribute.STRING);
    Instances result = useFilter();
    for (int i = 0; i < result.numAttributes(); i++) {
      assertTrue(result.attribute(i).type() != Attribute.STRING);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTypeTest.java,weka-master
"public void testNumericFiltering() {
    m_Filter = getFilter(Attribute.NUMERIC);
    Instances result = useFilter();
    for (int i = 0; i < result.numAttributes(); i++) {
      assertTrue(result.attribute(i).type() != Attribute.NUMERIC);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTypeTest.java,weka-master
"public void testDateFiltering() {
    m_Filter = getFilter(Attribute.DATE);
    Instances result = useFilter();
    for (int i = 0; i < result.numAttributes(); i++) {
      assertTrue(result.attribute(i).type() != Attribute.DATE);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveTypeTest.java,weka-master
public MakeIndicatorTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/MakeIndicatorTest.java,weka-master
"public void testInvalidAttributeTypes() {
    Instances icopy = new Instances(m_Instances);
    try {
      ((MakeIndicator)m_Filter).setAttributeIndex(""1"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception selecting a STRING attribute!"");
    } catch (Exception ex) {
      // OK
    }
    try {
      ((MakeIndicator)m_Filter).setAttributeIndex(""3"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception indicating a NUMERIC attribute!"");
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MakeIndicatorTest.java,weka-master
"public void testDefault() {
    ((MakeIndicator)m_Filter).setAttributeIndex(""2"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that default attribute type is numeric
    assertEquals(""Default attribute encoding should be NUMERIC"",
                 Attribute.NUMERIC, result.attribute(1).type());
    // Check that default indication is correct
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Checking indicator for instance: "" + (i + 1),
             (m_Instances.instance(i).value(1) == 2) ==
             (result.instance(i).value(1) == 1));
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MakeIndicatorTest.java,weka-master
"public void testNominalEncoding() {
    ((MakeIndicator)m_Filter).setAttributeIndex(""2"");
    ((MakeIndicator)m_Filter).setNumeric(false);    
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that default attribute type is numeric
    assertEquals(""New attribute encoding should be NOMINAL"",
                 Attribute.NOMINAL, result.attribute(1).type());
    // Check that default indication is correct
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Checking indicator for instance: "" + (i + 1),
             (m_Instances.instance(i).value(1) == 2) ==
             (result.instance(i).value(1) == 1));
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MakeIndicatorTest.java,weka-master
"public void testMultiValueIndication() {
    ((MakeIndicator)m_Filter).setAttributeIndex(""2"");
    try {
      ((MakeIndicator)m_Filter).setValueIndices(""1,3"");
    } catch (Exception ex) {
      fail(""Is Range broken?"");
    }
    ((MakeIndicator)m_Filter).setNumeric(false);    
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that default attribute type is numeric
    assertEquals(""New attribute encoding should be NOMINAL"",
                 Attribute.NOMINAL, result.attribute(1).type());
    // Check that default indication is correct
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Checking indicator for instance: "" + (i + 1),
             ((m_Instances.instance(i).value(1) == 0) ||
              (m_Instances.instance(i).value(1) == 2)) 
             ==
             (result.instance(i).value(1) == 1));
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MakeIndicatorTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((MakeIndicator) m_FilteredClassifier.getFilter()).setAttributeIndex(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MakeIndicatorTest.java,weka-master
"public RandomSubsetTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomSubsetTest.java,weka-master
"protected void performTest(double numSel, int numOut) {
    m_Filter         = getFilter(numSel);
    Instances icopy  = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(numOut, result.numAttributes());
    assertEquals(icopy.numInstances(), m_Instances.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomSubsetTest.java,weka-master
"public void testPercentage() {
    performTest(0.5, 4);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomSubsetTest.java,weka-master
"public void testAbsolute() {
    performTest(5, 5);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomSubsetTest.java,weka-master
public StringToNominalTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/StringToNominalTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    assertEquals(""Attribute type should now be NOMINAL"",
                 Attribute.NOMINAL, result.attribute(0).type());

    assertEquals(14, result.attribute(0).numValues());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/StringToNominalTest.java,weka-master
"public void testMissing() {
    ((StringToNominal)m_Filter).setAttributeRange(""4"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    assertEquals(""Attribute type should now be NOMINAL"",
                 Attribute.NOMINAL, result.attribute(3).type());

    assertEquals(8, result.attribute(3).numValues());
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Missing values should be preserved"",
             m_Instances.instance(i).isMissing(3) ==
             result.instance(i).isMissing(3));
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/StringToNominalTest.java,weka-master
"public void testRange() {
	    ((StringToNominal)m_Filter).setAttributeRange(""first-last"");
	    Instances result = useFilter();
	    // Number of attributes and instances shouldn't change
	    assertEquals(m_Instances.numAttributes(), result.numAttributes());
	    assertEquals(m_Instances.numInstances(),  result.numInstances());
	    
	    assertEquals(""Attribute type should now be NOMINAL"",
                Attribute.NOMINAL, result.attribute(0).type());
	    assertEquals(""Attribute type should still be NOMINAL"",
                Attribute.NOMINAL, result.attribute(1).type());
	    assertEquals(""Attribute type should still be NUMERIC"",
                Attribute.NUMERIC, result.attribute(2).type());
	    assertEquals(""Attribute type should now be NOMINAL"",
	                 Attribute.NOMINAL, result.attribute(3).type());
	    assertEquals(""Attribute type should still be NOMINAL"",
                Attribute.NOMINAL, result.attribute(4).type());
	    assertEquals(""Attribute type should still be NUMERIC"",
                Attribute.NUMERIC, result.attribute(5).type());
	    assertEquals(""Attribute type should still be DATE"",
                Attribute.DATE, result.attribute(6).type());

	    assertEquals(14, result.attribute(0).numValues());
	    
	    assertEquals(8, result.attribute(3).numValues());
	    for (int i = 0; i < result.numInstances(); i++) {
	      assertTrue(""Missing values should be preserved"",
	             m_Instances.instance(i).isMissing(3) ==
	             result.instance(i).isMissing(3));
	    }
	  }",./weka/src/test/java/weka/filters/unsupervised/attribute/StringToNominalTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isString()) {
	  ((StringToNominal) m_FilteredClassifier.getFilter()).setAttributeRange(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/StringToNominalTest.java,weka-master
"public MergeManyValuesTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeManyValuesTest.java,weka-master
"public void testInvalidAttributeTypes() {
    Instances icopy = new Instances(m_Instances);
    try {
      ((MergeManyValues)m_Filter).setAttributeIndex(""1"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception selecting a STRING attribute!"");
    } catch (Exception ex) {
      // OK
    }
    try {
      ((MergeManyValues)m_Filter).setAttributeIndex(""3"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception indicating a NUMERIC attribute!"");
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeManyValuesTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if ((m_Instances.instance(i).value(1) == 0) || 
          (m_Instances.instance(i).value(1) == 1)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(1);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(1));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeManyValuesTest.java,weka-master
"public void testDifferentRange() {
    ((MergeManyValues)m_Filter).setMergeValueRange(""2,3"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if ((m_Instances.instance(i).value(1) == 1) || 
          (m_Instances.instance(i).value(1) == 2)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(1);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(1));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeManyValuesTest.java,weka-master
"public void testMergeAll() {
    ((MergeManyValues)m_Filter).setMergeValueRange(""first-last"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    assertEquals(1, result.attribute(1).numValues());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeManyValuesTest.java,weka-master
"public void testAttributeWithMissing() {
    ((MergeManyValues)m_Filter).setAttributeIndex(""5"");
    ((MergeManyValues)m_Filter).setMergeValueRange(""1,2"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).isMissing(4)) {
        assertTrue(""Missing in input should give missing in result"",
               result.instance(i).isMissing(4));
      } else if ((m_Instances.instance(i).value(4) == 0) || 
                 (m_Instances.instance(i).value(4) == 1)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(4);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(4));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeManyValuesTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((MergeManyValues) m_FilteredClassifier.getFilter()).setAttributeIndex(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeManyValuesTest.java,weka-master
"public ClassAssignerTest(String name) { 
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ClassAssignerTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ClassAssignerTest.java,weka-master
"public NumericCleanerTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericCleanerTest.java,weka-master
"public void testTypical() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(icopy.numAttributes(), result.numAttributes());
    assertEquals(icopy.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericCleanerTest.java,weka-master
"public RandomProjectionTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomProjectionTest.java,weka-master
"public void testSparse1() {
    checkDistributionType(RandomProjection.SPARSE1);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomProjectionTest.java,weka-master
"public void testSparse2() {
    checkDistributionType(RandomProjection.SPARSE2);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomProjectionTest.java,weka-master
"public void testGaussian() {
    checkDistributionType(RandomProjection.GAUSSIAN);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomProjectionTest.java,weka-master
"public void testNumberOfAttributes() {
    m_Filter = getFilter(5);
    Instances result = useFilter();
    checkResult(result);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RandomProjectionTest.java,weka-master
public TimeSeriesDeltaTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/TimeSeriesDeltaTest.java,weka-master
"public void testInverted() {
    m_Filter = getFilter(""1,2,3,4,5,6"");
    ((TimeSeriesDelta)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    // Number of attributes shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances() - 1, result.numInstances());
    // Check conversion looks OK
    for (int i = 0; i < result.numInstances(); i++) {
      Instance in = m_Instances.instance(i + 1);
      Instance out = result.instance(i);
      for (int j = 0; j < result.numAttributes(); j++) {
        if ((j != 4) && (j != 5) && (j != 6)) {
          if (in.isMissing(j)) {
            assertTrue(""Nonselected missing values should pass through"",
                   out.isMissing(j));
          } else if (result.attribute(j).isString()) {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         m_Instances.attribute(j).value((int)in.value(j)),
                         result.attribute(j).value((int)out.value(j)));
          } else {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         in.value(j),
                         out.value(j), TOLERANCE);
          }
        }
      }
    }    
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/TimeSeriesDeltaTest.java,weka-master
"public NominalToStringTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NominalToStringTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    assertEquals(""Attribute type should now be STRING"",
                 Attribute.STRING, result.attribute(1).type());

    assertEquals(3, result.attribute(1).numValues());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NominalToStringTest.java,weka-master
"public void testMissing() {
    ((NominalToString)m_Filter).setAttributeIndexes(""5"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    assertEquals(""Attribute type should now be STRING"",
                 Attribute.STRING, result.attribute(4).type());
    assertEquals(4, result.attribute(4).numValues());
    for (int i = 0; i < result.numInstances(); i++) {
      assertTrue(""Missing values should be preserved"",
             m_Instances.instance(i).isMissing(4) ==
             result.instance(i).isMissing(4));
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NominalToStringTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((NominalToString) m_FilteredClassifier.getFilter()).setAttributeIndexes(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NominalToStringTest.java,weka-master
"public FixedDictionaryStringToWordVectorTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/FixedDictionaryStringToWordVectorTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numInstances(),  result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/FixedDictionaryStringToWordVectorTest.java,weka-master
"public RemoveByNameTest(String name) { 
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveByNameTest.java,weka-master
"public void testTypical() {
    Instances 	result;

    m_Filter = getFilter(""^String.*"", false);

    // 1. with class attribute
    result = useFilter();
    // Number of attributes will be two less, number of instances won't change
    assertEquals(m_Instances.numAttributes() - 2, result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveByNameTest.java,weka-master
"public void testTypicalWithClass() {
    Instances 	result;

    m_Instances.setClassIndex(1);  // ""NominalAtt1""
    m_Filter = getFilter(""^Nominal.*"", false);

    // 1. with class attribute
    result = useFilter();
    // Number of attributes will be two less, number of instances won't change
    assertEquals(m_Instances.numAttributes() - 1, result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveByNameTest.java,weka-master
"public void testTypicalInverted() {
    Instances 	result;

    m_Filter = getFilter("".*Att2$"", true);

    // 1. with class attribute
    result = useFilter();
    // Number of attributes will be two less, number of instances won't change
    assertEquals(3, result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RemoveByNameTest.java,weka-master
"public ReorderTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReorderTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter(""2,1"");
    Instances result = useFilter();
    m_Instances.numAttributes();
    assertEquals(2, result.numAttributes());
    assertTrue(result.attribute(1).name()
      .endsWith(m_Instances.attribute(0).name()));
    assertTrue(result.attribute(0).name()
      .endsWith(m_Instances.attribute(1).name()));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReorderTest.java,weka-master
"public void testTypical2() {
    m_Filter = getFilter(""3-4"");
    Instances result = useFilter();
    m_Instances.numAttributes();
    assertEquals(2, result.numAttributes());
    assertTrue(result.attribute(0).name()
      .endsWith(m_Instances.attribute(2).name()));
    assertTrue(result.attribute(1).name()
      .endsWith(m_Instances.attribute(3).name()));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReorderTest.java,weka-master
"public void testTypical3() {
    m_Filter = getFilter(""2-last,1"");
    Instances result = useFilter();
    int origNum = m_Instances.numAttributes();
    assertEquals(origNum, result.numAttributes());
    assertTrue(result.attribute(0).name()
      .endsWith(m_Instances.attribute(1).name()));
    assertTrue(result.attribute(1).name()
      .endsWith(m_Instances.attribute(2).name()));
    assertTrue(result.attribute(origNum - 1).name()
      .endsWith(m_Instances.attribute(0).name()));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReorderTest.java,weka-master
"public AddNoiseTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddNoiseTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // at least one instance must be different
    boolean equal = true;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      if (m_Comparator.compare(
            m_Instances.instance(i), result.instance(i)) != 0) {
        equal = false;
        break;
      }
    }
    if (equal)
      fail(""No noise added!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddNoiseTest.java,weka-master
"public void testNoNoise() {
    m_Filter = getFilter();
    ((AddNoise) m_Filter).setPercent(0);
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // all instance's must be the same
    boolean equal = true;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      if (m_Comparator.compare(
            m_Instances.instance(i), result.instance(i)) != 0) {
        equal = false;
        break;
      }
    }
    if (!equal)
      fail(""Instances modified!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddNoiseTest.java,weka-master
public NominalToBinaryTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/NominalToBinaryTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes() + 5, result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Eibe can enhance this to check the binarizing is correct.
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NominalToBinaryTest.java,weka-master
"public SortLabelsTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SortLabelsTest.java,weka-master
"protected Instances performTest() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(""Number of attributes"", icopy.numAttributes(), result.numAttributes());
    assertEquals(""Number of instances"", icopy.numInstances(), m_Instances.numInstances());
    for (int i = 0; i < result.numAttributes(); i++) {
      // test number of values
      assertEquals(""Number of values differ for attribute #"" + (i+1), icopy.attribute(i).numValues(), result.attribute(i).numValues());
      // test values
      HashSet<String> valuesOriginal = new HashSet<String>();
      HashSet<String> valuesResult = new HashSet<String>();
      for (int n = 0; n < icopy.attribute(i).numValues(); n++) {
	valuesOriginal.add(icopy.attribute(i).value(n));
	valuesResult.add(result.attribute(i).value(n));
      }
      assertEquals(""Values differ for attribute #"" + (i+1), valuesOriginal, valuesResult);
    }
    
    return result;
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SortLabelsTest.java,weka-master
"public void testCaseSensitive() {
    m_Filter = getFilter(SortLabels.SORT_CASESENSITIVE, ""first-last"");
    testBuffered();
    Instances result = performTest();
    String[] sorted = new String[]{""b"", ""g"", ""r""};
    for (int i = 0; i < sorted.length; i++)
      assertEquals(""Values differ for index #"" + (i+1), result.attribute(0).value(i), sorted[i]);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SortLabelsTest.java,weka-master
"public void testCaseInsensitive() {
    m_Filter = getFilter(SortLabels.SORT_CASEINSENSITIVE, ""first-last"");
    testBuffered();
    Instances result = performTest();
    String[] sorted = new String[]{""b"", ""g"", ""r""};
    for (int i = 0; i < sorted.length; i++)
      assertEquals(""Values differ for index #"" + (i+1), sorted[i], result.attribute(0).value(i));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SortLabelsTest.java,weka-master
"public void testUnchangedOrder() {
    m_Filter = getFilter(SortLabels.SORT_CASESENSITIVE, ""first-last"");
    testBuffered();
    Instances result = performTest();
    for (int i = 0; i < m_Instances.attribute(2).numValues(); i++)
      assertEquals(""Values differ for index #"" + (i+1), m_Instances.attribute(2).value(i), result.attribute(2).value(i));
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SortLabelsTest.java,weka-master
"public OrdinalToNumericTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/OrdinalToNumericTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();

    Instances result = useFilter();

    assertEquals(m_Instances.numAttributes(), result.numAttributes());

    // check that the two nominal attributes are now numeric
    assertTrue(result.attribute(1).isNumeric());
    assertTrue(result.attribute(4).isNumeric());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/OrdinalToNumericTest.java,weka-master
"public void testNoNominalsInRange() {
    m_Filter = getFilter();
    ((OrdinalToNumeric) m_Filter).setAttributesToOperateOn(""1,3-4,6,last"");
    Instances result = useFilter();

    assertTrue(result.attribute(1).isNominal());
    assertTrue(result.attribute(4).isNominal());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/OrdinalToNumericTest.java,weka-master
public ObfuscateTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/ObfuscateTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    
    assertTrue(!m_Instances.relationName().equals(result.relationName()));
    for (int i = 0; i < m_Instances.numAttributes(); i++) {
      Attribute inatt = m_Instances.attribute(i);
      Attribute outatt = result.attribute(i);
      if (!inatt.isString() && !inatt.isDate()) {
        assertTrue(""Attribute names should be changed"",
               !inatt.name().equals(outatt.name()));
        if (inatt.isNominal()) {
          assertEquals(""Number of nominal values shouldn't change"",
                       inatt.numValues(), outatt.numValues());
          for (int j = 0; j < inatt.numValues(); j++) {
            assertTrue(""Nominal labels should be changed"",
                   !inatt.value(j).equals(outatt.value(j)));
          }
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ObfuscateTest.java,weka-master
"public ClusterMembershipTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ClusterMembershipTest.java,weka-master
"public void testNominal() {
    m_Filter = getFilter();
    m_Instances.setClassIndex(1);
    Instances result = useFilter();
    // classes must be still the same
    assertEquals(m_Instances.numClasses(), result.numClasses());
    // at least one cluster per label besides class
    assertTrue(result.numAttributes() >= m_Instances.numClasses() + 1);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ClusterMembershipTest.java,weka-master
"public void testNumeric() {
    m_Filter = getFilter();
    m_Instances.setClassIndex(2);
    Instances result = useFilter();
    // at least one cluster (only one clusterer is generateed) besides class
    assertTrue(result.numAttributes() >= 1 + 1);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ClusterMembershipTest.java,weka-master
public ReplaceWithMissingValueTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/ReplaceWithMissingValueTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReplaceWithMissingValueTest.java,weka-master
"public KernelFilterTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/KernelFilterTest.java,weka-master
"public void testTypical() {
    Instances icopy = new Instances(m_Instances);
    
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(result.numAttributes(), icopy.numInstances() + 1);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/KernelFilterTest.java,weka-master
"public MergeInfrequentNominalValuesTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeInfrequentNominalValuesTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeInfrequentNominalValuesTest.java,weka-master
"public void testDifferentRange() {
    ((MergeInfrequentNominalValues)m_Filter).setMinimumFrequency(5);
    ((MergeInfrequentNominalValues)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if ((m_Instances.instance(i).value(4) == 1) || 
          (m_Instances.instance(i).value(4) == 2)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(4);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(4));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeInfrequentNominalValuesTest.java,weka-master
"public void testMergeAll() {
    ((MergeInfrequentNominalValues)m_Filter).setMinimumFrequency(100);
    ((MergeInfrequentNominalValues)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    assertEquals(1, result.attribute(1).numValues());
    assertEquals(1, result.attribute(4).numValues());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeInfrequentNominalValuesTest.java,weka-master
"public void testAttributeWithMissing() {
    ((MergeInfrequentNominalValues)m_Filter).setAttributeIndices(""5"");
    ((MergeInfrequentNominalValues)m_Filter).setMinimumFrequency(100);
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the merging is correct
    int mergedIndex = -1;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).isMissing(4)) {
        assertTrue(""Missing in input should give missing in result"",
               result.instance(i).isMissing(4));
      } else if ((m_Instances.instance(i).value(4) == 1) || 
          (m_Instances.instance(i).value(4) == 2)) {
        if (mergedIndex == -1) {
          mergedIndex = (int)result.instance(i).value(4);
        } else {
          assertEquals(""Checking merged value for instance: "" + (i + 1),
                       mergedIndex, (int)result.instance(i).value(4));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeInfrequentNominalValuesTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((MergeInfrequentNominalValues) m_FilteredClassifier.getFilter()).setAttributeIndices(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/MergeInfrequentNominalValuesTest.java,weka-master
public TimeSeriesTranslateTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/TimeSeriesTranslateTest.java,weka-master
"public void testInverted() {
    m_Filter = getFilter(""1,4,2-3"");
    ((TimeSeriesTranslate)m_Filter).setInvertSelection(true);
    Instances result = useFilter();
    // Number of attributes shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances() - 1, result.numInstances());
    // Check conversion looks OK
    for (int i = 0; i < result.numInstances(); i++) {
      Instance in = m_Instances.instance(i + 1);
      Instance out = result.instance(i);
      for (int j = 0; j < result.numAttributes(); j++) {
        if ((j != 4) && (j != 5)&& (j != 6)) {
          if (in.isMissing(j)) {
            assertTrue(""Nonselected missing values should pass through"",
                   out.isMissing(j));
          } else if (result.attribute(j).isString()) {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         m_Instances.attribute(j).value((int)in.value(j)),
                         result.attribute(j).value((int)out.value(j)));
          } else {
            assertEquals(""Nonselected attributes shouldn't change. ""
                         + in + "" --> "" + out,
                         in.value(j),
                         out.value(j), TOLERANCE);
          }
        }
      }
    }    
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/TimeSeriesTranslateTest.java,weka-master
"public DateToNumericTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DateToNumericTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // no date attributes should remain
    if (result.checkForAttributeType(Attribute.DATE))
      fail(""Date attribute(s) left over!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/DateToNumericTest.java,weka-master
public StandardizeTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/StandardizeTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());

    // Check conversion is OK
    for (int j = 0; j < result.numAttributes(); j++) {
      if (result.attribute(j).isNumeric()) {
	double mean = result.meanOrMode(j);
	assertTrue(""Mean should be 0"", Utils.eq(mean, 0));
	double stdDev = Math.sqrt(result.variance(j));
	assertTrue(""StdDev should be 1 (or 0)"", 
		   Utils.eq(stdDev, 0) || Utils.eq(stdDev, 1));
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/StandardizeTest.java,weka-master
public SwapValuesTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/SwapValuesTest.java,weka-master
"public void testInvalidAttributeTypes() {
    Instances icopy = new Instances(m_Instances);
    try {
      ((SwapValues)m_Filter).setAttributeIndex(""1"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception selecting a STRING attribute!"");
    } catch (Exception ex) {
      // OK
    }
    try {
      ((SwapValues)m_Filter).setAttributeIndex(""3"");
      m_Filter.setInputFormat(icopy);
      fail(""Should have thrown an exception indicating a NUMERIC attribute!"");
    } catch (Exception ex) {
      // OK
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SwapValuesTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the swapping is correct
    int first = 0, second = 2;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).value(1) == first) {
        assertTrue(""Value should be swapped"", result.instance(i).value(1) == second);
      } else if (m_Instances.instance(i).value(1) == second) {
        assertTrue(""Value should be swapped"", result.instance(i).value(1) == first);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SwapValuesTest.java,weka-master
"public void testFirstValueIndex() {
    ((SwapValues)m_Filter).setFirstValueIndex(""2"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the swapping is correct
    int first = 1, second = 2;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).value(1) == first) {
        assertTrue(""Value should be swapped"", result.instance(i).value(1) == second);
      } else if (m_Instances.instance(i).value(1) == second) {
        assertTrue(""Value should be swapped"", result.instance(i).value(1) == first);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SwapValuesTest.java,weka-master
"public void testSecondValueIndex() {
    ((SwapValues)m_Filter).setSecondValueIndex(""2"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the swapping is correct
    int first = 0, second = 1;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).value(1) == first) {
        assertTrue(""Value should be swapped"", result.instance(i).value(1) == second);
      } else if (m_Instances.instance(i).value(1) == second) {
        assertTrue(""Value should be swapped"", result.instance(i).value(1) == first);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SwapValuesTest.java,weka-master
"public void testAttributeWithMissing() {
    ((SwapValues)m_Filter).setAttributeIndex(""5"");
    ((SwapValues)m_Filter).setFirstValueIndex(""1"");
    ((SwapValues)m_Filter).setSecondValueIndex(""2"");
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());
    // Check that the swapping is correct
    int first = 0, second = 1;
    for (int i = 0; i < result.numInstances(); i++) {
      if (m_Instances.instance(i).isMissing(4)) {
        assertTrue(""Missing in input should give missing in result:"" 
               + m_Instances.instance(i) + "" --> ""
               + result.instance(i),
               result.instance(i).isMissing(4));
      } else if (m_Instances.instance(i).value(4) == first) {
        assertTrue(""Value should be swapped"", result.instance(i).value(4) == second);
      } else if (m_Instances.instance(i).value(4) == second) {
        assertTrue(""Value should be swapped"", result.instance(i).value(4) == first);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SwapValuesTest.java,weka-master
"public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
	if (data.classIndex() == i)
	  continue;
	if (data.attribute(i).isNominal()) {
	  ((SwapValues) m_FilteredClassifier.getFilter()).setAttributeIndex(
	      """" + (i + 1));
	  break;
	}
      }
    }
    catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }
    
    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/SwapValuesTest.java,weka-master
public NormalizeTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/NormalizeTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(),  result.numInstances());

    // Check conversion is OK
    for (int j = 0; j < result.numAttributes(); j++) {
      if (result.attribute(j).isNumeric()) {
        for (int i = 0; i < result.numInstances(); i++) {
          if (!result.instance(i).isMissing(j)) {
            assertTrue(""Value should be between 0 and 1"",
                   (result.instance(i).value(j) >= 0) &&
                   (result.instance(i).value(j) <= 1));
          }
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NormalizeTest.java,weka-master
public ReplaceMissingValuesTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/ReplaceMissingValuesTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    for (int j = 0; j < m_Instances.numAttributes(); j++) {
      Attribute inatt = m_Instances.attribute(j);
      Attribute outatt = result.attribute(j);
      for (int i = 0; i < m_Instances.numInstances(); i++) {
        if (m_Instances.attribute(j).isString()) {
          if (m_Instances.instance(i).isMissing(j)) {
            assertTrue(""Missing values in strings cannot be replaced"",
                   result.instance(i).isMissing(j));
          } else {
            assertEquals(""String values should not have changed"",
                         inatt.value((int)m_Instances.instance(i).value(j)),
                         outatt.value((int)result.instance(i).value(j)));
          }
        } else {
          assertTrue(""All non-string missing values should have been replaced"",
                 !result.instance(i).isMissing(j));
        }
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/ReplaceMissingValuesTest.java,weka-master
"public NumericToNominalTest(String name) { 
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToNominalTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // no date and numeric attributes should remain
    if (result.checkForAttributeType(Attribute.DATE))
      fail(""Date attribute(s) left over!"");
    if (result.checkForAttributeType(Attribute.NUMERIC))
      fail(""Numeric attribute(s) left over!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToNominalTest.java,weka-master
"public NumericToDateTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToDateTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
    // no numeric attributes should remain
    if (result.checkForAttributeType(Attribute.NUMERIC))
      fail(""Numeric attribute(s) left over!"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/NumericToDateTest.java,weka-master
public FirstOrderTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/FirstOrderTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter(""6,3"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes() - 1, result.numAttributes());
    for (int i = 0; i < result.numInstances(); i++) {
      Instance orig = m_Instances.instance(i);
      if (orig.isMissing(5) || orig.isMissing(2)) {
        assertTrue(""Instance "" + (i + 1) + "" should have been ?"" , 
               result.instance(i).isMissing(4));
      } else {
        assertEquals(orig.value(5) - orig.value(2), 
                     result.instance(i).value(4), 
                     EXPR_DELTA);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/FirstOrderTest.java,weka-master
"public void testTypical2() {
    m_Filter = getFilter(""3,6"");
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes() - 1, result.numAttributes());
    for (int i = 0; i < result.numInstances(); i++) {
      Instance orig = m_Instances.instance(i);
      if (orig.isMissing(5) || orig.isMissing(2)) {
        assertTrue(""Instance "" + (i + 1) + "" should have been ?"" , 
               result.instance(i).isMissing(4));
      } else {
        assertEquals(orig.value(5) - orig.value(2), 
                     result.instance(i).value(4), 
                     EXPR_DELTA);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/FirstOrderTest.java,weka-master
"public AddUserFieldsTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddUserFieldsTest.java,weka-master
"protected void performTest() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(icopy.numInstances(), result.numInstances());
    assertEquals(icopy.numAttributes() + 4, result.numAttributes());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddUserFieldsTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    performTest();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddUserFieldsTest.java,weka-master
public AddExpressionTest(String name) { super(name);  },./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testAdd() {
    m_Filter = getFilter(""a3+a6"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   inst.value(2) + inst.value(5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testSubtract() {
    m_Filter = getFilter(""a3-a6"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   inst.value(2) - inst.value(5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testMultiply() {
    m_Filter = getFilter(""a3*a6"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   inst.value(2) * inst.value(5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testDivide() {
    m_Filter = getFilter(""a3/a6"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
          inst.value(2) / inst.value(5), 
          inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testExponent() {
    m_Filter = getFilter(""a3^a6"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.pow(inst.value(2), inst.value(5)), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testLog() {
    m_Filter = getFilter(""log(a6/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      if (inst.value(5) != 0) {
        assertEquals(""Instance "" + (i + 1),
                     Math.log(inst.value(5)/5), 
                     inst.value(inst.numAttributes() - 1), EXPR_DELTA);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testCos() {
    m_Filter = getFilter(""cos(a6/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.cos(inst.value(5) / 5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testSin() {
    m_Filter = getFilter(""sin(a6/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.sin(inst.value(5) / 5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testTan() {
    m_Filter = getFilter(""tan(a6/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1) + "": "" + inst + ""\n"",
                   Math.tan(inst.value(5) / 5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testAbs() {
    m_Filter = getFilter(""abs(a6-a3)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.abs(inst.value(5) - inst.value(2)), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testExp() {
    m_Filter = getFilter(""exp(a6-a3)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.exp(inst.value(5) - inst.value(2)), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testSqrt() {
    m_Filter = getFilter(""sqrt(a6+a3/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.sqrt(inst.value(5) + inst.value(2)/5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testFloor() {
    m_Filter = getFilter(""floor(a6+a3/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.floor(inst.value(5) + inst.value(2)/5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testCeil() {
    m_Filter = getFilter(""ceil(a6*a3/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.ceil(inst.value(5) * inst.value(2)/5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testRint() {
    m_Filter = getFilter(""rint(a6*a3/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      assertEquals(""Instance "" + (i + 1),
                   Math.rint(inst.value(5) * inst.value(2)/5), 
                   inst.value(inst.numAttributes() - 1), EXPR_DELTA);
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testBracketing() {
    m_Filter = getFilter(""(a3+a6)*((a6-a3)/5)"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      if (inst.isMissing(2) || inst.isMissing(5)) {
        assertTrue(""Instance "" + (i + 1) + "" should have been ?"" , 
               inst.isMissing(inst.numAttributes() - 1));
      } else {
        assertEquals(""Instance "" + (i + 1),
                     (inst.value(2) + inst.value(5)) * 
                     ((inst.value(5) - inst.value(2))/5), 
                     inst.value(inst.numAttributes() - 1), EXPR_DELTA);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testBODMAS() {
    m_Filter = getFilter(""a3+a3*a6-a3/5+a3*a6+a6"");
    Instances result = useFilter();
    for (int i = 0; i < result.numInstances(); i++) {
      Instance inst = result.instance(i);
      if (inst.isMissing(2) || inst.isMissing(5)) {
        assertTrue(""Instance "" + (i + 1) + "" should have been ?"" , 
               inst.isMissing(inst.numAttributes() - 1));
      } else {
        assertEquals(""Instance "" + (i + 1),
                     inst.value(2) + 
                     (inst.value(2) * inst.value(5)) 
                     - (inst.value(2)/5)
                     + (inst.value(2) * inst.value(5))
                     + inst.value(5), 
                     inst.value(inst.numAttributes() - 1), EXPR_DELTA);
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public void testAddNamed() {
    m_Filter = getFilter(""a3+a6"");
    String name = ""BongoBongo"";
    ((AddExpression)m_Filter).setName(name);
    Instances result = useFilter();
    assertEquals(name, result.attribute(result.numAttributes() - 1).name());
    name = ""BongoBongoSecond"";
    ((AddExpression)m_Filter).setName(name);
    result = useFilter();
    assertEquals(name, result.attribute(result.numAttributes() - 1).name());
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/AddExpressionTest.java,weka-master
"public RenameNominalValuesTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameNominalValuesTest.java,weka-master
"public void testNoSelectedAttsNoReplaceSpec() {
    m_Filter = getFilter();
    ((RenameNominalValues) m_Filter).setSelectedAttributes("""");
    ((RenameNominalValues) m_Filter).setValueReplacements("""");

    Instances result = useFilter();
    assertEquals(m_Instances.numInstances(), result.numInstances());
    assertEquals(m_Instances.numAttributes(), result.numAttributes());

    // all instances should be unchanged
    for (int i = 0; i < result.numInstances(); i++) {
      Instance orig = m_Instances.instance(i);
      Instance filtered = result.instance(i);

      for (int j = 0; j < orig.numAttributes(); j++) {
        assertEquals(orig.value(j), filtered.value(j));
      }
    }
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameNominalValuesTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();

    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());

    // shouldn't be any 'b' values in the header - they should now
    // be 'bob'
    Attribute first = result.attribute(1);
    Attribute second = result.attribute(4);

    assertEquals(first.value(2), ""bob"");
    assertEquals(second.value(1), ""bob"");

    // check an instance
    Instance inst = result.instance(1);
    assertEquals(inst.stringValue(1), ""bob"");
    assertEquals(inst.stringValue(4), ""bob"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameNominalValuesTest.java,weka-master
"public void testTypical2() {
    m_Filter = getFilter(""2"", ""b:bob"");
    Instances result = useFilter();

    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());

    // shouldn't be any 'b' values in the header for attribute 2
    // - they should now be 'bob'
    Attribute first = result.attribute(1);
    Attribute second = result.attribute(4);

    assertEquals(first.value(2), ""bob"");

    // check that the other nominal attribute is unchanged
    assertEquals(second.value(1), ""b"");

    // check an instance
    Instance inst = result.instance(1);
    assertEquals(inst.stringValue(1), ""bob"");
    assertEquals(inst.stringValue(4), ""b"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameNominalValuesTest.java,weka-master
"public void testInverted1() {
    m_Filter = getFilter("""", ""b:bob"");
    ((RenameNominalValues) m_Filter).setInvertSelection(true);

    Instances result = useFilter();

    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());

    // shouldn't be any 'b' values in the header - they should now
    // be 'bob'
    Attribute first = result.attribute(1);
    Attribute second = result.attribute(4);

    assertEquals(first.value(2), ""bob"");
    assertEquals(second.value(1), ""bob"");

    // check an instance
    Instance inst = result.instance(1);
    assertEquals(inst.stringValue(1), ""bob"");
    assertEquals(inst.stringValue(4), ""bob"");
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameNominalValuesTest.java,weka-master
"@Override
  public void testFilteredClassifier() {
    try {
      Instances data = getFilteredClassifierData();

      for (int i = 0; i < data.numAttributes(); i++) {
        if (data.classIndex() == i)
          continue;
        if (data.attribute(i).isNominal()) {
          ((RenameNominalValues) m_FilteredClassifier.getFilter())
              .setSelectedAttributes("""" + (i + 1));
          break;
        }
      }
    } catch (Exception e) {
      fail(""Problem setting up test for FilteredClassifier: "" + e.toString());
    }

    super.testFilteredClassifier();
  }",./weka/src/test/java/weka/filters/unsupervised/attribute/RenameNominalValuesTest.java,weka-master
public AllFilterTest(String name) { super(name);  },./weka/src/test/java/weka/filters/AllFilterTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./weka/src/test/java/weka/filters/AllFilterTest.java,weka-master
"public AbstractClusterDefinitionTest(String name) { 
    super(name); 
  }",./weka/src/test/java/weka/datagenerators/AbstractClusterDefinitionTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE		result;
    
    result = new CheckGOE();
    result.setObject(getDefinition());
    result.setSilent(true);
    
    return result;
  }",./weka/src/test/java/weka/datagenerators/AbstractClusterDefinitionTest.java,weka-master
"public void testOptions() {
    try {
      m_Definition.setOptions(m_Definition.getOptions());
    }
    catch (Exception e) {
      fail(""setOptions(getOptions()) does not work: "" + e.getMessage());
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractClusterDefinitionTest.java,weka-master
"public void testSerialVersionUID() {
    if (SerializationHelper.needsUID(m_Definition.getClass()))
      fail(""Doesn't declare serialVersionUID!"");
  }",./weka/src/test/java/weka/datagenerators/AbstractClusterDefinitionTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo())
      fail(""No globalInfo method"");
  }",./weka/src/test/java/weka/datagenerators/AbstractClusterDefinitionTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips())
      fail(""Tool tips inconsistent"");
  }",./weka/src/test/java/weka/datagenerators/AbstractClusterDefinitionTest.java,weka-master
"public SubspaceClusterTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/clusterers/SubspaceClusterTest.java,weka-master
"public SubspaceClusterDefinitionTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/clusterers/SubspaceClusterDefinitionTest.java,weka-master
"public BIRCHClusterTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/clusterers/BIRCHClusterTest.java,weka-master
"public ExpressionTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/classifiers/regression/ExpressionTest.java,weka-master
"public MexicanHatTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/classifiers/regression/MexicanHatTest.java,weka-master
"public BayesNetTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/classifiers/classification/BayesNetTest.java,weka-master
"public AgrawalTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/classifiers/classification/AgrawalTest.java,weka-master
"public RandomRBFTest(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/classifiers/classification/RandomRBFTest.java,weka-master
"public LED24Test(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/classifiers/classification/LED24Test.java,weka-master
"public RDG1Test(String name) { 
    super(name);  
  }",./weka/src/test/java/weka/datagenerators/classifiers/classification/RDG1Test.java,weka-master
"public AbstractDataGeneratorTest(String name) {
    super(name);
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler result;

    result = new CheckOptionHandler();
    result.setOptionHandler(getGenerator());
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE result;

    result = new CheckGOE();
    result.setObject(getGenerator());
    result.setIgnoredProperties(result.getIgnoredProperties()
      + "",datasetFormat"");
    result.setSilent(true);

    return result;
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testOptions() {
    try {
      m_Generator.setOptions(m_Generator.getOptions());
    } catch (Exception e) {
      fail(""setOptions(getOptions()) does not work: "" + e.getMessage());
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testMakeData() {
    try {
      DataGenerator.makeData(m_Generator, new String[0]);
    } catch (Exception e) {
      fail(""Generation of data failed: "" + e.getMessage());
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testSerialVersionUID() {
    if (SerializationHelper.needsUID(m_Generator.getClass())) {
      fail(""Doesn't declare serialVersionUID!"");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testListOptions() {
    if (!m_OptionTester.checkListOptions()) {
      fail(""Options cannot be listed via listOptions."");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testSetOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""setOptions method failed."");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testDefaultOptions() {
    if (!m_OptionTester.checkDefaultOptions()) {
      fail(""Default options were not processed correctly."");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testRemainingOptions() {
    if (!m_OptionTester.checkRemainingOptions()) {
      fail(""There were 'left-over' options."");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (!m_OptionTester.checkCanonicalUserOptions()) {
      fail(""setOptions method failed"");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testResettingOptions() {
    if (!m_OptionTester.checkSetOptions()) {
      fail(""Resetting of options failed"");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo()) {
      fail(""No globalInfo method"");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips()) {
      fail(""Tool tips inconsistent"");
    }
  }",./weka/src/test/java/weka/datagenerators/AbstractDataGeneratorTest.java,weka-master
"protected static String getTestClassname(String classname) {
    if (!classname.endsWith(""Test"")) {
      return classname + ""Test"";
    } else {
      return classname;
    }
  }",./weka/src/test/java/weka/test/WekaTestSuite.java,weka-master
"protected static Class<?> testClassFor(String classname) {
    Class<?> result;

    result = null;

    try {
      result = Class.forName(getTestClassname(classname));
    } catch (Exception e) {
      // ignore it
    }

    return result;
  }",./weka/src/test/java/weka/test/WekaTestSuite.java,weka-master
"public QDATest(String name) {
    super(name);  
  }",./packages/internal/discriminantAnalysis/src/test/java/weka/classifiers/functions/QDATest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier 	result;
    
    result = super.getTester();
    result.setNumInstances(40);
    
    return result;
  }",./packages/internal/discriminantAnalysis/src/test/java/weka/classifiers/functions/QDATest.java,weka-master
"public LDATest(String name) {
    super(name);  
  }",./packages/internal/discriminantAnalysis/src/test/java/weka/classifiers/functions/LDATest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier 	result;
    
    result = super.getTester();
    result.setNumInstances(40);
    
    return result;
  }",./packages/internal/discriminantAnalysis/src/test/java/weka/classifiers/functions/LDATest.java,weka-master
"public FLDATest(String name) { 
    super(name);  
  }",./packages/internal/discriminantAnalysis/src/test/java/weka/classifiers/functions/FLDATest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier 	result;
    
    result = super.getTester();
    result.setNumInstances(40);
    
    return result;
  }",./packages/internal/discriminantAnalysis/src/test/java/weka/classifiers/functions/FLDATest.java,weka-master
"@Test
  public void testNonRegexOneRule() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@quick@@MR@@slow"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(0).contains(""slow""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    System.err.println(secondTransformed);
    assertTrue(secondTransformed.stringValue(0).contains(""slow""));
  }",./packages/internal/distributedWekaSpark2Dev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexOneRuleTwoAtts() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""second@@MR@@f@@MR@@t@@MR@@dog@@MR@@fish"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test2);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(1).contains(""fish""));
    assertFalse(firstTransformed.stringValue(0).contains(""fish""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    assertFalse(secondTransformed.stringValue(0).contains(""fish""));
    assertFalse(secondTransformed.stringValue(1).contains(""fish""));
  }",./packages/internal/distributedWekaSpark2Dev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexTwoRules() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@quick@@MR@@slow"",
        ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@turnip@@MR@@carrot"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(0).contains(""slow""));
    assertFalse(firstTransformed.stringValue(0).contains(""carrot""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    System.err.println(secondTransformed);
    assertTrue(secondTransformed.stringValue(0).contains(""slow""));
    assertTrue(secondTransformed.stringValue(0).contains(""carrot""));
  }",./packages/internal/distributedWekaSpark2Dev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexCaseSensitiveOneRule() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@f@@MR@@quick@@MR@@Slow"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertFalse(firstTransformed.stringValue(0).contains(""slow""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    System.err.println(secondTransformed);
    assertFalse(secondTransformed.stringValue(0).contains(""slow""));
  }",./packages/internal/distributedWekaSpark2Dev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testRegexOneRule() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts = { ""-match-rule"", ""first@@MR@@t@@MR@@t@@MR@@dog$@@MR@@cat"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(0).contains(""lazy cat""));
    assertTrue(firstTransformed.stringValue(0).contains(""brown dog""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    assertFalse(secondTransformed.stringValue(0).contains(""cat""));
  }",./packages/internal/distributedWekaSpark2Dev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexOneRule() throws Exception {
    SubstringLabeler labeler = new SubstringLabeler();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@quick@@MR@@class1"" };
    labeler.setOptions(opts);
    Instances data = getData(s_test1);
    labeler.setInputFormat(data);

    Instances outFormat = labeler.getOutputFormat();
    assertTrue(outFormat != null);
    assertEquals(2, outFormat.numAttributes());
    assertEquals(1, outFormat.classIndex());
    assertTrue(outFormat.classAttribute().isNominal());
    assertEquals(1, outFormat.classAttribute().numValues());
    assertEquals(""class1"", outFormat.classAttribute().value(0));

    labeler.input(data.instance(0));
    Instance firstTransformed = labeler.output();
    assertFalse(firstTransformed.classIsMissing());

    labeler.input(data.instance(1));
    assertFalse(labeler.output().classIsMissing());
    labeler.input(data.instance(2));
    assertFalse(labeler.output().classIsMissing());
  }",./packages/internal/distributedWekaSpark2Dev/src/test/java/weka/filters/unsupervised/attribute/SubstringLabelerTest.java,weka-master
"@Test
  public void testNonRegexTwoRules() throws Exception {
    SubstringLabeler labeler = new SubstringLabeler();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@dog@@MR@@class1"",
      ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@snail@@MR@@class2""};
    labeler.setOptions(opts);
    Instances data = getData(s_test1);
    labeler.setInputFormat(data);

    Instances outFormat = labeler.getOutputFormat();
    assertTrue(outFormat != null);
    assertEquals(2, outFormat.numAttributes());
    assertEquals(1, outFormat.classIndex());
    assertTrue(outFormat.classAttribute().isNominal());
    assertEquals(2, outFormat.classAttribute().numValues());
    Assert.assertEquals(""class1"", outFormat.classAttribute().value(0));

    labeler.input(data.instance(0));
    Instance firstTransformed = labeler.output();
    assertFalse(firstTransformed.classIsMissing());
    assertEquals(""class1"", firstTransformed.stringValue(1));

    labeler.input(data.instance(1));
    Instance secondTransformed = labeler.output();
    assertFalse(secondTransformed.classIsMissing());
    assertEquals(""class2"", secondTransformed.stringValue(1));

  }",./packages/internal/distributedWekaSpark2Dev/src/test/java/weka/filters/unsupervised/attribute/SubstringLabelerTest.java,weka-master
"public DaggingTest(String name) { 
    super(name);  
  }",./packages/internal/dagging/src/test/java/weka/classifiers/meta/DaggingTest.java,weka-master
public DTNBTest(String name) { super(name);  },./packages/internal/DTNB/src/test/java/weka/classifiers/rules/DTNBTest.java,weka-master
"public CascadeGeneralizationTest(String name) { 
    super(name);  
  }",./packages/internal/probabilityCalibrationTrees/src/test/java/weka/classifiers/meta/CascadeGeneralizationTest.java,weka-master
"public PCTTest(String name) { 
    super(name);  
  }",./packages/internal/probabilityCalibrationTrees/src/test/java/weka/classifiers/trees/PCTTest.java,weka-master
"public SAXTransformerTest(String name) {
    super(name);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/SAXTransformerTest.java,weka-master
"public void testNumerics() throws Exception {
    checkEquivalence(getNumericsDataset10x20(),
        apply(getNumericsDataset(), getFilter(10, 20, ""1"")), ""1"");
    checkEquivalence(getNumericsDataset10x4(),
        apply(getNumericsDataset(), getFilter(10, 4, ""1"")), ""1"");
    checkEquivalence(getNumericsDataset7x20(),
        apply(getNumericsDataset(), getFilter(7, 20, ""1"")), ""1"");
    checkEquivalence(getNumericsDataset7x4(),
        apply(getNumericsDataset(), getFilter(7, 4, ""1"")), ""1"");
    
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/SAXTransformerTest.java,weka-master
"public void testSimpleDataset() throws Exception {
    int[] ws = {1, 10, 7, 6};
    String[] ranges = {"""", ""3"", ""5"", ""3,5""};
    int[] as = {4, 20, 10, 26*26*26 + 1};
    for (int w : ws)
      for (String range : ranges)
        for (int a : as)
          doSimpleDatasetTest(w, a, range);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/SAXTransformerTest.java,weka-master
"private void doSimpleDatasetTest(int w, int a, String range) throws Exception {
    m_Instances = getSimpleDataset();
    m_Filter = getFilter(w, a, range);
    testBuffered();
    m_Instances = getSimpleDataset();
    m_Filter = getFilter(w, a, range);
    testIncremental();
    m_Instances = getSimpleDataset();
    m_Filter = getFilter(w, a, range);
    testThroughput();
    m_Instances = getSimpleDataset();
    checkBasicProperties(m_Instances, apply(m_Instances, getFilter(w, a, range)), range);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/SAXTransformerTest.java,weka-master
"public PAATransformerTest(String name) {
    super(name);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/PAATransformerTest.java,weka-master
"public void testNumerics() throws Exception {
    Instances output10 = apply(getNumericsDataset(), getFilter(10, ""1""));
    Instances output7 = apply(getNumericsDataset(), getFilter(7, ""1""));
    
    checkNumericSimilarity(getNumericsDataset10(), output10, ""1"");
    checkNumericSimilarity(getNumericsDataset7(), output7, ""1"");

  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/PAATransformerTest.java,weka-master
"public void testWeightedCase() throws Exception {
    Instances test = new Instances(new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream(""weka/filters/unsupervised/timeseries/data/PAAweightsTest.arff""))));
    Instances reference = new Instances(new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream(""weka/filters/unsupervised/timeseries/data/PAAweightsTest.ref""))));
    
    Instances out = apply(test, getFilter(7, ""1""));
    checkNumericSimilarity(reference, out, ""1"");
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/PAATransformerTest.java,weka-master
"public void testSimpleDataset() throws Exception {
    int[] ws = {1, 10, 7, 6};
    String[] ranges = {"""", ""3"", ""5"", ""3,5""};
    for (int w : ws)
      for (String range : ranges)
        doSimpleDatasetTest(w, range);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/PAATransformerTest.java,weka-master
"private void doSimpleDatasetTest(int w, String range) throws Exception {
    m_Instances = getSimpleDataset();
    m_Filter = getFilter(w, range);
    testBuffered();
    m_Instances = getSimpleDataset();
    m_Filter = getFilter(w, range);
    testIncremental();
    m_Instances = getSimpleDataset();
    m_Filter = getFilter(w, range);
    testThroughput();
    m_Instances = getSimpleDataset();
    checkBasicProperties(m_Instances, apply(m_Instances, getFilter(w, range)), range);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/PAATransformerTest.java,weka-master
"public FlatToRelationalTest(String name) {
    super(name);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/FlatToRelationalTest.java,weka-master
"public void testProcess() throws Exception {
    Instances[] datasets =
        new Instances[] {
          makeTestDataset(0, 100, 100, 0, 0, 0, 0, 2, Attribute.NOMINAL, 100),
          makeTestDataset(0, 100, 0, 100, 0, 0, 0, 2, Attribute.NOMINAL, 100),
          makeTestDataset(0, 100, 0, 0, 100, 0, 0, 2, Attribute.NOMINAL, 100),
          makeTestDataset(0, 100, 0, 0, 0, 100, 0, 2, Attribute.NOMINAL, 100),
        };
    for (Instances insts : datasets) {
      final FlatToRelational filter = getFilter(""1-100"", 5, true);
      filter.setInputFormat(insts);
      final Instances filteredData = Filter.useFilter(insts, filter);

      // Attribute number should be reduced to 2 (one bag and one class)
      assertEquals(2, filteredData.numAttributes());
      // Check if first attribute is relation valued
      assertTrue(filteredData.attribute(0).isRelationValued());
      // Check if first attributes relation has five attributes
      assertEquals(5, filteredData.attribute(0).relation().numAttributes());
      // Check if data size is still the same
      assertEquals(insts.numInstances(), filteredData.numInstances());
    }
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/FlatToRelationalTest.java,weka-master
"public void testMultipleAttributeTypes() throws Exception {
    Attribute att1 = new Attribute(""numeric1"");
    Attribute att2 = new Attribute(""nominal1"", Arrays.asList(""val1"", ""val2""));
    Attribute att3 = att1.copy(""numeric2"");
    Attribute att4 = att2.copy(""nominal2"");
    ArrayList<Attribute> atts = new ArrayList<>(Arrays.asList(att1, att2, att3, att4));
    Instances insts = new Instances(""test"", atts, 0);

    // Generate 100 test instances
    for (int i = 0; i < 100; i++) {
      Instance inst = new DenseInstance(4);
      inst.setDataset(insts);
      inst.setValue(0, Math.random());
      inst.setValue(1, ""val1"");
      inst.setValue(2, Math.random());
      inst.setValue(3, ""val2"");
      insts.add(inst);
    }
    final FlatToRelational filter = getFilter(""1-4"", 2, true);
    filter.setInputFormat(insts);
    final Instances filteredData = Filter.useFilter(insts, filter);
    // Attribute number should be reduced to 1 (one bag)
    assertEquals(1, filteredData.numAttributes());
    // Check if first attribute is relation valued
    assertTrue(filteredData.attribute(0).isRelationValued());
    // Check if first attributes relation has 2 attributes
    assertEquals(2, filteredData.attribute(0).relation().numAttributes());
    // Check if data size is still the same
    assertEquals(insts.numInstances(), filteredData.numInstances());
    // Check if first attribute of relation is numeric
    assertEquals(Attribute.NUMERIC, filteredData.attribute(0).relation().attribute(0).type());
    assertEquals(Attribute.NOMINAL, filteredData.attribute(0).relation().attribute(1).type());
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/FlatToRelationalTest.java,weka-master
"public static Instances makeTestDataset(
      int seed,
      int numInstances,
      int numNominal,
      int numNumeric,
      int numString,
      int numDate,
      int numRelational,
      int numClasses,
      int classType,
      int classIndex)
      throws Exception {

    ArrayList<Attribute> attributes = new ArrayList<>();

    final List<String> nominalValues = Arrays.asList(""val1"", ""val2"");
    Attribute att = new Attribute(""nominal"", nominalValues);
    for (int i = 0; i < numNominal; i++) {
      attributes.add(att.copy(att.name() + i));
    }

    att = new Attribute(""numeric"");
    for (int i = 0; i < numNumeric; i++) {
      attributes.add(att.copy(att.name() + i));
    }

    att = new Attribute(""string"", true);
    for (int i = 0; i < numString; i++) {
      attributes.add(att.copy(att.name() + i));
    }

    att = new Attribute(""date"", ""yyyy"");
    for (int i = 0; i < numDate; i++) {

      attributes.add(att.copy(att.name() + i));
    }

    Attribute cls =
        new Attribute(
            ""class"",
            IntStream.range(0, numClasses).mapToObj(i -> ""class"" + i).collect(Collectors.toList()));
    attributes.add(cls);
    Random rand = new Random(seed);
    String[] randString = ""l k ; r j i e a j ; l s k d n c x c e i u r k n ; a"".split("" "");
    String[] randDates = {""2000"", ""2001"", ""2002""};
    Instances data = new Instances(""data"", attributes, numInstances);
    data.setClassIndex(attributes.indexOf(cls));
    for (int i = 0; i < numInstances; i++) {
      Instance inst = new DenseInstance(attributes.size());
      inst.setDataset(data);
      int j = 0;
      int offset = 0;
      for (; j < numNominal + offset; j++) {
        inst.setValue(j, nominalValues.get(rand.nextInt(nominalValues.size())));
      }
      offset += numNominal;

      for (; j < numNumeric + offset; j++) {
        inst.setValue(j, rand.nextDouble());
      }
      offset += numNumeric;

      for (; j < numString + offset; j++) {
        inst.setValue(j, randString[rand.nextInt(randString.length)]);
      }
      offset += numString;
      for (; j < numDate + offset; j++) {
        inst.setValue(j, attributes.get(j).parseDate(randDates[rand.nextInt(randDates.length)]));
      }
      data.add(inst);
    }

    return data;
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/FlatToRelationalTest.java,weka-master
"public void testKeepOtherAttributes() throws Exception {
    final Instances data = makeTestDataset(0, 100, 100, 10, 0, 0, 0, 2, Attribute.NOMINAL, 110);
     FlatToRelational filter = getFilter(""1-100"", 5, true);
    filter.setInputFormat(data);
    Instances filteredData = Filter.useFilter(data, filter);
    // 1 bag + 10 numeric + 1 class
    assertEquals(1 + 10 + 1, filteredData.numAttributes());
    for (int i = 1; i < 11; i++) {
      assertEquals(Attribute.NUMERIC, filteredData.attribute(i).type());
    }

    filter = getFilter(""1-100"", 5, false);
    filter.setInputFormat(data);
    filteredData = Filter.useFilter(data, filter);
    // 1 bag  + 1 class
    assertEquals(1 + 1, filteredData.numAttributes());
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/FlatToRelationalTest.java,weka-master
"public void testInvalidInput() throws Exception {
    Instances generated = makeTestDataset(0, 100, 0, 10, 0, 0, 0, 2, Attribute.NOMINAL, 10);

    FlatToRelational filter = getFilter(""1-9"", 2, true);
    try {
      filter.setInputFormat(generated);
      Filter.useFilter(generated, filter);
      fail(
          ""9 attributes have been selected while the number of timeseries variables ""
              + ""was 2. 9 mod 2 != 0. Exception expected."");
    } catch (WekaException we) {
      // All good
    }

    filter = getFilter(""1-10"", 2, true);
    generated = makeTestDataset(0, 100, 4, 4, 4, 4, 4, 2, Attribute.NOMINAL, 20);
    try {
      filter.setInputFormat(generated);
      Filter.useFilter(generated, filter);
      fail(""The attributes types do not match in the given range. Exception expected."");
    } catch (WekaException we) {
      // All good
    }

    filter = getFilter(""1-10"", -1, true);
    generated = makeTestDataset(0, 100, 4, 4, 4, 4, 4, 2, Attribute.NOMINAL, 20);
    try {
      filter.setInputFormat(generated);
      Filter.useFilter(generated, filter);
      fail(""The number of variables was set to -1. Exception expected."");
    } catch (WekaException we) {
      // All good
    }
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/FlatToRelationalTest.java,weka-master
"public OneDimensionalTimeSeriesToStringTest(String name) {
    super(name);
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/OneDimensionalTimeSeriesToStringTest.java,weka-master
"public void testSimpleConversions() throws Exception {
    checkEquivalence(getReferenceSet1(), apply(getTestSet1(), getFilter(""1"")));
    checkEquivalence(getReferenceSet2(), apply(getTestSet2(), getFilter(""1"")));
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/OneDimensionalTimeSeriesToStringTest.java,weka-master
"public void testGenericConversions() throws Exception {
    Instances reference = getGenericReferenceSet();
    Instances test = apply(getGenericSet(), getFilter(""3""));
    
    final int timeSeriesIndex = 2;
    
    assertEquals(""Incorrect amount of attribute"",
        reference.numAttributes(), test.numAttributes());
    assertEquals(""Incorrect amount of instances"",
        reference.numInstances(), test.numInstances());

        
    for (int att = 0; att < reference.numAttributes(); att++) {
      if (att == timeSeriesIndex) {
        // check time series
        assertTrue(""Time series wasn't converted to String"",
            test.attribute(att).isString());
      }
    }

    for (int i = 0; i < reference.numInstances(); i++) {
      for (int att = 0; att < reference.numAttributes(); att++) {
        
        // non-time series simply must have the same value
        if (att != timeSeriesIndex) {
          assertEquals(
              ""Incorrect value in instance "" + i + "" at Attribute #"" + (att + 1) + ""!"",
              reference.get(i).value(att), test.get(i).value(att)
              );
          continue;
        }
        
        assertEquals(""Incorrect output string"",
            reference.get(i).stringValue(att), test.get(i).stringValue(att));
      }
    }
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/OneDimensionalTimeSeriesToStringTest.java,weka-master
"private Instances getTestSet1() throws IOException {
    return new Instances(new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream(""weka/filters/unsupervised/timeseries/data/NumericTimeSeriesSAX10x20.ref""))));
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/OneDimensionalTimeSeriesToStringTest.java,weka-master
"private Instances getTestSet2() throws IOException {
    return new Instances(new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream(""weka/filters/unsupervised/timeseries/data/NumericTimeSeriesSAX7x4.ref""))));
  }",./packages/internal/timeSeriesFilters/src/test/java/weka/filters/unsupervised/timeseries/OneDimensionalTimeSeriesToStringTest.java,weka-master
"@Test
  public void testSimpleBatchClassifierTraining() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupBatchClassifier();

    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }

    // classifier training should happen in the finalizeTask() method for
    // batch learners
    assertTrue(task.getClassifier().toString()
      .startsWith(""No classifier built""));

    task.finalizeTask();

    assertTrue(task.getClassifier().toString().startsWith(""J48 pruned tree""));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testSimpleBatchRegressorTraining() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.BOLTS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierMapTask task = setupBatchRegressor();
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }

    assertTrue(task.getClassifier().toString()
      .startsWith(""Classifier hasn't been built yet""));

    task.finalizeTask();

    assertTrue(task.getClassifier().toString()
      .startsWith(""M5 pruned model tree""));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testIncrementalRegressorTraining() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.BOLTS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierMapTask task = setupIncrementalRegressor();
    assertTrue(task.getClassifier().toString()
      .startsWith(""SGD: No model built yet""));

    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }

    assertTrue(task.getClassifier().toString()
      .startsWith(""Loss function: Squared loss (linear regression)""));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testBatchClassifierWithReservoirSampling() throws Exception {

    // first classifier on all the data
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupBatchClassifier();

    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }

    // classifier training should happen in the finalizeTask() method for
    // batch learners
    assertTrue(task.getClassifier().toString()
      .startsWith(""No classifier built""));

    task.finalizeTask();

    assertTrue(task.getClassifier().toString().startsWith(""J48 pruned tree""));

    // second classifier on a 50% sample
    WekaClassifierMapTask task50 = setupBatchClassifier();
    task50.setUseReservoirSamplingWhenBatchLearning(true);
    task50.setReservoirSampleSize(75);
    task50.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task50.processInstance(train.instance(i));
    }

    assertTrue(task50.getClassifier().toString()
      .startsWith(""No classifier built""));

    task50.finalizeTask();

    assertFalse(task.getClassifier().toString()
      .equals(task50.getClassifier().toString()));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testIncrementalRegressorTrainingMultipleIterations()
    throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.BOLTS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierMapTask task = setupIncrementalRegressor();
    assertTrue(task.getClassifier().toString()
      .startsWith(""SGD: No model built yet""));

    task.setup(new Instances(train, 0));

    String firstIteration = """";
    String secondIteration = """";

    for (int j = 0; j < 2; j++) {
      for (int i = 0; i < train.numInstances(); i++) {
        task.processInstance(train.instance(i));
      }

      if (j == 0) {
        firstIteration = task.getClassifier().toString();
        assertTrue(firstIteration
          .startsWith(""Loss function: Squared loss (linear regression)""));

        // make a new class and initialize it with our trained classifier
        // from iteration 1
        Classifier c = task.getClassifier();
        task = setupIncrementalRegressor();
        task.setClassifier(c);
        task.setContinueTrainingUpdateableClassifier(true);
      }
    }
    secondIteration = task.getClassifier().toString();
    assertFalse(firstIteration.equals(secondIteration));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testSimpleIncrementalClassifierTraining() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupIncrementalClassifier();

    assertTrue(task.getClassifier().toString()
      .startsWith(""Naive Bayes Classifier: No model built yet""));

    task.setup(new Instances(train, 0));

    // classifier is updated on each instance
    String model70 = """";
    String modelFull = """";
    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));

      if (i == 70) {
        model70 = task.getClassifier().toString();
      }
    }
    modelFull = task.getClassifier().toString();

    assertFalse(modelFull.equals(model70));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testForceBatchTrainingForUpdateableClassifier() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupIncrementalClassifier();
    task.setForceBatchLearningForUpdateableClassifiers(true);

    task.setup(new Instances(train, 0));

    assertTrue(task.getClassifier().toString()
      .startsWith(""Naive Bayes Classifier: No model built yet""));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }

    // forcing batch training, so classifier should not be built yet
    assertTrue(task.getClassifier().toString()
      .startsWith(""Naive Bayes Classifier: No model built yet""));

    // build classifier
    task.finalizeTask();

    assertFalse(task.getClassifier().toString()
      .startsWith(""Naive Bayes Classifier: No model built yet""));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testFilterWrappingAggregateableClassifier() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupAggregateableBatchClassifier();

    // Single filter with non-incremental Aggregateable classifier
    Filter oneF = new Remove();

    Filter[] filters = new Filter[1];
    filters[0] = oneF;
    task.setFiltersToUse(filters);

    task.setup(new Instances(train, 0));

    Classifier wrapped = task.getClassifier();
    assertTrue(wrapped instanceof AggregateableFilteredClassifier);

    // multiple filters with non-incremental Aggregateable classifier
    filters = new Filter[2];
    Filter twoF = new NominalToBinary();
    filters[0] = twoF;
    filters[1] = oneF;
    task.setFiltersToUse(filters);

    task.setup(new Instances(train, 0));

    wrapped = task.getClassifier();
    assertTrue(wrapped instanceof AggregateableFilteredClassifier);
    Filter f = ((AggregateableFilteredClassifier) wrapped)
      .getPreConstructedFilter();
    assertTrue(f instanceof MakePreconstructedFilter);

    // base filter should be a MultiFilter
    Filter f2 = ((MakePreconstructedFilter) f).getBaseFilter();
    assertTrue(f2 instanceof MultiFilter);

    // single filter with incremental Aggregateable classifier
    task = setupAggregateableIncrementalClassifier();
    filters = new Filter[1];
    filters[0] = oneF;
    task.setFiltersToUse(filters);
    task.setup(new Instances(train, 0));

    wrapped = task.getClassifier();

    assertTrue(wrapped instanceof AggregateableFilteredClassifierUpdateable);

    // single MakePreconstructedFilter
    assertTrue(((AggregateableFilteredClassifierUpdateable) wrapped)
      .getPreConstructedFilter() instanceof MakePreconstructedFilter);

    f = ((AggregateableFilteredClassifierUpdateable) wrapped)
      .getPreConstructedFilter();
    assertTrue(((MakePreconstructedFilter) f).getBaseFilter() instanceof Remove);

    // multiple filters with incremental Aggregateable classifier
    filters = new Filter[2];
    filters[0] = twoF;
    filters[1] = oneF;
    task.setFiltersToUse(filters);
    task.setup(new Instances(train, 0));

    wrapped = task.getClassifier();
    assertTrue(wrapped instanceof AggregateableFilteredClassifierUpdateable);
    assertTrue(((AggregateableFilteredClassifierUpdateable) wrapped)
      .getPreConstructedFilter() instanceof MakePreconstructedFilter);
    f = ((AggregateableFilteredClassifierUpdateable) wrapped)
      .getPreConstructedFilter();
    assertTrue(((MakePreconstructedFilter) f).getBaseFilter() instanceof MultiFilter);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testFilterWrappingNonAggregateableClassifier() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupBatchClassifier();

    // Single filter with non-incremental non-aggregateable classifier
    Filter oneF = new Remove();

    Filter[] filters = new Filter[1];
    filters[0] = oneF;
    task.setFiltersToUse(filters);

    task.setup(new Instances(train, 0));
    Classifier wrapped = task.getClassifier();

    assertTrue(wrapped instanceof FilteredClassifier);
    assertTrue(((FilteredClassifier) wrapped).getFilter() instanceof Remove);

    // Single filter with incremental non-aggregateable classifier
    task = setupIncrementalNonAggregateableClassifier();
    task.setFiltersToUse(filters);
    task.setup(new Instances(train, 0));

    wrapped = task.getClassifier();
    assertTrue(wrapped instanceof FilteredClassifierUpdateable);
    assertTrue(((FilteredClassifierUpdateable) wrapped).getFilter() instanceof Remove);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testAggregatingAggregateableClassifiers() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupAggregateableBatchClassifier();
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c1 = task.getClassifier();
    String c1S = c1.toString();

    task = setupAggregateableBatchClassifier();
    task.setUseReservoirSamplingWhenBatchLearning(true);
    task.setReservoirSampleSize(75);
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c2 = task.getClassifier();
    String c2S = c2.toString();

    // different classifiers
    assertFalse(c1S.equals(c2S));

    WekaClassifierReduceTask reduce = new WekaClassifierReduceTask();
    List<Classifier> toAgg = new ArrayList<Classifier>();
    toAgg.add(c1);
    toAgg.add(c2);
    Classifier aggregated = reduce.aggregate(toAgg);
    String aggregatedS = aggregated.toString();

    // aggregated classifier differs from both base classifier
    assertFalse(aggregatedS.equals(c1S));
    assertFalse(aggregatedS.equals(c2S));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testAggregatingNonAggregateableClassifiers() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupBatchClassifier();
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c1 = task.getClassifier();
    String c1S = c1.toString();

    task = setupBatchClassifier();
    task.setUseReservoirSamplingWhenBatchLearning(true);
    task.setReservoirSampleSize(75);
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c2 = task.getClassifier();
    String c2S = c2.toString();

    // different classifiers
    assertFalse(c1S.equals(c2S));

    WekaClassifierReduceTask reduce = new WekaClassifierReduceTask();
    List<Classifier> toAgg = new ArrayList<Classifier>();
    toAgg.add(c1);
    toAgg.add(c2);
    Classifier aggregated = reduce.aggregate(toAgg);

    assertTrue(aggregated instanceof Vote);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testAggregatingAggregateableClassifiersForceVote()
    throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupAggregateableBatchClassifier();
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c1 = task.getClassifier();
    String c1S = c1.toString();

    task = setupAggregateableBatchClassifier();
    task.setUseReservoirSamplingWhenBatchLearning(true);
    task.setReservoirSampleSize(75);
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c2 = task.getClassifier();
    String c2S = c2.toString();

    // different classifiers
    assertFalse(c1S.equals(c2S));

    WekaClassifierReduceTask reduce = new WekaClassifierReduceTask();
    List<Classifier> toAgg = new ArrayList<Classifier>();
    toAgg.add(c1);
    toAgg.add(c2);
    Classifier aggregated = reduce.aggregate(toAgg, null, true);

    assertTrue(aggregated instanceof Vote);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testAggregatingWithMinTrainingFraction() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    WekaClassifierMapTask task = setupAggregateableBatchClassifier();
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c1 = task.getClassifier();
    String c1S = c1.toString();

    task = setupAggregateableBatchClassifier();
    task.setUseReservoirSamplingWhenBatchLearning(true);
    task.setReservoirSampleSize(75);
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c2 = task.getClassifier();
    String c2S = c2.toString();

    // different classifiers
    assertFalse(c1S.equals(c2S));

    task = setupAggregateableBatchClassifier();
    task.setUseReservoirSamplingWhenBatchLearning(true);
    task.setReservoirSampleSize(60);
    task.setup(new Instances(train, 0));

    for (int i = 0; i < train.numInstances(); i++) {
      task.processInstance(train.instance(i));
    }
    task.finalizeTask();

    Classifier c3 = task.getClassifier();
    WekaClassifierReduceTask reduce = new WekaClassifierReduceTask();
    List<Classifier> toAgg = new ArrayList<Classifier>();
    toAgg.add(c1);
    toAgg.add(c2);
    toAgg.add(c3);

    reduce.setMinTrainingFraction(0.5);
    List<Integer> numTraining = new ArrayList<Integer>();
    numTraining.add(150);
    numTraining.add(75);
    numTraining.add(60);

    Classifier aggregated = reduce.aggregate(toAgg, numTraining, false);

    assertFalse(aggregated instanceof Vote);

    List<Integer> discarded = reduce.getDiscarded();
    assertTrue(discarded != null);

    // should be one classifier discarded (< minTrainingFraction)
    assertTrue(discarded.size() == 1);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierTaskTest.java,weka-master
"@Test
  public void testNumericTarget() throws Exception {
    Instances orig = getBolts();

    orig.setClassIndex(orig.numAttributes() - 1);
    Instances withSummary = getSummaryInsts(orig, new String[0]);

    CorrelationMatrixMapTask corrTask = new CorrelationMatrixMapTask();
    corrTask.setup(withSummary);

    for (int i = 0; i < orig.numInstances(); i++) {
      corrTask.processInstance(orig.instance(i));
    }

    double[][] matrix = corrTask.getMatrix();
    assertTrue(matrix != null);
    assertEquals(7, matrix.length); // numeric class is not part of the matrix
    checkAgainstUtilsCorr(matrix, orig, withSummary, true);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CorrelationMatrixMapTaskTest.java,weka-master
"@Test
  public void testNumericTargetWithTargetIncluded() throws Exception {
    Instances orig = getBolts();

    orig.setClassIndex(orig.numAttributes() - 1);
    Instances withSummary = getSummaryInsts(orig, new String[0]);

    CorrelationMatrixMapTask corrTask = new CorrelationMatrixMapTask();
    corrTask.setKeepClassAttributeIfSet(true);
    corrTask.setup(withSummary);

    for (int i = 0; i < orig.numInstances(); i++) {
      corrTask.processInstance(orig.instance(i));
    }

    double[][] matrix = corrTask.getMatrix();

    orig.setClassIndex(-1);
    assertTrue(matrix != null);
    assertEquals(8, matrix.length); // numeric class is part of the matrix
    checkAgainstUtilsCorr(matrix, orig, withSummary, false);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CorrelationMatrixMapTaskTest.java,weka-master
"@Test
  public void testNominalTarget() throws Exception {
    Instances orig = getIris();

    orig.setClassIndex(orig.numAttributes() - 1);
    Instances withSummary = getSummaryInsts(orig, new String[0]);

    CorrelationMatrixMapTask corrTask = new CorrelationMatrixMapTask();
    corrTask.setup(withSummary);

    for (int i = 0; i < orig.numInstances(); i++) {
      corrTask.processInstance(orig.instance(i));
    }

    double[][] matrix = corrTask.getMatrix();

    assertTrue(matrix != null);

    assertEquals(4, matrix.length);

    checkAgainstUtilsCorr(matrix, orig, withSummary, true);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CorrelationMatrixMapTaskTest.java,weka-master
"@Test
  public void testScoreWithClassifier() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    NaiveBayes bayes = new NaiveBayes();

    bayes.buildClassifier(train);

    WekaScoringMapTask task = new WekaScoringMapTask();
    task.setModel(bayes, train, train);

    assertEquals(0, task.getMissingMismatchAttributeInfo().length());
    assertEquals(3, task.getPredictionLabels().size());

    for (int i = 0; i < train.numInstances(); i++) {
      assertEquals(3, task.processInstance(train.instance(i)).length);
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaScoringTaskTest.java,weka-master
"@Test
  public void testScoreWithClassifierSomeMissingFields() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);
    NaiveBayes bayes = new NaiveBayes();

    bayes.buildClassifier(train);

    WekaScoringMapTask task = new WekaScoringMapTask();
    Remove r = new Remove();
    r.setAttributeIndices(""1"");
    r.setInputFormat(train);
    Instances test = Filter.useFilter(train, r);

    task.setModel(bayes, train, test);

    assertTrue(task.getMissingMismatchAttributeInfo().length() > 0);
    assertTrue(task.getMissingMismatchAttributeInfo().equals(
      ""sepallength missing from incoming data\n""));
    assertEquals(3, task.getPredictionLabels().size());

    for (int i = 0; i < test.numInstances(); i++) {
      assertEquals(3, task.processInstance(test.instance(i)).length);
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaScoringTaskTest.java,weka-master
"@Test
  public void testGetHeaderWithoutProcessing() throws Exception {
    // tests getting a header without any processing of incoming
    // CSV data - i.e. all attributes are assumed to be numeric

    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();
    // task.setOptions(args);

    Instances i = task.getHeader(10, null);
    for (int j = 0; j < i.numAttributes(); j++) {
      assertTrue(i.attribute(j).isNumeric());
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessCSVSummaryAttributesWithStringAttribute()
    throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();
    task.setStringAttributes(""last"");

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    while ((line = br.readLine()) != null) {
      task.processRow(line, attNames);
    }

    br.close();

    Instances header = task.getHeader();

    // check that the summary att has 16 values - i.e.
    // 8 summary stats for the string length and 8 for
    // the word count
    assertEquals(16, header.attribute(9).numValues());

    StringStats stats = StringStats.attributeToStats(header.attribute(9));

    assertEquals(
      150,
      (int) stats.getStringLengthStats().getStats()[ArffSummaryNumericMetric.COUNT
        .ordinal()]);

    assertEquals(150,
      (int) stats.getWordCountStats().getStats()[ArffSummaryNumericMetric.COUNT
        .ordinal()]);

    // derived metrics should all be zero at this stage
    assertTrue(stats.getStringLengthStats().getStats()[ArffSummaryNumericMetric.STDDEV
      .ordinal()] == 0);

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    header = arffReduce.aggregate(instList);

    stats = StringStats.attributeToStats(header.attribute(9));
    assertTrue(Math
      .abs(stats.getStringLengthStats().getStats()[ArffSummaryNumericMetric.MEAN
        .ordinal()] - 13.333333) < TOL);

    assertTrue(Math
      .abs(stats.getStringLengthStats().getStats()[ArffSummaryNumericMetric.STDDEV
        .ordinal()] - 1.7053672) < TOL);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessCSVSummaryAttributes() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    while ((line = br.readLine()) != null) {
      task.processRow(line, attNames);
    }

    br.close();

    Instances header = task.getHeader();

    assertEquals(10, header.numAttributes()); // one meta attribute for each
                                              // actual attribute

    assertTrue(header.attribute(4).isNominal());
    for (int i = 5; i < header.numAttributes(); i++) {
      assertTrue(header.attribute(i).name().startsWith(""arff_summary_""));
    }

    // check stats for petallength
    NumericStats s = NumericStats.attributeToStats(header.attribute(5));

    // derived metrics in summary attributes should all be zero
    assertTrue(s.getStats()[ArffSummaryNumericMetric.STDDEV.ordinal()] == 0);

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    header = arffReduce.aggregate(instList);

    s = NumericStats.attributeToStats(header.attribute(5));
    assertEquals(150,
      (int) s.getStats()[ArffSummaryNumericMetric.COUNT.ordinal()]);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.SUM.ordinal()] - 876.5) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.SUMSQ.ordinal()] - 5223.849999999998) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MIN.ordinal()] - 4.3) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MAX.ordinal()] - 7.9) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MEAN.ordinal()] - 5.843333333333335) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MISSING.ordinal()] - 0) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.STDDEV.ordinal()] - 0.8280661279778435) < TOL);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessCSVSummaryAttributesPlusTDigestQuartiles()
    throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();
    task.setComputeQuartilesAsPartOfSummaryStats(true);
    task.setCompressionLevelForQuartileEstimation(75);

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    while ((line = br.readLine()) != null) {
      task.processRow(line, attNames);
    }

    br.close();

    HeaderAndQuantileDataHolder holder = task.getHeaderAndQuantileEstimators();
    List<HeaderAndQuantileDataHolder> holderList =
      new ArrayList<HeaderAndQuantileDataHolder>();
    holderList.add(holder);

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();

    Instances finalHeader = arffReduce.aggregateHeadersAndQuartiles(holderList);

    // System.err.println(finalHeader);

    // test a few quartiles
    Attribute sepallengthSummary =
      finalHeader
        .attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
          + ""sepallength"");
    double median =
      ArffSummaryNumericMetric.MEDIAN.valueFromAttribute(sepallengthSummary);
    assertEquals(5.80000021, median, 0.0001);

    double lowerQuartile =
      ArffSummaryNumericMetric.FIRSTQUARTILE
        .valueFromAttribute(sepallengthSummary);
    assertEquals(5.10000020, lowerQuartile, 0.0001);

    double upperQuartile =
      ArffSummaryNumericMetric.THIRDQUARTILE
        .valueFromAttribute(sepallengthSummary);
    assertEquals(6.40000022, upperQuartile, 0.0001);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessWithTDigestQuartilesTwoMapTasks() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();
    task.setComputeQuartilesAsPartOfSummaryStats(true);

    CSVToARFFHeaderMapTask task2 = new CSVToARFFHeaderMapTask();
    task2.setComputeQuartilesAsPartOfSummaryStats(true);

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    int count = 0;
    while ((line = br.readLine()) != null) {
      if (count % 2 == 0) {
        task.processRow(line, attNames);
      } else {
        task2.processRow(line, attNames);
      }

      count++;
    }

    br.close();

    assertEquals(10, task.getHeader().numAttributes());
    assertEquals(10, task2.getHeader().numAttributes());
    assertTrue(task.getHeader().attribute(4).isNominal());
    assertTrue(task2.getHeader().attribute(4).isNominal());

    for (int i = 5; i < task.getHeader().numAttributes(); i++) {
      assertTrue(task.getHeader().attribute(i).name()
        .startsWith(""arff_summary_""));
      assertTrue(task2.getHeader().attribute(i).name()
        .startsWith(""arff_summary_""));
    }

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();

    HeaderAndQuantileDataHolder holder = task.getHeaderAndQuantileEstimators();
    HeaderAndQuantileDataHolder holder2 =
      task2.getHeaderAndQuantileEstimators();
    List<HeaderAndQuantileDataHolder> holderList =
      new ArrayList<HeaderAndQuantileDataHolder>();
    holderList.add(holder);
    holderList.add(holder2);

    Instances finalHeader = arffReduce.aggregateHeadersAndQuartiles(holderList);

    // System.err.println(finalHeader);

    // test a few quartiles
    Attribute sepallengthSummary =
      finalHeader
        .attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
          + ""sepallength"");
    double median =
      ArffSummaryNumericMetric.MEDIAN.valueFromAttribute(sepallengthSummary);
    assertEquals(5.80000021, median, 0.0001);

    double lowerQuartile =
      ArffSummaryNumericMetric.FIRSTQUARTILE
        .valueFromAttribute(sepallengthSummary);
    assertEquals(5.10000020, lowerQuartile, 0.0001);

    double upperQuartile =
      ArffSummaryNumericMetric.THIRDQUARTILE
        .valueFromAttribute(sepallengthSummary);
    assertEquals(6.40000022, upperQuartile, 0.0001);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessCSVSummaryAttributesPlusPSquaredQuartiles()
    throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    while ((line = br.readLine()) != null) {
      task.processRow(line, attNames);
    }

    br.close();

    Instances header = task.getHeader();

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    header = arffReduce.aggregate(instList);

    Instances headerNoSummary =
      CSVToARFFHeaderReduceTask.stripSummaryAtts(header);
    QuantileCalculator quartiles =
      new QuantileCalculator(headerNoSummary, new double[] { 0.25, 0.5, 0.75 });

    Map<Integer, NumericAttributeBinData> histMaps =
      new HashMap<Integer, NumericAttributeBinData>();
    for (int i = 0; i < headerNoSummary.numAttributes(); i++) {
      if (headerNoSummary.attribute(i).isNumeric()) {
        Attribute summary =
          header.attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
            + headerNoSummary.attribute(i).name());
        histMaps.put(i, new NumericAttributeBinData(headerNoSummary
          .attribute(i).name(), summary, -1));
      }
    }

    quartiles.setHistogramMap(histMaps);

    br = new BufferedReader(new StringReader(IRIS));
    br.readLine();

    while ((line = br.readLine()) != null) {
      String[] split = line.split("","");

      quartiles.update(split, ""?"");
    }
    br.close();

    Instances updatedHeader =
      CSVToARFFHeaderReduceTask.updateSummaryAttsWithQuartilesAndHistograms(
        header, quartiles, histMaps);

    // test a few quartiles
    Attribute sepallengthSummary =
      updatedHeader
        .attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
          + ""sepallength"");
    double median =
      ArffSummaryNumericMetric.MEDIAN.valueFromAttribute(sepallengthSummary);
    assertEquals(5.87387, median, 0.0001);

    double lowerQuartile =
      ArffSummaryNumericMetric.FIRSTQUARTILE
        .valueFromAttribute(sepallengthSummary);
    assertEquals(5.31787, lowerQuartile, 0.0001);

    double upperQuartile =
      ArffSummaryNumericMetric.THIRDQUARTILE
        .valueFromAttribute(sepallengthSummary);
    assertEquals(6.49559, upperQuartile, 0.0001);

    NumericStats stats = NumericStats.attributeToStats(sepallengthSummary);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessCSVSummaryAttributesUnparsableNumericValue()
    throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    int count = 0;
    while ((line = br.readLine()) != null) {
      if (count == 4) {
        line = line.replace(""5.0"", ""bob"");
      }
      task.processRow(line, attNames);
      count++;
    }

    assertEquals(10, task.getHeader().numAttributes());
    for (int i = 5; i < task.getHeader().numAttributes(); i++) {
      assertTrue(task.getHeader().attribute(i).name()
        .startsWith(""arff_summary_""));
    }

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    Instances header = arffReduce.aggregate(instList);

    // first attribute is now of type string because of unparsable number
    StringStats s = StringStats.attributeToStats(header.attribute(5));
    assertEquals(150,
      (int) s.getStringLengthStats().getStats()[ArffSummaryNumericMetric.COUNT
        .ordinal()]);

    br.close();
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void
    testProcessCSVSummaryAttributesUnparsableNumericValueTwoMapTasks()
      throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();

    CSVToARFFHeaderMapTask task2 = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    int count = 0;
    while ((line = br.readLine()) != null) {
      if (count == 4) {
        line = line.replace(""5.0"", ""bob"");
      }
      if (count % 2 == 0) {
        task.processRow(line, attNames);
      } else {
        task2.processRow(line, attNames);
      }

      count++;
    }

    assertEquals(10, task.getHeader().numAttributes());
    assertEquals(10, task2.getHeader().numAttributes());
    assertTrue(task.getHeader().attribute(0).isString());
    assertTrue(task2.getHeader().attribute(0).isNumeric());

    for (int i = 5; i < task.getHeader().numAttributes(); i++) {
      assertTrue(task.getHeader().attribute(i).name()
        .startsWith(""arff_summary_""));
    }

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    instList.add(task2.getHeader());
    Instances header = arffReduce.aggregate(instList);

    // first attribute is now of type string because of unparsable number
    StringStats s = StringStats.attributeToStats(header.attribute(5));

    // We expect a count of only 75 because one task will have its stats dropped
    // due to being forced to be of type string in the aggregation process.
    assertEquals(75,
      (int) s.getStringLengthStats().getStats()[ArffSummaryNumericMetric.COUNT
        .ordinal()]);

    br.close();
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testTreatUnparsableAsMissing() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();
    task.setTreatUnparsableNumericValuesAsMissing(true);

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    int count = 0;
    while ((line = br.readLine()) != null) {
      if (count == 4) {
        line = line.replace(""5.0"", ""bob"");
      }
      task.processRow(line, attNames);
      count++;
    }

    assertEquals(10, task.getHeader().numAttributes());
    for (int i = 5; i < task.getHeader().numAttributes(); i++) {
      assertTrue(task.getHeader().attribute(i).name()
        .startsWith(""arff_summary_""));
    }
    assertTrue(task.getHeader().attribute(0).isNumeric());

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    Instances header = arffReduce.aggregate(instList);
    NumericStats s = NumericStats.attributeToStats(header.attribute(5));
    assertEquals(149,
      (int) s.getStats()[ArffSummaryNumericMetric.COUNT.ordinal()]);
    assertEquals(1,
      (int) s.getStats()[ArffSummaryNumericMetric.MISSING.ordinal()]);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessCSVSummaryAttributesTwoMapTasks() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();

    CSVToARFFHeaderMapTask task2 = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    int count = 0;
    while ((line = br.readLine()) != null) {
      if (count % 2 == 0) {
        task.processRow(line, attNames);
      } else {
        task2.processRow(line, attNames);
      }

      count++;
    }

    br.close();

    assertEquals(10, task.getHeader().numAttributes());
    assertEquals(10, task2.getHeader().numAttributes());
    assertTrue(task.getHeader().attribute(4).isNominal());
    assertTrue(task2.getHeader().attribute(4).isNominal());

    for (int i = 5; i < task.getHeader().numAttributes(); i++) {
      assertTrue(task.getHeader().attribute(i).name()
        .startsWith(""arff_summary_""));
      assertTrue(task2.getHeader().attribute(i).name()
        .startsWith(""arff_summary_""));
    }

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    instList.add(task2.getHeader());
    Instances header = arffReduce.aggregate(instList);

    NumericStats s = NumericStats.attributeToStats(header.attribute(5));
    assertEquals(150,
      (int) s.getStats()[ArffSummaryNumericMetric.COUNT.ordinal()]);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.SUM.ordinal()] - 876.5) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.SUMSQ.ordinal()] - 5223.849999999998) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MIN.ordinal()] - 4.3) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MAX.ordinal()] - 7.9) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MEAN.ordinal()] - 5.843333333333335) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.MISSING.ordinal()] - 0) < TOL);
    assertTrue(Math
      .abs(s.getStats()[ArffSummaryNumericMetric.STDDEV.ordinal()] - 0.8280661279778435) < TOL);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testNumericStatsWithHistograms() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    while ((line = br.readLine()) != null) {
      task.processRow(line, attNames);
    }

    br.close();

    Instances header = task.getHeader();

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    header = arffReduce.aggregate(instList);

    Attribute numericAtt =
      header.attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
        + header.attribute(0).name());

    NumericStats s = NumericStats.attributeToStats(numericAtt);

    assertTrue(s.getHistogramBinLabels() == null);
    assertTrue(s.getHistogramFrequencies() == null);

    List<String> binLabs = new ArrayList<String>();
    List<Double> binFreqs = new ArrayList<Double>();
    binLabs.add(""Label1"");
    binLabs.add(""Label2"");
    binLabs.add(""Label3"");
    binFreqs.add(2.0);
    binFreqs.add(0.0);
    binFreqs.add(10.0);

    s.setHistogramData(binLabs, binFreqs);

    Attribute newAtt = s.makeAttribute();

    assertEquals(""Label1:2.0!Label2:0.0!Label3:10.0"",
      newAtt.value(newAtt.numValues() - 1));

  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessFromHeaderRoundTrip() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    while ((line = br.readLine()) != null) {
      task.processRow(line, attNames);
    }

    br.close();

    Instances header = task.getHeader();

    // reduce to compute derived metrics
    CSVToARFFHeaderReduceTask arffReduce = new CSVToARFFHeaderReduceTask();
    List<Instances> instList = new ArrayList<Instances>();
    instList.add(task.getHeader());
    header = CSVToARFFHeaderReduceTask.aggregate(instList);

    // set state from header
    task.fromHeader(header, null);
    instList.clear();
    instList.add(task.getHeader());
    Instances header2 = CSVToARFFHeaderReduceTask.aggregate(instList);
    assertTrue(header.equalHeaders(header2));

    // this time use a fresh map task object
    CSVToARFFHeaderMapTask newTask = new CSVToARFFHeaderMapTask();
    newTask.fromHeader(header, null);
    instList.clear();
    instList.add(newTask.getHeader());
    header2 = CSVToARFFHeaderReduceTask.aggregate(instList);
    assertTrue(header.equalHeaders(header2));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testProcessRoundTripWithQuantiles() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();
    task.setComputeQuartilesAsPartOfSummaryStats(true);
    task.setCompressionLevelForQuartileEstimation(80.0);

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    while ((line = br.readLine()) != null) {
      task.processRow(line, attNames);
    }

    br.close();

    HeaderAndQuantileDataHolder holder = task.getHeaderAndQuantileEstimators();
    List<HeaderAndQuantileDataHolder> holderList =
      new ArrayList<HeaderAndQuantileDataHolder>();
    holderList.add(holder);
    Instances header =
      CSVToARFFHeaderReduceTask.aggregateHeadersAndQuartiles(holderList);

    Map<String, TDigest> estimators = new HashMap<String, TDigest>();
    Instances headerNoSummary =
      CSVToARFFHeaderReduceTask.stripSummaryAtts(header);
    for (int i = 0; i < headerNoSummary.numAttributes(); i++) {
      if (header.attribute(i).isNumeric()) {
        estimators.put(headerNoSummary.attribute(i).name(),
          holder.getQuantileEstimator(header.attribute(i).name()));
      }
    }

    CSVToARFFHeaderMapTask fresh = new CSVToARFFHeaderMapTask();
    fresh.setComputeQuartilesAsPartOfSummaryStats(true);
    fresh.setCompressionLevelForQuartileEstimation(80.0);
    fresh.fromHeader(header, estimators);
    holderList.clear();
    holder = fresh.getHeaderAndQuantileEstimators();
    holderList.add(holder);
    Instances freshHeader =
      CSVToARFFHeaderReduceTask.aggregateHeadersAndQuartiles(holderList);

    // check a few quantiles
    Attribute origSepallength =
      header.attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
        + ""sepallength"");
    Attribute freshSepallength =
      freshHeader
        .attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
          + ""sepallength"");

    assertEquals(
      ArffSummaryNumericMetric.FIRSTQUARTILE
        .valueFromAttribute(origSepallength),
      ArffSummaryNumericMetric.FIRSTQUARTILE
        .valueFromAttribute(freshSepallength), 0.000001);

    assertEquals(
      ArffSummaryNumericMetric.THIRDQUARTILE
        .valueFromAttribute(origSepallength),
      ArffSummaryNumericMetric.THIRDQUARTILE
        .valueFromAttribute(freshSepallength), 0.000001);

    assertEquals(
      ArffSummaryNumericMetric.MEDIAN.valueFromAttribute(origSepallength),
      ArffSummaryNumericMetric.MEDIAN.valueFromAttribute(freshSepallength),
      0.000001);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testCombine() throws Exception {
    CSVToARFFHeaderMapTask task = new CSVToARFFHeaderMapTask();
    CSVToARFFHeaderMapTask task2 = new CSVToARFFHeaderMapTask();
    CSVToARFFHeaderMapTask full = new CSVToARFFHeaderMapTask();

    BufferedReader br = new BufferedReader(new StringReader(IRIS));

    String line = br.readLine();
    String[] names = line.split("","");
    List<String> attNames = new ArrayList<String>();
    for (String s : names) {
      attNames.add(s);
    }

    int count = 0;
    while ((line = br.readLine()) != null) {
      if (count % 2 == 0) {
        task.processRow(line, attNames);
      } else {
        task2.processRow(line, attNames);
      }
      full.processRow(line, attNames);
      count++;
    }

    br.close();

    Instances fullHeader = full.getHeader();

    List<CSVToARFFHeaderMapTask> toCombine =
      new ArrayList<CSVToARFFHeaderMapTask>();
    toCombine.add(task);
    toCombine.add(task2);

    task = CSVToARFFHeaderMapTask.combine(toCombine);
    // assertTrue(fullHeader.equalHeaders(task.getHeader()));
    Instances combinedHeader = task.getHeader();

    // check a few numeric summary stats
    Attribute fullSepallength =
      fullHeader.attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
        + ""sepallength"");
    Attribute combinedSepallength =
      combinedHeader
        .attribute(CSVToARFFHeaderMapTask.ARFF_SUMMARY_ATTRIBUTE_PREFIX
          + ""sepallength"");
    assertEquals(
      ArffSummaryNumericMetric.SUM.valueFromAttribute(fullSepallength),
      ArffSummaryNumericMetric.SUM.valueFromAttribute(combinedSepallength),
      0.000001);

    assertEquals(
      ArffSummaryNumericMetric.SUMSQ.valueFromAttribute(fullSepallength),
      ArffSummaryNumericMetric.SUMSQ.valueFromAttribute(combinedSepallength),
      0.000001);

    assertEquals(
      ArffSummaryNumericMetric.MAX.valueFromAttribute(fullSepallength),
      ArffSummaryNumericMetric.MAX.valueFromAttribute(combinedSepallength),
      0.000001);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CSVToARFFHeaderMapTaskTest.java,weka-master
"@Test
  public void testInitializationNoFilters() throws Exception {

    // no filters apart from missing values

    Instances irisData = CorrelationMatrixMapTaskTest.getIris();
    irisData.firstInstance().setMissing(0); // set one value to missing
    Instances irisSummaryHeader = getIrisSummaryHeader();

    KMeansMapTask task = new KMeansMapTask();
    try {
      task.processInstance(irisData.firstInstance());
      fail(""Should have thrown an exception as we have not yet called init()"");
    } catch (DistributedWekaException e) {
      // expected
    }

    task.init(irisSummaryHeader);
    assertFalse(task.getDontReplaceMissingValues());

    try {
      task.processInstance(irisData.firstInstance());
      fail(""Should have thrown an exception as we have not set any starting centroids to use yet"");
    } catch (DistributedWekaException e) {
      // expected
    }

    Instances initialCenters = new Instances(irisData, 0);
    initialCenters.add(irisData.firstInstance());
    initialCenters.add(irisData.instance(50));
    initialCenters.add(irisData.instance(100));

    initialCenters = task.applyFilters(initialCenters);
    task.setCentroids(initialCenters);

    // processInstance() should not raise exceptions now
    for (int i = 0; i < irisData.numInstances(); i++) {
      task.processInstance(irisData.instance(i));
    }

    // System.err.println(""Full:\n"" + irisSummaryHeader);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/KMeansTaskTest.java,weka-master
"@Test
  public void testInitializationDontReplaceMissing() throws Exception {
    Instances irisData = CorrelationMatrixMapTaskTest.getIris();
    irisData.firstInstance().setMissing(0); // set one value to missing
    Instances irisSummaryHeader = getIrisSummaryHeader();

    KMeansMapTask task = new KMeansMapTask();
    task.setDontReplaceMissingValues(true);
    try {
      task.processInstance(irisData.firstInstance());
      fail(""Should have thrown an exception as we have not yet called init()"");
    } catch (DistributedWekaException e) {
      // expected
    }

    task.init(irisSummaryHeader);
    assertTrue(task.getDontReplaceMissingValues());

    try {
      task.processInstance(irisData.firstInstance());
      fail(""Should have thrown an exception as we have not set any starting centroids to use yet"");
    } catch (DistributedWekaException e) {
      // expected
    }

    Instances initialCenters = new Instances(irisData, 0);
    initialCenters.add(irisData.firstInstance());
    initialCenters.add(irisData.instance(50));
    initialCenters.add(irisData.instance(100));

    initialCenters = task.applyFilters(initialCenters);
    task.setCentroids(initialCenters);

    for (int i = 0; i < irisData.numInstances(); i++) {
      task.processInstance(irisData.instance(i));
    }

    List<Instances> centroidStats = task.getCentroidStats();
    assertEquals(3, centroidStats.size());

    // iris setosa cluster should have 49 non-missing values and 1 missing
    // for attributes
    assertEquals(49,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(centroidStats.get(0).attribute(5)));

    // size of the other two clusters should be 50
    for (int i = 1; i < centroidStats.size(); i++) {
      Attribute summary = centroidStats.get(i).attribute(5);
      assertEquals(50,
        (int) ArffSummaryNumericMetric.COUNT
          .valueFromAttribute(summary));
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/KMeansTaskTest.java,weka-master
"@Test
  public void testClusteringMissingValuesReplacementOnly() throws Exception {

    Instances irisData = CorrelationMatrixMapTaskTest.getIris();
    Instances irisSummaryHeader = getIrisSummaryHeader();

    KMeansMapTask task = new KMeansMapTask();
    task.init(irisSummaryHeader);
    assertFalse(task.getDontReplaceMissingValues());

    Instances initialCenters = new Instances(irisData, 0);
    initialCenters.add(irisData.firstInstance());
    initialCenters.add(irisData.instance(50));
    initialCenters.add(irisData.instance(100));

    initialCenters = task.applyFilters(initialCenters);
    task.setCentroids(initialCenters);

    // processInstance() should not raise exceptions now
    for (int i = 0; i < irisData.numInstances(); i++) {
      task.processInstance(irisData.instance(i));
    }

    List<Instances> centroidStats = task.getCentroidStats();
    assertEquals(3, centroidStats.size());

    // size of each should be 50 instances
    for (Instances i : centroidStats) {
      Attribute summary = i.attribute(5);
      assertEquals(50,
        (int) ArffSummaryNumericMetric.COUNT
          .valueFromAttribute(summary));
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/KMeansTaskTest.java,weka-master
"@Test
  public void testClusteringWithRemoveFilter() throws Exception {

    Instances irisData = CorrelationMatrixMapTaskTest.getIris();
    Instances irisSummaryHeader = getIrisSummaryHeader();

    KMeansMapTask task = new KMeansMapTask();
    task
      .setOptions(Utils
        .splitOptions(""-filter \""weka.filters.unsupervised.attribute.Remove -R last\""""));

    Instances irisTransformedNoSummary = task.init(irisSummaryHeader);
    assertEquals(4, irisTransformedNoSummary.numAttributes());
    assertFalse(task.getDontReplaceMissingValues());

    Instances initialCenters = new Instances(irisData, 0);
    initialCenters.add(irisData.firstInstance());
    initialCenters.add(irisData.instance(50));
    initialCenters.add(irisData.instance(100));

    initialCenters = task.applyFilters(initialCenters);
    assertEquals(4, initialCenters.numAttributes());

    task.setCentroids(initialCenters);

    // processInstance() should not raise exceptions now
    for (int i = 0; i < irisData.numInstances(); i++) {
      task.processInstance(irisData.instance(i));
    }

    List<Instances> centroidStats = task.getCentroidStats();
    assertEquals(3, centroidStats.size());

    // clusters are different this time because we
    // removed the last attribute
    assertEquals(53,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(centroidStats.get(0).attribute(4)));
    assertEquals(66,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(centroidStats.get(1).attribute(4)));
    assertEquals(31,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(centroidStats.get(2).attribute(4)));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/KMeansTaskTest.java,weka-master
"@Test
  public void testReduceClustersNoFilters() throws Exception {
    Instances irisData = CorrelationMatrixMapTaskTest.getIris();
    Instances irisSummaryHeader = getIrisSummaryHeader();

    KMeansMapTask[] task = new KMeansMapTask[2];
    task[0] = new KMeansMapTask();
    task[1] = new KMeansMapTask();

    Instances irisTransformedNoSummary = task[0].init(irisSummaryHeader);
    task[1].init(irisSummaryHeader);

    Instances initialCenters = new Instances(irisData, 0);
    initialCenters.add(irisData.firstInstance());
    initialCenters.add(irisData.instance(50));
    initialCenters.add(irisData.instance(100));

    // randomize the iris data
    irisData.randomize(new Random(1));

    initialCenters = task[0].applyFilters(initialCenters);
    task[0].setCentroids(initialCenters);
    task[1].setCentroids(initialCenters);

    // processInstance() should not raise exceptions now
    for (int i = 0; i < irisData.numInstances(); i++) {
      if (i < 75) {
        task[0].processInstance(irisData.instance(i));
      } else {
        task[1].processInstance(irisData.instance(i));
      }
    }

    List<Instances> centroidStats1 = task[0].getCentroidStats();
    List<Instances> centroidStats2 = task[1].getCentroidStats();
    assertEquals(3, centroidStats1.size());
    assertEquals(3, centroidStats2.size());

    // partial clusters will have counts less than 50
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats1.get(0).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats1.get(1).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats1.get(2).attribute(5)) < 50);

    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats2.get(0).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats2.get(1).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats2.get(2).attribute(5)) < 50);

    KMeansReduceTask reduceTask = new KMeansReduceTask();
    List<List<Instances>> clusterSummaries = new ArrayList<List<Instances>>();
    clusterSummaries.add(centroidStats1);
    clusterSummaries.add(centroidStats2);

    reduceTask =
      reduceTask.reduceClusters(0, 0, irisTransformedNoSummary,
        clusterSummaries);

    assertTrue(reduceTask != null);

    List<Instances> aggregatedCentroidSummaries =
      reduceTask.getAggregatedCentroidSummaries();
    assertTrue(aggregatedCentroidSummaries != null);
    assertEquals(3, aggregatedCentroidSummaries.size());

    // aggregated cluster stats will have counts of 50 (in this case)
    assertEquals(50,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(0).attribute(5)));
    assertEquals(50,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(1).attribute(5)));
    assertEquals(50,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(2).attribute(5)));

    // dummy distance function priming data should contain global min/max
    // for numeric attributes
    Instances dummyPriming = reduceTask.getGlobalDistanceFunctionPrimingData();
    assertTrue(dummyPriming != null);
    assertEquals(2, dummyPriming.numInstances());

    assertEquals(4.3, dummyPriming.instance(0).value(0), 0.0001);
    assertEquals(7.9, dummyPriming.instance(1).value(0), 0.0001);

    double totalError = reduceTask.getTotalWithinClustersError();
    assertEquals(17.712, totalError, 0.0001);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/KMeansTaskTest.java,weka-master
"@Test
  public void testReduceClustersNoFiltersEmptyClusters() throws Exception {
    Instances irisData = CorrelationMatrixMapTaskTest.getIris();
    Instances irisSummaryHeader = getIrisSummaryHeader();

    KMeansMapTask[] task = new KMeansMapTask[2];
    task[0] = new KMeansMapTask();
    task[1] = new KMeansMapTask();

    Instances irisTransformedNoSummary = task[0].init(irisSummaryHeader);
    task[1].init(irisSummaryHeader);

    Instances initialCenters = new Instances(irisData, 0);
    initialCenters.add(irisData.firstInstance());
    initialCenters.add(irisData.instance(50));
    initialCenters.add(irisData.instance(100));

    initialCenters = task[0].applyFilters(initialCenters);
    task[0].setCentroids(initialCenters);
    task[1].setCentroids(initialCenters);

    // processInstance() should not raise exceptions now
    for (int i = 0; i < irisData.numInstances(); i++) {
      if (i < 75) {
        task[0].processInstance(irisData.instance(i));
      } else {
        task[1].processInstance(irisData.instance(i));
      }
    }

    List<Instances> centroidStats1 = task[0].getCentroidStats();
    List<Instances> centroidStats2 = task[1].getCentroidStats();
    assertEquals(3, centroidStats1.size());
    assertEquals(3, centroidStats2.size());

    // since we didn't randomly shuffle iris there will be no
    // virginica instances seen by task[0] and no
    // setosas seen by task[1]
    assertTrue(centroidStats1.get(2) == null);
    assertTrue(centroidStats2.get(0) == null);

    KMeansReduceTask reduceTask = new KMeansReduceTask();
    List<List<Instances>> clusterSummaries = new ArrayList<List<Instances>>();
    clusterSummaries.add(centroidStats1);
    clusterSummaries.add(centroidStats2);

    reduceTask =
      reduceTask.reduceClusters(0, 0, irisTransformedNoSummary,
        clusterSummaries);

    assertTrue(reduceTask != null);

    List<Instances> aggregatedCentroidSummaries =
      reduceTask.getAggregatedCentroidSummaries();
    assertTrue(aggregatedCentroidSummaries != null);
    assertEquals(3, aggregatedCentroidSummaries.size());

    // aggregated cluster stats will have counts of 50 (in this case)
    assertEquals(50,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(0).attribute(5)));
    assertEquals(50,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(1).attribute(5)));
    assertEquals(50,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(2).attribute(5)));

    // for (Instances i : aggregatedCentroidSummaries) {
    // System.err.println(i);
    // }

    // dummy distance function priming data should contain global min/max
    // for numeric attributes
    Instances dummyPriming = reduceTask.getGlobalDistanceFunctionPrimingData();
    assertTrue(dummyPriming != null);
    assertEquals(2, dummyPriming.numInstances());

    assertEquals(4.3, dummyPriming.instance(0).value(0), 0.0001);
    assertEquals(7.9, dummyPriming.instance(1).value(0), 0.0001);

    double totalError = reduceTask.getTotalWithinClustersError();
    assertEquals(17.712, totalError, 0.0001);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/KMeansTaskTest.java,weka-master
"@Test
  public void testReduceClustersRemoveFilter() throws Exception {
    Instances irisData = CorrelationMatrixMapTaskTest.getIris();
    Instances irisSummaryHeader = getIrisSummaryHeader();

    KMeansMapTask[] task = new KMeansMapTask[2];
    task[0] = new KMeansMapTask();
    task[1] = new KMeansMapTask();

    task[0]
      .setOptions(Utils
        .splitOptions(""-filter \""weka.filters.unsupervised.attribute.Remove -R last\""""));
    task[1]
      .setOptions(Utils
        .splitOptions(""-filter \""weka.filters.unsupervised.attribute.Remove -R last\""""));

    Instances irisTransformedNoSummary = task[0].init(irisSummaryHeader);
    task[1].init(irisSummaryHeader);

    Instances initialCenters = new Instances(irisData, 0);
    initialCenters.add(irisData.firstInstance());
    initialCenters.add(irisData.instance(50));
    initialCenters.add(irisData.instance(100));

    // randomize the iris data
    irisData.randomize(new Random(1));

    initialCenters = task[0].applyFilters(initialCenters);
    task[0].setCentroids(initialCenters);
    task[1].setCentroids(initialCenters);

    // processInstance() should not raise exceptions now
    for (int i = 0; i < irisData.numInstances(); i++) {
      if (i < 75) {
        task[0].processInstance(irisData.instance(i));
      } else {
        task[1].processInstance(irisData.instance(i));
      }
    }

    List<Instances> centroidStats1 = task[0].getCentroidStats();
    List<Instances> centroidStats2 = task[1].getCentroidStats();
    assertEquals(3, centroidStats1.size());
    assertEquals(3, centroidStats2.size());

    // partial clusters will have counts less than 50
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats1.get(0).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats1.get(1).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats1.get(2).attribute(5)) < 50);

    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats2.get(0).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats2.get(1).attribute(5)) < 50);
    assertTrue((int) ArffSummaryNumericMetric.COUNT
      .valueFromAttribute(centroidStats2.get(2).attribute(5)) < 50);

    KMeansReduceTask reduceTask = new KMeansReduceTask();
    List<List<Instances>> clusterSummaries = new ArrayList<List<Instances>>();
    clusterSummaries.add(centroidStats1);
    clusterSummaries.add(centroidStats2);

    reduceTask =
      reduceTask.reduceClusters(0, 0, irisTransformedNoSummary,
        clusterSummaries);

    assertTrue(reduceTask != null);

    List<Instances> aggregatedCentroidSummaries =
      reduceTask.getAggregatedCentroidSummaries();
    assertTrue(aggregatedCentroidSummaries != null);
    assertEquals(3, aggregatedCentroidSummaries.size());

    assertEquals(56,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(0).attribute(5)));
    assertEquals(66,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(1).attribute(5)));
    assertEquals(28,
      (int) ArffSummaryNumericMetric.COUNT
        .valueFromAttribute(aggregatedCentroidSummaries.get(2).attribute(5)));

    // dummy distance function priming data should contain global min/max
    // for numeric attributes
    Instances dummyPriming = reduceTask.getGlobalDistanceFunctionPrimingData();
    assertTrue(dummyPriming != null);
    assertEquals(2, dummyPriming.numInstances());

    assertEquals(4.3, dummyPriming.instance(0).value(0), 0.0001);
    assertEquals(7.9, dummyPriming.instance(1).value(0), 0.0001);

    double totalError = reduceTask.getTotalWithinClustersError();
    assertEquals(29.6998, totalError, 0.0001);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/KMeansTaskTest.java,weka-master
"@Test
  public void testCrossValidateBatchMapOnly() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierEvaluationMapTask evaluator = new WekaClassifierEvaluationMapTask();
    WekaClassifierMapTask trainer = new WekaClassifierMapTask();
    trainer.setClassifier(new weka.classifiers.trees.J48());
    trainer.setTotalNumFolds(10);

    for (int i = 0; i < 10; i++) {
      trainer.setFoldNumber((i + 1));
      trainer.setup(new Instances(train, 0));
      trainer.addToTrainingHeader(train);
      trainer.finalizeTask();

      Classifier c = trainer.getClassifier();

      evaluator.setClassifier(c);
      evaluator.setTotalNumFolds(10);
      evaluator.setFoldNumber(i + 1);

      // priors for iris (just using priors + count from all the data for
      // simplicity)
      double[] priors = { 50.0, 50.0, 50.0 };
      evaluator.setup(new Instances(train, 0), priors, 150, 1L, 0);

      for (int j = 0; j < train.numInstances(); j++) {
        evaluator.processInstance(train.instance(j));
      }
      evaluator.finalizeTask();

      Evaluation eval = evaluator.getEvaluation();
      assertTrue(eval != null);

      // there should be predictions for exactly 15 instances per test fold
      assertEquals(15, (int) eval.numInstances());

      // there shouldn't be any AUC/AUPRC stats computed
      assertTrue(Utils.isMissingValue(eval.areaUnderROC(0)));
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierEvaluationTest.java,weka-master
"@Test
  public void testCrossValidateBatchMapOnlyRetainPredsForAUC() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierEvaluationMapTask evaluator = new WekaClassifierEvaluationMapTask();
    WekaClassifierMapTask trainer = new WekaClassifierMapTask();
    trainer.setClassifier(new weka.classifiers.trees.J48());
    trainer.setTotalNumFolds(10);

    for (int i = 0; i < 10; i++) {
      trainer.setFoldNumber((i + 1));
      trainer.setup(new Instances(train, 0));
      trainer.addToTrainingHeader(train);
      trainer.finalizeTask();

      Classifier c = trainer.getClassifier();

      evaluator.setClassifier(c);
      evaluator.setTotalNumFolds(10);
      evaluator.setFoldNumber(i + 1);

      // priors for iris (just using priors + count from all the data for
      // simplicity)
      double[] priors = { 50.0, 50.0, 50.0 };

      // retain 50% of the predictions for computing AUC
      evaluator.setup(new Instances(train, 0), priors, 150, 1L, 0.5);

      for (int j = 0; j < train.numInstances(); j++) {
        evaluator.processInstance(train.instance(j));
      }
      evaluator.finalizeTask();

      Evaluation eval = evaluator.getEvaluation();
      assertTrue(eval != null);

      // there should be predictions for exactly 15 instances per test fold
      assertEquals(15, (int) eval.numInstances());

      // should be only 7 (50% rounded down of 15) predictions retained for AUC
      // comp
      assertEquals(7, eval.predictions().size());

      // AUC shouldn't be a missing value...
      assertTrue(!Utils.isMissingValue(eval.areaUnderROC(0)));
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierEvaluationTest.java,weka-master
"@Test
  public void testCrossValidateIncrementalMapOnly() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierEvaluationMapTask evaluator = new WekaClassifierEvaluationMapTask();
    WekaClassifierMapTask trainer = new WekaClassifierMapTask();
    trainer.setClassifier(new weka.classifiers.bayes.NaiveBayesUpdateable());
    trainer.setTotalNumFolds(10);

    for (int i = 0; i < 10; i++) {
      trainer.setFoldNumber((i + 1));
      trainer.setup(new Instances(train, 0));

      for (int j = 0; j < train.numInstances(); j++) {
        trainer.processInstance(train.instance(j));
      }
      trainer.finalizeTask();

      Classifier c = trainer.getClassifier();

      evaluator.setClassifier(c);
      evaluator.setTotalNumFolds(10);
      evaluator.setFoldNumber(i + 1);

      // priors for iris (just using priors + count from all the data for
      // simplicity)
      double[] priors = { 50.0, 50.0, 50.0 };
      evaluator.setup(new Instances(train, 0), priors, 150, 1L, 0);

      for (int j = 0; j < train.numInstances(); j++) {
        evaluator.processInstance(train.instance(j));
      }
      evaluator.finalizeTask();

      Evaluation eval = evaluator.getEvaluation();
      assertTrue(eval != null);

      // there should be predictions for exactly 15 instances per test fold
      assertEquals(15, (int) eval.numInstances());

      // there shouldn't be any AUC/AUPRC stats computed
      assertTrue(Utils.isMissingValue(eval.areaUnderROC(0)));
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierEvaluationTest.java,weka-master
"@Test
  public void testCrossValidateIncrementalMapOnlyRetainPredsForAUC()
    throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierEvaluationMapTask evaluator = new WekaClassifierEvaluationMapTask();
    WekaClassifierMapTask trainer = new WekaClassifierMapTask();
    trainer.setClassifier(new weka.classifiers.bayes.NaiveBayesUpdateable());
    trainer.setTotalNumFolds(10);

    for (int i = 0; i < 10; i++) {
      trainer.setFoldNumber((i + 1));
      trainer.setup(new Instances(train, 0));

      for (int j = 0; j < train.numInstances(); j++) {
        trainer.processInstance(train.instance(j));
      }
      trainer.finalizeTask();

      Classifier c = trainer.getClassifier();

      evaluator.setClassifier(c);
      evaluator.setTotalNumFolds(10);
      evaluator.setFoldNumber(i + 1);

      // priors for iris (just using priors + count from all the data for
      // simplicity)
      double[] priors = { 50.0, 50.0, 50.0 };

      // retain all the predictions for AUC
      evaluator.setup(new Instances(train, 0), priors, 150, 1L, 1);

      for (int j = 0; j < train.numInstances(); j++) {
        evaluator.processInstance(train.instance(j));
      }
      evaluator.finalizeTask();

      Evaluation eval = evaluator.getEvaluation();
      assertTrue(eval != null);

      // there should be predictions for exactly 15 instances per test fold
      assertEquals(15, (int) eval.numInstances());

      // should be all the predictions in this fold retained for AUC
      // comp
      assertEquals(15, eval.predictions().size());

      // AUC shouldn't be a missing value
      assertTrue(!Utils.isMissingValue(eval.areaUnderROC(0)));
    }
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierEvaluationTest.java,weka-master
"@Test
  public void testReduceOverFolds() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    train.setClassIndex(train.numAttributes() - 1);

    WekaClassifierEvaluationMapTask evaluator = new WekaClassifierEvaluationMapTask();
    WekaClassifierMapTask trainer = new WekaClassifierMapTask();
    trainer.setClassifier(new weka.classifiers.trees.J48());
    trainer.setTotalNumFolds(10);

    List<Evaluation> foldEvals = new ArrayList<Evaluation>();

    for (int i = 0; i < 10; i++) {
      trainer.setFoldNumber((i + 1));
      trainer.setup(new Instances(train, 0));
      trainer.addToTrainingHeader(train);
      trainer.finalizeTask();

      Classifier c = trainer.getClassifier();

      evaluator.setClassifier(c);
      evaluator.setTotalNumFolds(10);
      evaluator.setFoldNumber(i + 1);

      // priors for iris (just using priors + count from all the data for
      // simplicity)
      double[] priors = { 50.0, 50.0, 50.0 };
      evaluator.setup(new Instances(train, 0), priors, 150, 1L, 0);

      for (int j = 0; j < train.numInstances(); j++) {
        evaluator.processInstance(train.instance(j));
      }
      evaluator.finalizeTask();

      Evaluation eval = evaluator.getEvaluation();
      assertTrue(eval != null);

      // there should be predictions for exactly 15 instances per test fold
      assertEquals(15, (int) eval.numInstances());

      // there shouldn't be any AUC/AUPRC stats computed
      assertTrue(Utils.isMissingValue(eval.areaUnderROC(0)));

      foldEvals.add(eval);
    }

    WekaClassifierEvaluationReduceTask reducer = new WekaClassifierEvaluationReduceTask();

    Evaluation aggregated = reducer.aggregate(foldEvals);

    // now should be predictions for all 150 iris instances
    assertEquals(150, (int) aggregated.numInstances());

    // still shouldn't be any AUC :-)
    assertTrue(Utils.isMissingValue(aggregated.areaUnderROC(0)));
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/WekaClassifierEvaluationTest.java,weka-master
"@Test
  public void testBasicInit() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    Instances headerWithSummary = DistributedUtils.makeHeaderWithSummaryAtts(
      train, false);

    CanopyMapTask task = new CanopyMapTask();
    task.init(headerWithSummary);

    assertTrue(task.m_missingValuesReplacer != null);

    assertEquals(task.getT1MapPhase(), """" + Canopy.DEFAULT_T1);
    assertEquals(task.getT2MapPhase(), """" + Canopy.DEFAULT_T2);
    assertTrue(task.m_filtersToUse == null);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CanopyTaskTest.java,weka-master
"@Test
  public void testInitWithFiltersNoMissingValuesReplacement() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    Instances headerWithSummary = DistributedUtils.makeHeaderWithSummaryAtts(
      train, false);

    CanopyMapTask task = new CanopyMapTask();
    task
      .setOptions(Utils
        .splitOptions(""-dont-replace-missing -filter \""weka.filters.unsupervised.attribute.Remove -R 1\""""));
    task.init(headerWithSummary);

    assertTrue(task.m_missingValuesReplacer == null);
    assertTrue(task.m_filtersToUse != null);
    assertEquals(task.m_filtersToUse.size(), 1);

    assertTrue(task.m_finalFullPreprocess instanceof MakePreconstructedFilter);
    assertTrue(((MakePreconstructedFilter) task.m_finalFullPreprocess)
      .getBaseFilter() instanceof weka.filters.unsupervised.attribute.Remove);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CanopyTaskTest.java,weka-master
"@Test
  public void testInitWithFiltersAndMissingValuesReplacement() throws Exception {
    Instances train = new Instances(new BufferedReader(new StringReader(
      CorrelationMatrixMapTaskTest.IRIS)));

    Instances headerWithSummary = DistributedUtils.makeHeaderWithSummaryAtts(
      train, false);

    CanopyMapTask task = new CanopyMapTask();
    task
      .setOptions(Utils
        .splitOptions(""-filter \""weka.filters.unsupervised.attribute.Remove -R 1\""""));
    task.init(headerWithSummary);

    assertTrue(task.m_missingValuesReplacer != null);
    assertTrue(task.m_filtersToUse != null);
    assertEquals(task.m_filtersToUse.size(), 1);

    assertTrue(task.m_finalFullPreprocess instanceof MakePreconstructedFilter);

    // Expecting a MultiFilter here because the first filter used *must* be the
    // missing values replacer so that missing values are replaced on the
    // original data format before all other filtering happens
    assertTrue(((MakePreconstructedFilter) task.m_finalFullPreprocess)
      .getBaseFilter() instanceof weka.filters.MultiFilter);
  }",./packages/internal/distributedWekaBase/src/test/java/weka/distributed/CanopyTaskTest.java,weka-master
"public RBFRegressorTest(String name) { 
    super(name);  
  }",./packages/internal/RBFNetwork/src/test/java/weka/classifiers/functions/RBFRegressorTest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier 	result;
    
    result = super.getTester();
    result.setNumInstances(40);
    
    return result;
  }",./packages/internal/RBFNetwork/src/test/java/weka/classifiers/functions/RBFRegressorTest.java,weka-master
"public RBFClassifierTest(String name) { 
    super(name);  
  }",./packages/internal/RBFNetwork/src/test/java/weka/classifiers/functions/RBFClassifierTest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier 	result;
    
    result = super.getTester();
    result.setNumInstances(40);
    
    return result;
  }",./packages/internal/RBFNetwork/src/test/java/weka/classifiers/functions/RBFClassifierTest.java,weka-master
"public RBFNetworkTest(String name) { 
    super(name);  
  }",./packages/internal/RBFNetwork/src/test/java/weka/classifiers/functions/RBFNetworkTest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier 	result;
    
    result = super.getTester();
    result.setNumInstances(40);
    
    return result;
  }",./packages/internal/RBFNetwork/src/test/java/weka/classifiers/functions/RBFNetworkTest.java,weka-master
"public OneClassClassifierTest(String name) { 
    super(name);  
  }",./packages/internal/oneClassClassifier/src/test/java/weka/classifiers/meta/OneClassClassifierTest.java,weka-master
"public Dl4jMlpClassifierAbstractTest(String name) {
    super(name);
  }",./packages/internal/wekaDeeplearning4jCore/src/test/java/weka/classifiers/functions/Dl4jMlpClassifierAbstractTest.java,weka-master
"public DenormalizeTest(String name) {
    super(name);
  }",./packages/internal/denormalize/src/test/java/weka/filters/unsupervised/instance/DenormalizeTest.java,weka-master
"public ClassificationViaClusteringTest(String name) { 
    super(name);  
  }",./packages/internal/classificationViaClustering/src/test/java/weka/classifiers/meta/ClassificationViaClusteringTest.java,weka-master
public PrismTest(String name) { super(name);  },./packages/internal/simpleEducationalLearningSchemes/src/test/java/weka/classifiers/rules/PrismTest.java,weka-master
public IB1Test(String name) { super(name);  },./packages/internal/simpleEducationalLearningSchemes/src/test/java/weka/classifiers/lazy/IB1Test.java,weka-master
public Id3Test(String name) { super(name);  },./packages/internal/simpleEducationalLearningSchemes/src/test/java/weka/classifiers/trees/Id3Test.java,weka-master
public NaiveBayesSimpleTest(String name) { super(name);  },./packages/internal/simpleEducationalLearningSchemes/src/test/java/weka/classifiers/bayes/NaiveBayesSimpleTest.java,weka-master
"public sIBTest(String name) { 
    super(name);  
  }",./packages/internal/sequentialInformationalBottleneckClusterer/src/test/java/weka/clusterers/sIBTest.java,weka-master
"public ThresholdSelectorTest(String name) {
    super(name);
  }",./packages/internal/thresholdSelector/src/test/java/weka/classifiers/meta/ThresholdSelectorTest.java,weka-master
"public void testRangeNone() throws Exception {

    int cind = 0;
    ((ThresholdSelector) m_Classifier).setDesignatedClass(new SelectedTag(
      ThresholdSelector.OPTIMIZE_0, ThresholdSelector.TAGS_OPTIMIZE));
    ((ThresholdSelector) m_Classifier).setRangeCorrection(new SelectedTag(
      ThresholdSelector.RANGE_NONE, ThresholdSelector.TAGS_RANGE));
    ArrayList<Prediction> result = null;
    m_Instances.setClassIndex(1);
    result = useClassifier();
    assertTrue(result.size() != 0);
    double minp = 0;
    double maxp = 0;
    for (int i = 0; i < result.size(); i++) {
      NominalPrediction p = (NominalPrediction) result.get(i);
      double prob = p.distribution()[cind];
      if ((i == 0) || (prob < minp)) {
        minp = prob;
      }
      if ((i == 0) || (prob > maxp)) {
        maxp = prob;
      }
    }
    assertTrue(""Upper limit shouldn't increase"", maxp <= 1.0);
    assertTrue(""Lower limit shouldn'd decrease"", minp >= 0.25);
  }",./packages/internal/thresholdSelector/src/test/java/weka/classifiers/meta/ThresholdSelectorTest.java,weka-master
"public void testDesignatedClass() throws Exception {

    for (Tag element : ThresholdSelector.TAGS_OPTIMIZE) {
      ((ThresholdSelector) m_Classifier).setDesignatedClass(new SelectedTag(
        element.getID(), ThresholdSelector.TAGS_OPTIMIZE));
      m_Instances.setClassIndex(1);
      ArrayList<Prediction> result = useClassifier();
      assertTrue(result.size() != 0);
    }
  }",./packages/internal/thresholdSelector/src/test/java/weka/classifiers/meta/ThresholdSelectorTest.java,weka-master
"public void testEvaluationMode() throws Exception {

    for (Tag element : ThresholdSelector.TAGS_EVAL) {
      ((ThresholdSelector) m_Classifier).setEvaluationMode(new SelectedTag(
        element.getID(), ThresholdSelector.TAGS_EVAL));
      m_Instances.setClassIndex(1);
      ArrayList<Prediction> result = useClassifier();
      assertTrue(result.size() != 0);
    }
  }",./packages/internal/thresholdSelector/src/test/java/weka/classifiers/meta/ThresholdSelectorTest.java,weka-master
"public void testNumXValFolds() throws Exception {

    try {
      ((ThresholdSelector) m_Classifier).setNumXValFolds(0);
      fail(""Expected IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
      // OK
    }

    for (int i = 2; i < 20; i += 2) {
      ((ThresholdSelector) m_Classifier).setNumXValFolds(i);
      m_Instances.setClassIndex(1);
      ArrayList<Prediction> result = useClassifier();
      assertTrue(result.size() != 0);
    }
  }",./packages/internal/thresholdSelector/src/test/java/weka/classifiers/meta/ThresholdSelectorTest.java,weka-master
"public CostSensitiveSubsetEvalTest(String name) { 
    super(name);  
  }",./packages/internal/costSensitiveAttributeSelection/src/test/java/weka/attributeSelection/CostSensitiveSubsetEvalTest.java,weka-master
"public CostSensitiveAttributeEvalTest(String name) { 
    super(name);  
  }",./packages/internal/costSensitiveAttributeSelection/src/test/java/weka/attributeSelection/CostSensitiveAttributeEvalTest.java,weka-master
public LeastMedSqTest(String name) { super(name);  },./packages/internal/leastMedSquared/src/test/java/weka/classifiers/functions/LeastMedSqTest.java,weka-master
public KernelLogisticRegressionTest(String name) { super(name);  },./packages/internal/kernelLogisticRegression/src/test/java/weka/classifiers/functions/KernelLogisticRegressionTest.java,weka-master
public MLPRegressorTest(String name) { super(name);  },./packages/internal/multiLayerPerceptrons/src/test/java/weka/classifiers/functions/MLPRegressorTest.java,weka-master
public MLPClassifierTest(String name) { super(name);  },./packages/internal/multiLayerPerceptrons/src/test/java/weka/classifiers/functions/MLPClassifierTest.java,weka-master
"public MLPAutoencoderTest(String name) {
    super(name);
  }",./packages/internal/multiLayerPerceptrons/src/test/java/weka/filters/unsupervised/attribute/MLPAutoencoderTest.java,weka-master
"public PaceRegressionTest(String name) { 
    super(name);  
  }",./packages/internal/paceRegression/src/test/java/weka/classifiers/functions/PaceRegressionTest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier 	result;
    
    result = super.getTester();
    result.setNumInstances(60);
    
    return result;
  }",./packages/internal/paceRegression/src/test/java/weka/classifiers/functions/PaceRegressionTest.java,weka-master
"protected CheckOptionHandler getOptionTesterLoader() {
    return getOptionTester(getLoader());
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"protected CheckGOE getGOETesterLoader() {
    return getGOETester(getLoader());
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"protected CheckOptionHandler getOptionTester(Object o) {
    CheckOptionHandler		result;

    result = new CheckOptionHandler();
    if (o instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) o);
    else
      result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"protected CheckGOE getGOETester(Object o) {
    CheckGOE		result;

    result = new CheckGOE();
    result.setObject(o);
    result.setIgnoredProperties(result.getIgnoredProperties() + "",instances"");
    result.setSilent(true);

    return result;
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkListOptions())
        fail(""Loader: Options cannot be listed via listOptions."");
    }
 }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"public void testSetOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkSetOptions())
        fail(""Loader: setOptions method failed."");
    }
 }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"public void testRemainingOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkRemainingOptions())
        fail(""Loader: There were 'left-over' options."");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"public void testCanonicalUserOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkCanonicalUserOptions())
        fail(""Loader: setOptions method failed"");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"public void testResettingOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkSetOptions())
        fail(""Loader: Resetting of options failed"");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETesterLoader.checkGlobalInfo())
      fail(""Loader: No globalInfo method"");
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETesterLoader.checkToolTips())
      fail(""Loader: Tool tips inconsistent"");
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIFileLoaderTest.java,weka-master
"protected CheckOptionHandler getOptionTesterLoader() {
    return getOptionTester(getLoader());
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"protected CheckGOE getGOETesterLoader() {
    return getGOETester(getLoader());
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"protected CheckOptionHandler getOptionTester(Object o) {
    CheckOptionHandler		result;

    result = new CheckOptionHandler();
    if (o instanceof OptionHandler)
      result.setOptionHandler((OptionHandler) o);
    else
      result.setOptionHandler(null);
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"protected CheckGOE getGOETester(Object o) {
    CheckGOE		result;

    result = new CheckGOE();
    result.setObject(o);
    result.setIgnoredProperties(result.getIgnoredProperties() + "",instances"");
    result.setSilent(true);

    return result;
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkListOptions())
        fail(""Loader: Options cannot be listed via listOptions."");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public void testSetOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkSetOptions())
        fail(""Loader: setOptions method failed."");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public void testRemainingOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkRemainingOptions())
        fail(""Loader: There were 'left-over' options."");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public void testCanonicalUserOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkCanonicalUserOptions())
        fail(""Loader: setOptions method failed"");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public void testResettingOptions() {
    // TODO: currently disabled
    if (!TEST_OPTION_HANDLING)
      return;

    if (m_OptionTesterLoader.getOptionHandler() != null) {
      if (!m_OptionTesterLoader.checkSetOptions())
        fail(""Loader: Resetting of options failed"");
    }
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETesterLoader.checkGlobalInfo())
      fail(""Loader: No globalInfo method"");
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETesterLoader.checkToolTips())
      fail(""Loader: Tool tips inconsistent"");
  }",./packages/internal/niftiLoader/src/test/java/weka/core/converters/NIfTIDirectoryLoaderTest.java,weka-master
"public Dl4jMlpClassifierAbstractTest(String name) {
    super(name);
  }",./packages/internal/wekaDeeplearning4j/src/test/java/weka/classifiers/functions/Dl4jMlpClassifierAbstractTest.java,weka-master
public MLRClassifierTest(String name) { super(name);  },./packages/internal/RPlugin/src/test/java/weka/classifiers/mlr/MLRClassifierTest.java,weka-master
"public RankSearchTest(String name) { 
    super(name);  
  }",./packages/internal/attributeSelectionSearchMethods/src/test/java/weka/attributeSelection/RankSearchTest.java,weka-master
"public GeneticSearchTest(String name) { 
    super(name);  
  }",./packages/internal/attributeSelectionSearchMethods/src/test/java/weka/attributeSelection/GeneticSearchTest.java,weka-master
"public ExhaustiveSearchTest(String name) { 
    super(name);  
  }",./packages/internal/attributeSelectionSearchMethods/src/test/java/weka/attributeSelection/ExhaustiveSearchTest.java,weka-master
"public RandomSearchTest(String name) { 
    super(name);  
  }",./packages/internal/attributeSelectionSearchMethods/src/test/java/weka/attributeSelection/RandomSearchTest.java,weka-master
public DPCTreeTest(String name) { super(name);  },./packages/internal/dualPerturbAndCombine/src/test/java/weka/classifiers/trees/DPCTreeTest.java,weka-master
"public XNVTest(String name) {
        super(name);
    }",./packages/internal/largeScaleKernelLearning/src/test/java/weka/classifiers/functions/XNVTest.java,weka-master
"public NystroemTest(String name) {
        super(name);
    }",./packages/internal/largeScaleKernelLearning/src/test/java/weka/filters/unsupervised/attribute/NystroemTest.java,weka-master
"public void testTypical() {
        Instances icopy = new Instances(m_Instances);

        m_Filter = getFilter();
        Instances result = useFilter();
    }",./packages/internal/largeScaleKernelLearning/src/test/java/weka/filters/unsupervised/attribute/NystroemTest.java,weka-master
"public XMeansTest(String name) { 
    super(name);  
  }",./packages/internal/XMeans/src/test/java/weka/clusterers/XMeansTest.java,weka-master
"public PredictiveAprioriTest(String name) { 
    super(name);  
  }",./packages/internal/predictiveApriori/src/test/java/weka/associations/PredictiveAprioriTest.java,weka-master
"@Test
  public void testNonRegexOneRule() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@quick@@MR@@slow"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(0).contains(""slow""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    System.err.println(secondTransformed);
    assertTrue(secondTransformed.stringValue(0).contains(""slow""));
  }",./packages/internal/distributedWekaSparkDev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexOneRuleTwoAtts() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""second@@MR@@f@@MR@@t@@MR@@dog@@MR@@fish"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test2);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(1).contains(""fish""));
    assertFalse(firstTransformed.stringValue(0).contains(""fish""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    assertFalse(secondTransformed.stringValue(0).contains(""fish""));
    assertFalse(secondTransformed.stringValue(1).contains(""fish""));
  }",./packages/internal/distributedWekaSparkDev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexTwoRules() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@quick@@MR@@slow"",
        ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@turnip@@MR@@carrot"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(0).contains(""slow""));
    assertFalse(firstTransformed.stringValue(0).contains(""carrot""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    System.err.println(secondTransformed);
    assertTrue(secondTransformed.stringValue(0).contains(""slow""));
    assertTrue(secondTransformed.stringValue(0).contains(""carrot""));
  }",./packages/internal/distributedWekaSparkDev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexCaseSensitiveOneRule() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@f@@MR@@quick@@MR@@Slow"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertFalse(firstTransformed.stringValue(0).contains(""slow""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    System.err.println(secondTransformed);
    assertFalse(secondTransformed.stringValue(0).contains(""slow""));
  }",./packages/internal/distributedWekaSparkDev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testRegexOneRule() throws Exception {
    SubstringReplacer replacer = new SubstringReplacer();

    String[] opts = { ""-match-rule"", ""first@@MR@@t@@MR@@t@@MR@@dog$@@MR@@cat"" };
    replacer.setOptions(opts);
    Instances data = getData(s_test1);

    replacer.setInputFormat(data);

    Instances outFormat = replacer.getOutputFormat();
    if (!outFormat.equalHeaders(data)) {
      throw new WekaException(outFormat.equalHeadersMsg(data));
    }

    replacer.input(data.instance(0));
    Instance firstTransformed = replacer.output();
    assertTrue(firstTransformed.stringValue(0).contains(""lazy cat""));
    assertTrue(firstTransformed.stringValue(0).contains(""brown dog""));

    replacer.input(data.instance(1));
    Instance secondTransformed = replacer.output();
    assertFalse(secondTransformed.stringValue(0).contains(""cat""));
  }",./packages/internal/distributedWekaSparkDev/src/test/java/weka/filters/unsupervised/attribute/SubstringReplacerTest.java,weka-master
"@Test
  public void testNonRegexOneRule() throws Exception {
    SubstringLabeler labeler = new SubstringLabeler();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@quick@@MR@@class1"" };
    labeler.setOptions(opts);
    Instances data = getData(s_test1);
    labeler.setInputFormat(data);

    Instances outFormat = labeler.getOutputFormat();
    assertTrue(outFormat != null);
    assertEquals(2, outFormat.numAttributes());
    assertEquals(1, outFormat.classIndex());
    assertTrue(outFormat.classAttribute().isNominal());
    assertEquals(1, outFormat.classAttribute().numValues());
    assertEquals(""class1"", outFormat.classAttribute().value(0));

    labeler.input(data.instance(0));
    Instance firstTransformed = labeler.output();
    assertFalse(firstTransformed.classIsMissing());

    labeler.input(data.instance(1));
    assertFalse(labeler.output().classIsMissing());
    labeler.input(data.instance(2));
    assertFalse(labeler.output().classIsMissing());
  }",./packages/internal/distributedWekaSparkDev/src/test/java/weka/filters/unsupervised/attribute/SubstringLabelerTest.java,weka-master
"@Test
  public void testNonRegexTwoRules() throws Exception {
    SubstringLabeler labeler = new SubstringLabeler();

    String[] opts =
      { ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@dog@@MR@@class1"",
      ""-match-rule"", ""first@@MR@@f@@MR@@t@@MR@@snail@@MR@@class2""};
    labeler.setOptions(opts);
    Instances data = getData(s_test1);
    labeler.setInputFormat(data);

    Instances outFormat = labeler.getOutputFormat();
    assertTrue(outFormat != null);
    assertEquals(2, outFormat.numAttributes());
    assertEquals(1, outFormat.classIndex());
    assertTrue(outFormat.classAttribute().isNominal());
    assertEquals(2, outFormat.classAttribute().numValues());
    Assert.assertEquals(""class1"", outFormat.classAttribute().value(0));

    labeler.input(data.instance(0));
    Instance firstTransformed = labeler.output();
    assertFalse(firstTransformed.classIsMissing());
    assertEquals(""class1"", firstTransformed.stringValue(1));

    labeler.input(data.instance(1));
    Instance secondTransformed = labeler.output();
    assertFalse(secondTransformed.classIsMissing());
    assertEquals(""class2"", secondTransformed.stringValue(1));

  }",./packages/internal/distributedWekaSparkDev/src/test/java/weka/filters/unsupervised/attribute/SubstringLabelerTest.java,weka-master
"@Test
	public void testClusterGenerator(){testClusterer(Clusterers[0]);}",./packages/internal/massiveOnlineAnalysis/src/test/java/moa/integration/SimpleClusterTest.java,weka-master
"@Test
	public void testClustream(){testClusterer(Clusterers[3]);}",./packages/internal/massiveOnlineAnalysis/src/test/java/moa/integration/SimpleClusterTest.java,weka-master
"@Test
	public void testClusTree(){testClusterer(Clusterers[4]);}",./packages/internal/massiveOnlineAnalysis/src/test/java/moa/integration/SimpleClusterTest.java,weka-master
"@Test
	public void testDenStream(){testClusterer(Clusterers[5]);}",./packages/internal/massiveOnlineAnalysis/src/test/java/moa/integration/SimpleClusterTest.java,weka-master
"@Test
	public void testStreamKM(){testClusterer(Clusterers[6]);}",./packages/internal/massiveOnlineAnalysis/src/test/java/moa/integration/SimpleClusterTest.java,weka-master
"void testClusterer(String clusterer) {
		System.out.println(""Processing: "" + clusterer);
		try {
			doTask(new String[]{""EvaluateClustering -l "" + clusterer});
		} catch (Exception e) {
			assertTrue(""Failed on clusterer "" + clusterer + "": "" + e.getMessage(), false);
		}
	}",./packages/internal/massiveOnlineAnalysis/src/test/java/moa/integration/SimpleClusterTest.java,weka-master
"public ChiSquaredAttributeEvalTest(String name) { 
    super(name);  
  }",./packages/internal/chiSquaredAttributeEval/src/test/java/weka/attributeSelection/ChiSquaredAttributeEvalTest.java,weka-master
"public SVMAttributeEvalTest(String name) { 
    super(name);  
  }",./packages/internal/SVMAttributeEval/src/test/java/weka/attributeSelection/SVMAttributeEvalTest.java,weka-master
"public ExcelTest(String name) {
    super(name);
  }",./packages/internal/WekaExcel/src/test/java/weka/core/converters/ExcelTest.java,weka-master
"public HotSpotTest(String name) { 
    super(name);  
  }",./packages/internal/hotSpot/src/test/java/weka/associations/HotSpotTest.java,weka-master
public RealAdaBoostTest(String name) { super(name);  },./packages/internal/realAdaBoost/src/test/java/weka/classifiers/meta/RealAdaBoostTest.java,weka-master
"public WaveletTest(String name) { 
    super(name);
  }",./packages/internal/wavelet/src/test/java/weka/filters/unsupervised/attribute/WaveletTest.java,weka-master
"public void testTypicalHAAR() {
    Instances 	icopy;
    Instances 	result;

    m_Filter = getFilter(Wavelet.ALGORITHM_HAAR, Wavelet.PADDING_ZERO);
    icopy    = new Instances(m_Instances);

    // 1. with class attribute
    result = useFilter();
    // Number of attributes will be power of 2 + class, number of instances won't change
    assertEquals(Wavelet.nextPowerOf2(m_Instances.numAttributes()) + 1, result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());

    // 2. without class attribute
    m_Instances = new Instances(icopy);
    m_Instances.setClassIndex(-1);
    result = useFilter();
    // Number of attributes will be power of 2 + class, number of instances won't change
    assertEquals(Wavelet.nextPowerOf2(m_Instances.numAttributes()), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./packages/internal/wavelet/src/test/java/weka/filters/unsupervised/attribute/WaveletTest.java,weka-master
public HyperPipesTest(String name) { super(name);  },./packages/internal/hyperPipes/src/test/java/weka/classifiers/misc/HyperPipesTest.java,weka-master
"public RaceSearchTest(String name) { 
    super(name);  
  }",./packages/internal/raceSearch/src/test/java/weka/attributeSelection/RaceSearchTest.java,weka-master
"public MultiInstanceWrapperTest(String name) { 
    super(name);
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/MultiInstanceWrapperTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();

    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/MultiInstanceWrapperTest.java,weka-master
"public PropositionalToMultiInstanceTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/PropositionalToMultiInstanceTest.java,weka-master
"public void testTypical() {
    Instances icopy = new Instances(m_Instances);
    Instances result = useFilter();
    // # of instances
    int count = 0;
    for (int i = 0; i < result.numInstances(); i++)
      count += result.instance(i).relationalValue(1).numInstances();
    assertEquals(icopy.numInstances(), count);
    // # of attributes
    count =   result.numAttributes() 
            + result.attribute(1).relation().numAttributes()
            - 1;
    assertEquals(icopy.numAttributes(), count);
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/PropositionalToMultiInstanceTest.java,weka-master
"public void testFilteredClassifier() {
    // nothing
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/PropositionalToMultiInstanceTest.java,weka-master
"public RELAGGSTest(String name) { 
    super(name);
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/RELAGGSTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();

    // explanation of ""(-1 + (2 + 2)*5 + 2*10)*2""
    // -1: rel. attribute gets removed
    // (2 + 2)*5: 2 date and 2 numeric each generate 5 attributes
    // 2*10: 2 nominal attributes with 10 values
    // (...)*2: 2 relational attributes
    assertEquals(m_Instances.numAttributes() + (-1 + (2 + 2)*5 + 2*10)*2, result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/RELAGGSTest.java,weka-master
"public void testMaxCardinality() {
    m_Filter = getFilter();
    ((RELAGGS) m_Filter).setMaxCardinality(5);  // this skips the nominal atts. with 10 values
    Instances result = useFilter();

    // explanation of ""(-1 + (2 + 2)*5)*2""
    // -1: rel. attribute gets removed
    // (2 + 2)*5: 2 date and 2 numeric each generate 5 attributes
    // (...)*2: 2 relational attributes
    assertEquals(m_Instances.numAttributes() + (-1 + (2 + 2)*5)*2, result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/RELAGGSTest.java,weka-master
"public void testNoRelationalAttribute() {
    m_Filter = getFilter();
    
    // delete the rel. attributes
    int i = 0;
    while (i < m_Instances.numAttributes()) {
      if (m_Instances.attribute(i).isRelationValued())
	m_Instances.deleteAttributeAt(i);
      else
	i++;
    }
    
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/RELAGGSTest.java,weka-master
"public MultiInstanceToPropositionalTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/MultiInstanceToPropositionalTest.java,weka-master
"public void testTypical() {
    Instances icopy = new Instances(m_Instances);
    Instances result = useFilter();
    // # of instances
    int count = 0;
    for (int i = 0; i < icopy.numInstances(); i++)
      count += icopy.instance(i).relationalValue(1).numInstances();
    assertEquals(result.numInstances(), count);
    // # of attributes
    count =   icopy.numAttributes() 
            + icopy.attribute(1).relation().numAttributes()
            - 1;
    assertEquals(result.numAttributes(), count);
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/MultiInstanceToPropositionalTest.java,weka-master
"public void testFilteredClassifier() {
    // nothing
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/MultiInstanceToPropositionalTest.java,weka-master
"public MILESFilterTest(String name) { 
    super(name);
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/MILESFilterTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();

    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./packages/internal/multiInstanceFilters/src/test/java/weka/filters/unsupervised/attribute/MILESFilterTest.java,weka-master
public ExtraTreeTest(String name) { super(name);  },./packages/internal/extraTrees/src/test/java/weka/classifiers/trees/ExtraTreeTest.java,weka-master
"public ODFTest(String name) {
    super(name);
  }",./packages/internal/WekaODF/src/test/java/weka/core/converters/ODFTest.java,weka-master
public IsolationForestTest(String name) { super(name);  },./packages/internal/isolationForest/src/test/java/weka/classifiers/misc/IsolationForestTest.java,weka-master
"public FilteredSubsetEvalTest(String name) { 
    super(name);  
  }",./packages/internal/filteredAttributeSelection/src/test/java/weka/attributeSelection/FilteredSubsetEvalTest.java,weka-master
"public FilteredAttributeEvalTest(String name) { 
    super(name);  
  }",./packages/internal/filteredAttributeSelection/src/test/java/weka/attributeSelection/FilteredAttributeEvalTest.java,weka-master
public VFITest(String name) { super(name);  },./packages/internal/votingFeatureIntervals/src/test/java/weka/classifiers/misc/VFITest.java,weka-master
"public MultiBoostABTest(String name) { 
    super(name);  
  }",./packages/internal/multiBoostAB/src/test/java/weka/classifiers/meta/MultiBoostABTest.java,weka-master
"public BFTreeTest(String name) {
    super(name);
  }",./packages/internal/bestFirstTree/src/test/java/weka/classifiers/trees/BFTreeTest.java,weka-master
"public ScikitLearnClustererTest(String name) {
    super(name);
  }",./packages/internal/wekaPython/src/test/java/weka/clusterers/ScikitLearnClustererTest.java,weka-master
"public ScikitLearnClassifierTest(String name) {
    super(name);
  }",./packages/internal/wekaPython/src/test/java/weka/classifiers/sklearn/ScikitLearnClassifierTest.java,weka-master
public AlternatingModelTreeTest(String name) { super(name);  },./packages/internal/alternatingModelTrees/src/test/java/weka/classifiers/trees/AlternatingModelTreeTest.java,weka-master
public SPegasosTest(String name) { super(name);  },./packages/internal/SPegasos/src/test/java/weka/classifiers/functions/SPegasosTest.java,weka-master
"public SimpleCartTest(String name) {
    super(name);
  }",./packages/internal/simpleCART/src/test/java/weka/classifiers/trees/SimpleCartTest.java,weka-master
public ADTreeTest(String name) { super(name);  },./packages/internal/alternatingDecisionTrees/src/test/java/weka/classifiers/trees/ADTreeTest.java,weka-master
public LADTreeTest(String name) { super(name);  },./packages/internal/alternatingDecisionTrees/src/test/java/weka/classifiers/trees/LADTreeTest.java,weka-master
public RidorTest(String name) { super(name);  },./packages/internal/ridor/src/test/java/weka/classifiers/rules/RidorTest.java,weka-master
"public CustomPeriodicTest(String theTest) throws IllegalArgumentException {
    setTest(theTest);
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/core/CustomPeriodicTest.java,weka-master
"public TestPart getLowerTest() {
    return m_lowerTest;
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/core/CustomPeriodicTest.java,weka-master
"public TestPart getUpperTest() {
    return m_upperTest;
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/core/CustomPeriodicTest.java,weka-master
"public void setTest(String theTest) throws IllegalArgumentException {
    /*// check for brackets first
    if (theTest.indexOf('(') < 0 || theTest.indexOf(')') < 0) {
      throw new IllegalArgumentException(""Custom periodic test needs enclosing "" +
      		""parenthesis!"");
    } */
      
/*    // split off brackets
    theTest = theTest.substring(1, theTest.indexOf(')') - 1); */
    theTest = theTest.trim();
    
    if (theTest.indexOf(' ') > 0) {
      String[] parts = theTest.split("" "");
      
      m_lowerTest = parseTest(parts[0]);
      m_upperTest = parseTest(parts[1]);
      m_upperTest.setIsUpper(true);
      
      if (m_upperTest.m_boundOperator == m_lowerTest.m_boundOperator) {
        throw new IllegalArgumentException(""Doesn't make sense to define "" +
        		""an upper and lower test that uses the same operator"");
      }      
    } else {
      m_lowerTest = parseTest(theTest);
    }
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/core/CustomPeriodicTest.java,weka-master
"protected TestPart parseTest(String aTest) throws IllegalArgumentException {
    // check for a label
    if (aTest.indexOf('/') > 0) {
      String[] parts = aTest.split(""/"");
      aTest = parts[0].trim();
      m_label = parts[1].trim();
    }     
    
    aTest = aTest.trim();
    TestPart newTest = new TestPart();
    
    if (aTest.charAt(0) == '=') {
      newTest.m_boundOperator = Operator.EQUALS;
      aTest = aTest.substring(1, aTest.length());
    } else {
      if (aTest.charAt(0) == '>') {
        newTest.m_boundOperator = Operator.GREATER_THAN;
        aTest = aTest.substring(1, aTest.length());
        if (aTest.charAt(0) == '=') {
          newTest.m_boundOperator = Operator.GREATER_THAN_OR_EQUAL_TO;
          aTest = aTest.substring(1, aTest.length());
        }
      } else if (aTest.charAt(0) == '<') {
        newTest.m_boundOperator = Operator.LESS_THAN;
        aTest = aTest.substring(1, aTest.length());
        if (aTest.charAt(0) == '=') {
          newTest.m_boundOperator = Operator.LESS_THAN_OR_EQUAL_TO;
          aTest = aTest.substring(1, aTest.length());
        }
      }
    }
    
    String[] parts = aTest.split("":"");
    // do we have the right number of parts?
    if (parts.length != 10) {
/*      System.err.println(aTest);
      System.err.println(""-- Num parts "" + parts.length);
      for (int z = 0; z < parts.length; z++) {
        System.err.println(parts[z]);
      }*/
      throw new IllegalArgumentException(""Test does not contain 10 parts!"");
    }
    if (parts[0].trim().length() > 0 && parts[0].charAt(0) != '*') {
      newTest.m_year = Integer.parseInt(parts[0].trim());
    }
    if (parts[1].trim().length() > 0 && parts[1].charAt(0) != '*') {
      newTest.m_month = parseMonth(parts[1].trim());
    }
    if (parts[2].trim().length() > 0 && parts[2].charAt(0) != '*') {
      newTest.m_week_of_yr = Integer.parseInt(parts[2].trim());
    }
    if (parts[3].trim().length() > 0 && parts[3].charAt(0) != '*') {
      newTest.m_week_of_month = Integer.parseInt(parts[3].trim());
    }
    if (parts[4].trim().length() > 0 && parts[4].charAt(0) != '*') {
      newTest.m_day_of_yr = Integer.parseInt(parts[4].trim());
    }
    if (parts[5].trim().length() > 0 && parts[5].charAt(0) != '*') {
      newTest.m_day_of_month = Integer.parseInt(parts[5].trim());
    }
    if (parts[6].trim().length() > 0 && parts[6].charAt(0) != '*') {
      newTest.m_day_of_week = parseDay(parts[6].trim());
    }
    if (parts[7].trim().length() > 0 && parts[7].charAt(0) != '*') {
      newTest.m_hour_of_day = Integer.parseInt(parts[7].trim());
    }
    if (parts[8].trim().length() > 0 && parts[8].charAt(0) != '*') {
      newTest.m_min_of_hour = Integer.parseInt(parts[8].trim());
    }
    if (parts[9].trim().length() > 0 && parts[9].charAt(0) != '*') {
      newTest.m_second = Integer.parseInt(parts[9].trim());
    }
    
    return newTest;
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/core/CustomPeriodicTest.java,weka-master
"public CustomPeriodicTestEditor(boolean right) {
    setLayout(new GridLayout(1,10));
    
    /*SpinnerNumberModel snm = new SpinnerNumberModel();
    snm.setValue(1); snm.setMinimum(1); snm.setMaximum(52);
    m_week_of_yr = new JSpinner(snm);
    snm = new SpinnerNumberModel();
    snm.setValue(1); snm.setMinimum(1); snm.setMaximum(5);
    m_week_of_month = new JSpinner(snm);
    snm = new SpinnerNumberModel();
    snm.setValue(1); snm.setMinimum(1); snm.setMaximum(365);
    m_day_of_yr = new JSpinner(snm);
    snm.setValue(1); snm.setMinimum(1); snm.setMaximum(31);
    m_day_of_month = new JSpinner(snm);
    snm = new SpinnerNumberModel();
    snm.setValue(1); snm.setMinimum(1); snm.setMaximum(23);
    m_hour_of_day = new JSpinner(snm);
    snm = new SpinnerNumberModel();
    snm.setValue(1); snm.setMinimum(1); snm.setMaximum(59);
    m_min_of_hour = new JSpinner(snm);
    snm = new SpinnerNumberModel();
    snm.setValue(1); snm.setMinimum(1); snm.setMaximum(59);
    m_second = new JSpinner(snm);*/
    
    add(m_operator);
    add(m_year); add(m_month); add(m_week_of_yr); add(m_week_of_month);
    add(m_day_of_yr); add(m_day_of_month); add(m_day_of_week);
    add(m_hour_of_day); add(m_min_of_hour); add(m_second);
    
    m_right = right;
    if (m_right) {
      m_testToEdit = new CustomPeriodicTest(""<*:*:*:*:*:*:*:*:*:*"");
    }
    m_partToEdit = (m_right) ? m_testToEdit.getUpperTest() : m_testToEdit.getLowerTest();
    
    setupCombos();
    
    
    m_operator.setToolTipText(""Operator"");
    m_operator.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setOperator(m_operator.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_year.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setYear(m_year.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    }); 
    m_year.setToolTipText(""Year"");
    m_month.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setMonth(m_month.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });        
    m_month.setToolTipText(""Month"");
    m_week_of_yr.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setWeekOfYear(m_week_of_yr.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_week_of_yr.setToolTipText(""Week of the year"");
    m_week_of_month.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setWeekOfMonth(m_week_of_month.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_week_of_month.setToolTipText(""Week of the month"");
    m_day_of_yr.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setDayOfYear(m_day_of_yr.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_day_of_yr.setToolTipText(""Day of the year"");
    m_day_of_month.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setDayOfMonth(m_day_of_month.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_day_of_month.setToolTipText(""Day of the month"");
    m_day_of_week.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setDayOfWeek(m_day_of_week.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_day_of_week.setToolTipText(""Day of the week"");
    m_hour_of_day.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setHourOfDay(m_hour_of_day.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_hour_of_day.setToolTipText(""Hour of the day"");
    m_min_of_hour.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setMinuteOfHour(m_min_of_hour.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_min_of_hour.setToolTipText(""Minute of the hour"");
    m_second.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (m_partToEdit != null){
          m_partToEdit.setSecond(m_second.getSelectedItem().toString());
          m_support.firePropertyChange("""", null, null);
        }
      }
    });
    m_second.setToolTipText(""Second"");
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/gui/CustomPeriodicTestEditor.java,weka-master
"public void setTestToEdit(CustomPeriodicTest t) {
    m_testToEdit = t;
    m_partToEdit = (m_right) ? m_testToEdit.getUpperTest() : m_testToEdit.getLowerTest();
    fillGUIElements();
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/gui/CustomPeriodicTestEditor.java,weka-master
"public CustomPeriodicTest getTestBeingEdited() {
    return m_testToEdit;
  }",./packages/internal/timeseriesForecasting/src/main/java/weka/classifiers/timeseries/gui/CustomPeriodicTestEditor.java,weka-master
"public WekaForecasterTest(String name) {
    super(name);
  }",./packages/internal/timeseriesForecasting/src/test/java/weka/classifiers/timeseries/WekaForecasterTest.java,weka-master
"public void testRegressionForecastTwoTargetsConfidenceIntervals() throws Exception {

    boolean success = false;
    Instances wine = getData(""wine_date.arff"");
    weka.test.Regression reg = new weka.test.Regression(this.getClass());

    WekaForecaster forecaster = new WekaForecaster();
    TSLagMaker lagMaker = forecaster.getTSLagMaker();

    try {
      forecaster.setFieldsToForecast(""Fortified,Dry-white"");
      forecaster.setCalculateConfIntervalsForForecasts(12);
      lagMaker.setTimeStampField(""Date"");
      lagMaker.setMinLag(1);
      lagMaker.setMaxLag(12);
      lagMaker.setAddMonthOfYear(true);
      lagMaker.setAddQuarterOfYear(true);
      forecaster.buildForecaster(wine, System.out);
      forecaster.primeForecaster(wine);

      int numStepsToForecast = 12;
      List<List<NumericPrediction>> forecast = 
        forecaster.forecast(numStepsToForecast, System.out);
    
      String forecastString = predsToString(forecast, numStepsToForecast);
      success = true;
      reg.println(forecastString);
    } catch (Exception ex) {
      ex.printStackTrace();
      String msg = ex.getMessage().toLowerCase();
      if (msg.indexOf(""not in classpath"") > -1) {
        return;
      }
    }
    
    if (!success) {
      fail(""Problem during regression testing: no successful predictions generated"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./packages/internal/timeseriesForecasting/src/test/java/weka/classifiers/timeseries/WekaForecasterTest.java,weka-master
"public PLSClassifierTest(String name) { 
    super(name);  
  }",./packages/internal/partialLeastSquares/src/test/java/weka/classifiers/functions/PLSClassifierTest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier	result;
    
    result = super.getTester();
    result.setNumNominal(NUM_COMPONENTS * 2);
    result.setNumNumeric(NUM_COMPONENTS * 2);
    result.setNumString(NUM_COMPONENTS * 2);
    result.setNumDate(NUM_COMPONENTS * 2);
    result.setNumRelational(NUM_COMPONENTS * 2);
    
    return result;
  }",./packages/internal/partialLeastSquares/src/test/java/weka/classifiers/functions/PLSClassifierTest.java,weka-master
"public PLSFilterTest(String name) { 
    super(name);  
  }",./packages/internal/partialLeastSquares/src/test/java/weka/filters/supervised/attribute/PLSFilterTest.java,weka-master
"protected void performTest(int algorithm) {
    Instances icopy = new Instances(m_Instances);
    
    m_Filter = getFilter(NUM_ATTS, algorithm);
    Instances result = useFilter();
    assertEquals(result.numAttributes(), NUM_ATTS + 1);
    assertEquals(result.numInstances(), icopy.numInstances());
    
    m_Filter = getFilter(NUM_ATTS*2, algorithm);
    result = useFilter();
    assertEquals(result.numAttributes(), NUM_ATTS*2 + 1);
    assertEquals(result.numInstances(), icopy.numInstances());
  }",./packages/internal/partialLeastSquares/src/test/java/weka/filters/supervised/attribute/PLSFilterTest.java,weka-master
"public void testPLS1() {
    performTest(PLSFilter.ALGORITHM_PLS1);
  }",./packages/internal/partialLeastSquares/src/test/java/weka/filters/supervised/attribute/PLSFilterTest.java,weka-master
"public void testSIMPLS() {
    performTest(PLSFilter.ALGORITHM_SIMPLS);
  }",./packages/internal/partialLeastSquares/src/test/java/weka/filters/supervised/attribute/PLSFilterTest.java,weka-master
"public ClassifierAttributeEvalTest(String name) { 
    super(name);  
  }",./packages/internal/classifierBasedAttributeSelection/src/test/java/weka/attributeSelection/ClassifierAttributeEvalTest.java,weka-master
"public ClassifierSubsetEvalTest(String name) { 
    super(name);  
  }",./packages/internal/classifierBasedAttributeSelection/src/test/java/weka/attributeSelection/ClassifierSubsetEvalTest.java,weka-master
public UserClassifierTest(String name) { super(name);  },./packages/internal/userClassifier/src/test/java/weka/classifiers/trees/UserClassifierTest.java,weka-master
"public MIDDTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MIDDTest.java,weka-master
"public MINNDTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MINNDTest.java,weka-master
"public MIBoostTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MIBoostTest.java,weka-master
"public SimpleMITest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/SimpleMITest.java,weka-master
"public MISVMTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MISVMTest.java,weka-master
"public TLDSimpleTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/TLDSimpleTest.java,weka-master
"public MILRTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MILRTest.java,weka-master
"public MIPolyKernelTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/supportVector/MIPolyKernelTest.java,weka-master
"public MIRBFKernelTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/supportVector/MIRBFKernelTest.java,weka-master
"public MISMOTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MISMOTest.java,weka-master
"public QuickDDIterativeTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/QuickDDIterativeTest.java,weka-master
"public MDDTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MDDTest.java,weka-master
"public MIWrapperTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MIWrapperTest.java,weka-master
"public MIRITest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MIRITest.java,weka-master
"public TLDTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/TLDTest.java,weka-master
"public TLCTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/TLCTest.java,weka-master
"public MIEMDDTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MIEMDDTest.java,weka-master
"public MITITest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MITITest.java,weka-master
"public MIOptimalBallTest(String name) { 
    super(name);  
  }",./packages/internal/multiInstanceLearning/src/test/java/weka/classifiers/mi/MIOptimalBallTest.java,weka-master
"public RacedIncrementalLogitBoostTest(String name) { 
    super(name);  
  }",./packages/internal/racedIncrementalLogitBoost/src/test/java/weka/classifiers/meta/RacedIncrementalLogitBoostTest.java,weka-master
"public GridSearchTest(String name) { 
    super(name);  
  }",./packages/internal/gridSearch/src/test/java/weka/classifiers/meta/GridSearchTest.java,weka-master
"protected CheckClassifier getTester() {
    CheckClassifier	result;
    
    result = super.getTester();
    result.setNumNumeric(7);
    result.setNumInstances(100);
    
    return result;
  }",./packages/internal/gridSearch/src/test/java/weka/classifiers/meta/GridSearchTest.java,weka-master
"public NBTreeTest(String name) { 
    super(name);  
  }",./packages/internal/naiveBayesTree/src/test/java/weka/classifiers/trees/NBTreeTest.java,weka-master
"public MetaCostTest(String name) { 
    super(name);  
  }",./packages/internal/metaCost/src/test/java/weka/classifiers/meta/MetaCostTest.java,weka-master
"public ENDTest(String name) { 
    super(name);  
  }",./packages/internal/ensemblesOfNestedDichotomies/src/test/java/weka/classifiers/meta/ENDTest.java,weka-master
"public DataNearBalancedNDTest(String name) { 
    super(name);  
  }",./packages/internal/ensemblesOfNestedDichotomies/src/test/java/weka/classifiers/meta/nestedDichotomies/DataNearBalancedNDTest.java,weka-master
"public NDTest(String name) { 
    super(name);  
  }",./packages/internal/ensemblesOfNestedDichotomies/src/test/java/weka/classifiers/meta/nestedDichotomies/NDTest.java,weka-master
"public ClassBalancedNDTest(String name) { 
    super(name);  
  }",./packages/internal/ensemblesOfNestedDichotomies/src/test/java/weka/classifiers/meta/nestedDichotomies/ClassBalancedNDTest.java,weka-master
"public RandomPairNDTest(String name) {
    super(name);  
  }",./packages/internal/ensemblesOfNestedDichotomies/src/test/java/weka/classifiers/meta/nestedDichotomies/RandomPairNDTest.java,weka-master
"public FurthestCentroidNDTest(String name) {
    super(name);  
  }",./packages/internal/ensemblesOfNestedDichotomies/src/test/java/weka/classifiers/meta/nestedDichotomies/FurthestCentroidNDTest.java,weka-master
"public IsotonicRegressionTest(String name) { 
    super(name);  
  }",./packages/internal/isotonicRegression/src/test/java/weka/classifiers/functions/IsotonicRegressionTest.java,weka-master
public NonNegativeLogisticRegressionTest(String name) { super(name);  },./packages/internal/supervisedAttributeScaling/src/test/java/weka/classifiers/functions/NonNegativeLogisticRegressionTest.java,weka-master
"public SupervisedAttributeScalerTest(String name) {

    super(name);
  }",./packages/internal/supervisedAttributeScaling/src/test/java/weka/filters/supervised/attribute/SupervisedAttributeScalerTest.java,weka-master
"public void testTypical() {

    Instances result = useFilter();
    // Number of attributes and instances shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    assertEquals(m_Instances.numInstances(), result.numInstances());
  }",./packages/internal/supervisedAttributeScaling/src/test/java/weka/filters/supervised/attribute/SupervisedAttributeScalerTest.java,weka-master
"public void testFilteredClassifier() {
    Instances		data;
    int			i;
    
    // skip this test if a subclass has set the
    // filtered classifier to null
    if (m_FilteredClassifier == null) {
      return;
    }
    
    try {
      // generate data
      data = getFilteredClassifierData();

      // Only keep numeric attributes
      RemoveType af = new RemoveType();
      af.setInvertSelection(true);
      af.setAttributeType(new SelectedTag(Attribute.NUMERIC,
                                          RemoveType.TAGS_ATTRIBUTETYPE));
      af.setInputFormat(data);
      data = Filter.useFilter(data, af);
      
      // Replace missing values
      ReplaceMissingValues rpv = new ReplaceMissingValues();
      rpv.setInputFormat(data);
      data = Filter.useFilter(data, rpv);
      
      // build classifier
      m_FilteredClassifier.buildClassifier(data);

      // test classifier
      for (i = 0; i < data.numInstances(); i++) {
	m_FilteredClassifier.classifyInstance(data.instance(i));
      }
    }
    catch (Exception e) {
      fail(""Problem with FilteredClassifier: "" + e.toString());
    }
  }",./packages/internal/supervisedAttributeScaling/src/test/java/weka/filters/supervised/attribute/SupervisedAttributeScalerTest.java,weka-master
"public ComplementNaiveBayesTest(String name) { 
    super(name);  
  }",./packages/internal/complementNaiveBayes/src/test/java/weka/classifiers/bayes/ComplementNaiveBayesTest.java,weka-master
public OrdinalClassClassifierTest(String name) { super(name);  },./packages/internal/ordinalClassClassifier/src/test/java/weka/classifiers/meta/OrdinalClassClassifierTest.java,weka-master
public LOFTest(String name) { super(name);  },./packages/internal/localOutlierFactor/src/test/java/weka/classifiers/misc/LOFTest.java,weka-master
"public LOFTest(String name) {
    super(name);
  }",./packages/internal/localOutlierFactor/src/test/java/weka/filters/unsupervised/attribute/LOFTest.java,weka-master
"protected void performTest() {
    Instances icopy = new Instances(m_Instances);
    Instances result = null;
    try {
      m_Filter.setInputFormat(icopy);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on setInputFormat(): \n"" + ex.getMessage());
    }
    try {
      result = Filter.useFilter(icopy, m_Filter);
      assertNotNull(result);
    } 
    catch (Exception ex) {
      ex.printStackTrace();
      fail(""Exception thrown on useFilter(): \n"" + ex.getMessage());
    }

    assertEquals(icopy.numInstances(), result.numInstances());
    assertEquals(icopy.numAttributes() + 1, result.numAttributes());
  }",./packages/internal/localOutlierFactor/src/test/java/weka/filters/unsupervised/attribute/LOFTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    performTest();
  }",./packages/internal/localOutlierFactor/src/test/java/weka/filters/unsupervised/attribute/LOFTest.java,weka-master
"public IterativeAbsoluteErrorRegressionTest(String name) { 
    super(name);  
  }",./packages/internal/iterativeAbsoluteErrorRegression/src/test/java/weka/classifiers/meta/IterativeAbsoluteErrorRegressionTest.java,weka-master
"public ConsistencySubsetEvalTest(String name) { 
    super(name);  
  }",./packages/internal/consistencySubsetEval/src/test/java/weka/attributeSelection/ConsistencySubsetEvalTest.java,weka-master
"public GradingTest(String name) { 
    super(name);  
  }",./packages/internal/grading/src/test/java/weka/classifiers/meta/GradingTest.java,weka-master
public ConjunctiveRuleTest(String name) { super(name);  },./packages/internal/conjunctiveRule/src/test/java/weka/classifiers/rules/ConjunctiveRuleTest.java,weka-master
"public TertiusTest(String name) { 
    super(name);  
  }",./packages/external/tertius/src/test/java/weka/associations/TertiusTest.java,weka-master
public WinnowTest(String name) { super(name);  },./packages/external/winnow/src/test/java/weka/classifiers/functions/WinnowTest.java,weka-master
"public CitationKNNTest(String name) { 
    super(name);  
  }",./packages/external/citationKNN/src/test/java/weka/classifiers/mi/CitationKNNTest.java,weka-master
"public OSDLTest(String name) {
    super(name);
  }",./packages/external/ordinalStochasticDominance/src/test/java/weka/classifiers/misc/OSDLTest.java,weka-master
public EMImputationTest(String name) { super(name);  },./packages/external/EMImputation/src/test/java/weka/filters/unsupervised/attribute/EMImputationTest.java,weka-master
"public void testTypical() {
    Instances result = useFilter();
    // Number of attributes shouldn't change
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    // Number of instances may change (if an instance has all missing values)
    // assertEquals(m_Instances.numInstances(), result.numInstances());
    for (int j = 0; j < result.numAttributes(); j++) {
      if (j == m_Instances.classIndex() && m_Instances.attribute(j).isNumeric() == false) {
        continue;
      }
      AttributeStats currentStats = m_Instances.attributeStats(j);
      if (currentStats.distinctCount < 2) {
        continue;
      }
      assertTrue(""All missing values except for those in nonnumeric class "" +
                  ""attributes should be replaced."", 
                  result.attributeStats(j).missingCount == 0);
    }
  }",./packages/external/EMImputation/src/test/java/weka/filters/unsupervised/attribute/EMImputationTest.java,weka-master
public WeightedClassifierTest(String name) { super(name);  },./packages/external/classAssociationRules/src/test/java/weka/classifiers/rules/car/WeightedClassifierTest.java,weka-master
public JCBATest(String name) { super(name);  },./packages/external/classAssociationRules/src/test/java/weka/classifiers/rules/car/JCBATest.java,weka-master
"public CLOPETest(String name) { 
    super(name);  
  }",./packages/external/CLOPE/src/test/java/weka/clusterers/CLOPETest.java,weka-master
"public SnowballStemmerEnglishTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerEnglishTest.java,weka-master
"public SnowballStemmerPorterTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerPorterTest.java,weka-master
"public SnowballStemmerHungarianTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerHungarianTest.java,weka-master
"public SnowballStemmerFinnishTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerFinnishTest.java,weka-master
"public SnowballStemmerFrenchTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerFrenchTest.java,weka-master
"public SnowballStemmerDutchTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerDutchTest.java,weka-master
"public SnowballStemmerTurkishTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerTurkishTest.java,weka-master
"public SnowballStemmerDefaultTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerDefaultTest.java,weka-master
"public SnowballStemmerItalianTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerItalianTest.java,weka-master
"public SnowballStemmerNorwegianTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerNorwegianTest.java,weka-master
"public SnowballStemmerGermanTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerGermanTest.java,weka-master
"public SnowballStemmerDanishTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerDanishTest.java,weka-master
"public AbstractCustomSnowballStemmerTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler result;

    result = new CheckOptionHandler();
    if (getStemmer() instanceof OptionHandler) {
      result.setOptionHandler((OptionHandler) getStemmer());
    } else {
      result.setOptionHandler(null);
    }
    result.setUserOptions(new String[0]);
    result.setSilent(true);

    return result;
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"protected CheckGOE getGOETester() {
    CheckGOE result;

    result = new CheckGOE();
    result.setObject(getStemmer());
    result.setSilent(true);

    return result;
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testSerialVersionUID() {
    boolean result;

    result = !SerializationHelper.needsUID(m_Stemmer.getClass());

    if (!result) {
      fail(""Doesn't declare serialVersionUID!"");
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testBuildInitialization() {
    boolean result;
    int i;
    int n;
    int m;
    String[][][] processed;
    String[] data;
    String msg;

    // process data twice
    processed = new String[2][m_Data.length][];
    for (n = 0; n < 2; n++) {
      for (i = 0; i < m_Data.length; i++) {
        try {
          data = tokenize(m_Data[i]);
          processed[n][i] = new String[data.length];
          for (m = 0; m < data.length; m++)
            processed[n][i][m] = m_Stemmer.stem(data[m]);
        } catch (Exception e) {
          processed[n][i] = new String[]{null};
        }
      }
    }

    // was the same data produced?
    result = true;
    msg = """";
    for (i = 0; i < m_Data.length; i++) {
      if (processed[0].length == processed[1].length) {
        for (n = 0; n < processed[0][i].length; n++) {
          if (!processed[0][i][n].equals(processed[1][i][n])) {
            result = false;
            msg = ""different stemming results"";
            break;
          }
        }
      } else {
        result = false;
        msg = ""different number of words"";
        break;
      }
    }

    if (!result) {
      fail(""Incorrect build initialization ("" + msg + "")!"");
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testRegression() {
    int i;
    boolean succeeded;
    Regression reg;
    String[] tokens;
    String[] results;

    reg = new Regression(this.getClass());
    succeeded = false;

    for (i = 0; i < m_Data.length; i++) {
      try {
	tokens = tokenize(m_Data[i]);
	results = useStemmer(tokens);
        succeeded = true;
        reg.println(predictionsToString(tokens, results));
      } catch (Exception e) {
	results = new String[0];
      }
    }

    if (!succeeded) {
      fail(""Problem during regression testing: no successful results generated for any string"");
    }

    try {
      String diff = reg.diff();
      if (diff == null) {
        System.err.println(""Warning: No reference available, creating."");
      } else if (!diff.equals("""")) {
        fail(""Regression test failed. Difference:\n"" + diff);
      }
    } catch (IOException ex) {
      fail(""Problem during regression testing.\n"" + ex);
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testListOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkListOptions()) {
        fail(""Options cannot be listed via listOptions."");
      }
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testSetOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions()) {
        fail(""setOptions method failed."");
      }
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testDefaultOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkDefaultOptions()) {
        fail(""Default options were not processed correctly."");
      }
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testRemainingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkRemainingOptions()) {
        fail(""There were 'left-over' options."");
      }
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testCanonicalUserOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkCanonicalUserOptions()) {
        fail(""setOptions method failed"");
      }
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testResettingOptions() {
    if (m_OptionTester.getOptionHandler() != null) {
      if (!m_OptionTester.checkSetOptions()) {
        fail(""Resetting of options failed"");
      }
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testGlobalInfo() {
    if (!m_GOETester.checkGlobalInfo()) {
      fail(""No globalInfo method"");
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public void testToolTips() {
    if (!m_GOETester.checkToolTips()) {
      fail(""Tool tips inconsistent"");
    }
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/AbstractCustomSnowballStemmerTest.java,weka-master
"public SnowballStemmerRussianTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerRussianTest.java,weka-master
"public SnowballStemmerPortugueseTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerPortugueseTest.java,weka-master
"public SnowballStemmerRomanianTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerRomanianTest.java,weka-master
"public SnowballStemmerSwedishTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerSwedishTest.java,weka-master
"public SnowballStemmerSpanishTest(String name) {
    super(name);
  }",./packages/external/snowball-stemmers/src/test/java/weka/core/stemmers/SnowballStemmerSpanishTest.java,weka-master
"public LBRTest(String name) { 
    super(name);  
  }",./packages/external/lazyBayesianRules/src/test/java/weka/classifiers/lazy/LBRTest.java,weka-master
"public DecorateTest(String name) { 
    super(name);  
  }",./packages/external/decorate/src/test/java/weka/classifiers/meta/DecorateTest.java,weka-master
"public LibLINEARTest( String name ) {
        super(name);
    }",./packages/external/LibLINEAR/src/test/java/weka/classifiers/functions/LibLINEARTest.java,weka-master
"public SignificanceAttributeEvalTest(String name) { 
    super(name);  
  }",./packages/external/probabilisticSignificanceAE/src/test/java/weka/attributeSelection/SignificanceAttributeEvalTest.java,weka-master
"public LatentSemanticAnalysisTest(String name) { 
    super(name);  
  }",./packages/external/latentSemanticAnalysis/src/test/java/weka/attributeSelection/LatentSemanticAnalysisTest.java,weka-master
"public OPTICSTest(String name) { 
    super(name);  
  }",./packages/external/optics_dbScan/src/test/java/weka/clusterers/OPTICSTest.java,weka-master
"public DBSCANTest(String name) { 
    super(name);  
  }",./packages/external/optics_dbScan/src/test/java/weka/clusterers/DBSCANTest.java,weka-master
"public LibSVMTest(String name) { 
    super(name);  
  }",./packages/external/LibSVM/src/test/java/weka/classifiers/functions/LibSVMTest.java,weka-master
"public SMOTETest(String name) {
    super(name);
  }",./packages/external/SMOTE/src/test/java/weka/filters/supervised/instance/SMOTETest.java,weka-master
public FURIATest(String name) { super(name);  },./packages/external/fuzzyUnorderedRuleInduction/src/test/java/weka/classifiers/rules/FURIATest.java,weka-master
"public ScatterSearchV1Test(String name) { 
    super(name);  
  }",./packages/external/tabuAndScatterSearch/src/test/java/weka/attributeSelection/ScatterSearchV1Test.java,weka-master
"public TabuSearchTest(String name) { 
    super(name);  
  }",./packages/external/tabuAndScatterSearch/src/test/java/weka/attributeSelection/TabuSearchTest.java,weka-master
public MultilayerPerceptronCSTest(String name) { super(name);  },./packages/external/multilayerPerceptronCS/src/test/java/weka/classifiers/functions/MultilayerPerceptronCSTest.java,weka-master
"public StackingCTest(String name) { 
    super(name);  
  }",./packages/external/stackingC/src/test/java/weka/classifiers/meta/StackingCTest.java,weka-master
public BayesianLogisticRegressionTest(String name) { super(name);  },./packages/external/bayesianLogisticRegression/src/test/java/weka/classifiers/bayes/BayesianLogisticRegressionTest.java,weka-master
public DMNBtextTest(String name) { super(name);  },./packages/external/DMNBtext/src/test/java/weka/classifiers/bayes/DMNBtextTest.java,weka-master
"public FLRTest(String name) { 
    super(name);  
  }",./packages/external/fuzzyLaticeReasoning/src/test/java/weka/classifiers/misc/FLRTest.java,weka-master
"public NormalizeTest(String name) { 
    super(name);  
  }",./packages/external/normalize/src/test/java/weka/filters/unsupervised/instance/NormalizeTest.java,weka-master
"public void testTypical() {
    m_Filter = getFilter();
    Instances result = useFilter();
    assertEquals(m_Instances.numAttributes(), result.numAttributes());
    // at least one instance must be different
    boolean equal = true;
    for (int i = 0; i < m_Instances.numInstances(); i++) {
      if (m_Comparator.compare(
            m_Instances.instance(i), result.instance(i)) != 0) {
        equal = false;
        break;
      }
    }
    if (equal)
      fail(""Nothing changed!"");
  }",./packages/external/normalize/src/test/java/weka/filters/unsupervised/instance/NormalizeTest.java,weka-master
public J48graftTest(String name) { super(name);  },./packages/external/J48graft/src/test/java/weka/classifiers/trees/J48graftTest.java,weka-master
"public LinearForwardSelectionTest(String name) { 
    super(name);  
  }",./packages/external/linearForwardSelection/src/test/java/weka/attributeSelection/LinearForwardSelectionTest.java,weka-master
"public SubsetSizeForwardSelectionTest(String name) { 
    super(name);  
  }",./packages/external/linearForwardSelection/src/test/java/weka/attributeSelection/SubsetSizeForwardSelectionTest.java,weka-master
public FTTest(String name) { super(name);  },./packages/external/functionalTrees/src/test/java/weka/classifiers/trees/FTTest.java,weka-master
"public GeneralizedSequentialPatternsTest(String name) { 
    super(name);  
  }",./packages/external/generalizedSequentialPatterns/src/test/java/weka/associations/GeneralizedSequentialPatternsTest.java,weka-master
"public HNBTest(String name) { 
    super(name);  
  }",./packages/external/hiddenNaiveBayes/src/test/java/weka/classifiers/bayes/HNBTest.java,weka-master
"public ElasticNetTest( String name ) {
        super(name);
    }",./packages/external/elasticNet/src/test/java/weka/classifiers/functions/ElasticNetTest.java,weka-master
public RotationForestTest(String name) { super(name);  },./packages/external/rotationForest/src/test/java/weka/classifiers/meta/RotationForestTest.java,weka-master
"public SymmetricalUncertAttributeSetEvalTest(String name) { 
    super(name);  
  }",./packages/external/fastCorrBasedFS/src/test/java/weka/attributeSelection/SymmetricalUncertAttributeSetEvalTest.java,weka-master
"public FCBFSearchTest(String name) { 
    super(name);  
  }",./packages/external/fastCorrBasedFS/src/test/java/weka/attributeSelection/FCBFSearchTest.java,weka-master
"public CascadeSimpleKMeansTest(String name) { 
    super(name);  
  }",./packages/external/cascadeKMeans/src/test/java/weka/clusterers/CascadeSimpleKMeansTest.java,weka-master
"public EnsembleSelectionTest(String name) { 
    super(name);  
  }",./packages/external/ensembleLibrary/src/test/java/weka/classifiers/meta/EnsembleSelectionTest.java,weka-master
"public WAODETest(String name) { 
    super(name);  
  }",./packages/external/averagedOneDependenceEstimators/src/test/java/weka/classifiers/bayes/WAODETest.java,weka-master
"public AODETest(String name) { 
    super(name);  
  }",./packages/external/averagedOneDependenceEstimators/src/test/java/weka/classifiers/bayes/AODETest.java,weka-master
"public AODEsrTest(String name) { 
    super(name);  
  }",./packages/external/averagedOneDependenceEstimators/src/test/java/weka/classifiers/bayes/AODEsrTest.java,weka-master
